<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>游记 - NJUSC 2025</title>
    <link href="/rec-2025njusc/"/>
    <url>/rec-2025njusc/</url>
    
    <content type="html"><![CDATA[<p>8.23-8.24.</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>先进的 NJUSC，赛时有榜看。</p><p>南京大牌档，好吃。</p><h2 id="Day-0-Morning"><a href="#Day-0-Morning" class="headerlink" title="Day 0 Morning"></a>Day 0 Morning</h2><p>笔试。</p><p>二三四都是幽默题，但是 T2 把集合的“可数”理解成了“有限”，然后就死了。</p><p>T1 是专考 Sylow 的理论，不会就是不会，丢掉。T5 挺有意思的。</p><blockquote><p>证明：一个 $n$ 点 $m$ 边的图，存在一种把点集划分为 $S,T$ 的方式，满足（记 $E(S)$ 表示 $S$ 点集内边数）$\max(E(S),E(T))\le \frac{m}{3}$。</p></blockquote><p>Hint：调整法。其实赛时我就会这个 hint 了，但一直没接着往下想。</p><p>唉，笔试打的还是太蠢了，后面看来。</p><h2 id="Day-0-Afternoon"><a href="#Day-0-Afternoon" class="headerlink" title="Day 0 Afternoon"></a>Day 0 Afternoon</h2><p>T1 T2 过于简单，T3 过于难了。</p><blockquote><p>给一个三角形网格，边界是一个六边形，长度依次为 $n,m,n,m,n,m$，然后数这里面有多少个格点等边三角形，满足其边不经过顶点以外的格点。数据范围忘了，还挺大的，好像有 $10^{10}$ 级别。</p></blockquote><p>基本的观察是转化成数六边形，而这个六边形应该被理解为一个大的正三角形扣掉三个小的正三角形。一开始推了一个假算，以为两维必须都不超过边长，然后最后一点时间想到容斥，搞不定，倒闭了。</p><h2 id="Day-1-Morning"><a href="#Day-1-Morning" class="headerlink" title="Day 1 Morning"></a>Day 1 Morning</h2><p>T1 过于简单，T2 T3 过于难了。</p><blockquote><p>给质数 $p$，以及 $0\le x&lt; p$，构造 ${1^{-1},2^{-1},\ldots,5000^{-1}}$ 的一个子集，使得 $\bmod p$ 意义下其和为 $x$。$p\le 10^{18}$。</p><p>依次输入 $n=10^5$ 个 $[0,1]$ 的随机实数，每次必须在线地把它填到某一位，要求最后的序列里 $\sum<em>{1\le i&lt;n} |a_i - a</em>{i-1}|\le 50$。</p></blockquote><p>T2 感觉很熟悉，但是除了生日悖论以外没有有效想法。T3 大家都会了，然后我一开始写了个 40 pts，不知道为什么所有人都是 pretest 42 pts，然后改笨一点，写成每个数就在它的前驱和后继中间找一个位置，找不到就尽量靠近点，然后就 42 了。当时以为分块拿不到分，最后听说分块有 50+，我服了。然后后来盒出来 T2 是之前联考听过的讲课，那完蛋了。</p><p>最终 $40+100+100+0+100+20+41$，大概略高于中位数吧，感觉远远不如 ymh 大神 D2T2 40pts，以及某两个不知道的人 D2T2 速切，也不如 D1T3 打 35pts 暴力的老哥和……唉枚举不完了。反正现在自己的水平就是一个 NJU 营都只是大概在中位数上面一点，还得磨练。就是笔试的时候完全不在线；机试就是勉勉强强，第一场 T3 暴力其实我觉得不容易，不知道为什么所有人都会；第二场不写分块也是有点蠢，就是在错误的想法里面耗了太久，以为应该把序列分成一些连续段，但其实没有用。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>踩坑记录 - Mac 使用 Virtualbox 安装 Linux Ubuntu Desktop 虚拟机</title>
    <link href="/tech-virtualbox/"/>
    <url>/tech-virtualbox/</url>
    
    <content type="html"><![CDATA[<h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p>动机是本人想要安装 NOI Linux 虚拟机，然后下载不下来。最后发现最旧支持本机芯片（Apple M3，属 ARM）的 Ubuntu Desktop 是 Ubuntu Desktop 25。毅然决然下载 Ubuntu Desktop 25。</p><h2 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h2><p>首先下载功能扩展包，<code>sudo apt install virtualbox-ext-pack</code>。</p><p>然后就是在 Virtualbox 配置里面写好配置（默认即可，不用写挂载点路径）。但是本人并未就此挂载成功，而且也没有找到 <code>vboxsf</code> 用户组，即使手动挂载也还要修改权限，文件夹属于 <code>root</code>。</p><p>所以我们修改 <code>/etc/fstab</code>，添加以下内容：</p><p><code>FILENAME /MOUNT-POINT-PATH vboxsf uid=1000,gid=1000 0 0</code></p><p>FILENAME 是 Virtualbox 配置处的文件夹名称，MOUNT-POINT-PATH 是虚拟机的挂载文件夹，<code>uid=1000,gid=1000</code> 是指这个挂载让权限归到“我”这个用户，而“我”的用户 ID 和用户组 ID 都是 1000，因此这里可以根据你对权限的意愿，修改为其他用户组。</p><p>重启之后就行了。</p><h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>设置里面，Keyboard -&gt; Input Sources -&gt; <code>+</code>。</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - PKUWC 2025 &amp; WC 2025 &amp; APIO 2025</title>
    <link href="/rec-2025pkuwc-2025wc-2025apio/"/>
    <url>/rec-2025pkuwc-2025wc-2025apio/</url>
    
    <content type="html"><![CDATA[<p>PKUWC：100+41+20+41+73+36。</p><p>WC：100+50+5。交换徽章。见到了 Purslane 本人，比照片帅。</p><p>APIO：37+12+5。</p><p>今日之耻。潦草的 2025 赛季，顺利成为人下人。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - CCPC Final 2022 B Disjoint Set Union</title>
    <link href="/sol-QOJ6502/"/>
    <url>/sol-QOJ6502/</url>
    
    <content type="html"><![CDATA[<p>好难的刻画！</p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>给一个合法的并查集数组，构造一组方案使得它变为给定的目标并查集数组，可用的操作包括路径压缩的 <code>find(x)</code> 和合并联通块 <code>unite(x, y)</code>。多组数据 $n\le 10^3, \sum n\le 5\times 10^6$。</p><h2 id="等价转换"><a href="#等价转换" class="headerlink" title="等价转换"></a>等价转换</h2><p>我们假设初始数组为 $a_i$，目标数组为 $b_i$。</p><p>实际上是什么意思？追踪一下 $a_p$ 的变化，发现 $b_p$ 可能是这两种 case 之一：</p><ul><li>关于 $p$ 最后一次操作实现了 <code>find(p)</code>，此时 $p$ 所在联通分量的根是 $b_p$；</li><li>关于 $p$ 最后一次操作是 <code>unite(p, b[p])</code>，这之前 $p, b_p$ 分别是各自联通分量的根。</li></ul><p><strong>最后一次操作</strong>的限制就是这之后，$p$ 子树内不再有任何操作，除了当 $p$ 深度（指和根的距离）为 $1$ 时它的儿子的 <code>find()</code> 操作，这种操作并不会改变其他结构。</p><p>其实可以稍微化简一下，整个过程应该有一些 <code>unite()</code> 来划分阶段。而每个阶段对于每个 $p$，只要 $a_p\neq b_p$，深度 $\ge 2$ 都一定要执行一次 <code>find(p)</code>。</p><p>那么 <code>find()</code> 的逻辑就比较清楚了，但是我们怎么 <code>unite()</code>？</p><h2 id="处理限制"><a href="#处理限制" class="headerlink" title="处理限制"></a>处理限制</h2><p>我们知道初始时满足 $a_p\neq b_p$ 的 $p$ 一定会进行 <code>find(p)</code>。那么这一轮过后这个并查集形如菊花森林。考虑菊花根和非菊花根的限制。</p><ul><li>菊花根的限制：一定是先确定 $p$，然后把 $p$ 连成 $b_p$ 的儿子，之后可能确定 $b_p$。如果连之前 $p$ 和 $b_p$ 在不同联通分量，则要 <code>unite(p, b[p])</code>。</li><li>非菊花根的限制：假设已经进行完初始必需的操作，只讨论 $a_p\neq b_p$ 的情况。在某个时刻 $b_p$ 是 $p$ 的祖先（二级父亲，联通分量的根），然后进行一次 <code>find(p)</code> 做到转移。所以一定是先确定 $a_p$，然后可能确定 $b_p$。</li></ul><p>归纳一下就是，假设已经进行完初始必需的操作，在所有 $a_p\neq b_p$ 的情况，$a_p$ 要先于 $b_p$ 完成最后的操作。</p><p>这个形式就可以建图，做拓扑排序，如果有一个合法的拓扑序就构造方案，假设拓扑序的当前位是 $p$，它必须有 $a_p=p\land a_p\neq b_p$（否则无法进行操作）。我们找到它应该 <code>unite()</code> 的目标，<code>unite()</code> 后完成它所有儿子的 <code>find()</code>。所谓 <code>unite()</code> 的目标，就是接下来最早出现的点，满足 $p$ 和 $p$ 的儿子们可能以它为 $b$ 值（如果更早，不优；如果更晚，会漏）。如果这个过程不可以正确进行，或者最后 $a\neq b$，都是无解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> T, N, fa[MXN], tgt[MXN];<br><span class="hljs-type">int</span> deg[MXN], que[MXN], qh, qt, ord[MXN];<br>vector&lt;tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; ans;<br>vector&lt;<span class="hljs-type">int</span>&gt; lim[MXN];<br><br><span class="hljs-type">int</span> _find(<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> fa[x] ^ x ? fa[x] = _find(fa[x]) : x; &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (fa[fa[x]] ^ fa[x]) ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>, x);<br>  <span class="hljs-keyword">return</span> _find(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">2</span>, x, y);<br>  fa[_find(x)] = _find(y);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) cin &gt;&gt; fa[i], --fa[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) cin &gt;&gt; tgt[i], --tgt[i];<br>  ans.<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">p</span><span class="hljs-params">(i)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">c</span>(N); tgt[p] ^ p &amp;&amp; c--;) p = tgt[p];<br>    <span class="hljs-keyword">if</span> (tgt[p] ^ p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) deg[i] = <span class="hljs-number">0</span>, lim[i].<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (fa[i] ^ tgt[i]) &#123;<br>      <span class="hljs-built_in">find</span>(i);<br>      <span class="hljs-keyword">if</span> (fa[i] ^ tgt[i]) lim[fa[i]].<span class="hljs-built_in">push_back</span>(tgt[i]), ++deg[tgt[i]];<br>    &#125;<br>  &#125;<br>  qh = qt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) <span class="hljs-keyword">if</span> (!deg[i]) que[qt++] = i;<br>  <span class="hljs-keyword">while</span> (qh != qt) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(que[qh])</span></span>;<br>    ord[c] = qh++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : lim[c]) <span class="hljs-keyword">if</span> (!--deg[n]) que[qt++] = n;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (qt != N) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">p</span><span class="hljs-params">(que[i])</span></span>;<br>    <span class="hljs-keyword">if</span> (fa[p] == tgt[p] || fa[p] ^ p) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != N; ++j)<br>      <span class="hljs-keyword">if</span> (fa[j] == p &amp;&amp; fa[j] ^ tgt[j] &amp;&amp; (f == <span class="hljs-number">-1</span> || ord[tgt[j]] &lt; ord[f]))<br>        f = tgt[j];<br>    <span class="hljs-keyword">if</span> (~f) &#123;<br>      <span class="hljs-built_in">merge</span>(p, f);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != N; ++j)<br>        <span class="hljs-keyword">if</span> (fa[j] == p &amp;&amp; fa[j] ^ tgt[j]) <span class="hljs-built_in">find</span>(j);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i)<br>    <span class="hljs-keyword">if</span> (fa[i] != tgt[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span> &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [o, x, y] : ans)<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;1 &quot;</span> &lt;&lt; x + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;2 &quot;</span> &lt;&lt; x + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (cin &gt;&gt; T; T--;) <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">work</span>()) cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构造</tag>
      
      <tag>并查集</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AGC071A XOR Cross Over</title>
    <link href="/sol-AGC071A/"/>
    <url>/sol-AGC071A/</url>
    
    <content type="html"><![CDATA[<p>变身喜欢降降降的小朋友。评分系统我问你，A、B、C 真的是同一个紫吗？</p><h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>给一个数列 ${a<em>1,\ldots,a_n}$。每次可以选择一个长度不为 $1$ 的数列拆成非空的两半：${a_1,\ldots,a</em>{k-1}}$ 和 ${a_k,\ldots,a_n}$，然后每个元素都异或上另一半的异或和。最小化这样拆分 $n-1$ 次后的元素和。$n\le 500,a_i&lt; 2^{40}$。</p><h2 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h2><p>关注一下这个过程中值的变化。比如说现在有一个数列，根据题意，它们在以前被异或的总和是相同的，假设叫做 $t$。再稍微假设一下分裂成的两半的原始数分别是 ${a<em>1,\ldots,a_n}$ 和 ${b_1,\ldots,b_m}$，就是说它们现在的值分别是 ${a_1\oplus t,\ldots,a_n\oplus t}$ 和 ${b_1\oplus t,\ldots,b_m\oplus t}$。令 $B=\oplus</em>{1\le i\le m} b_i$，我们追踪 $a$ 中元素的变化（$b$ 为对称的情况）：</p><ul><li>$m$ 是偶数时，$a_i\oplus t$ 变为 $a_i\oplus B\oplus t$。</li><li>$m$ 是奇数时，$a_i\oplus t$ 变为 $a_i\oplus B$。</li></ul><h2 id="刻画"><a href="#刻画" class="headerlink" title="刻画"></a>刻画</h2><p>把分裂的过程画成线段树，$a_i$ 现在的值是：找到其祖先中最低的，令其为 $a’$，满足 $a’$ 的兄弟长度为奇数，$a_i$ 现在的值即为 $a’$ 父亲区间的异或和。</p><p>或者，不如说：找到其祖先中最低的，令其为 $a’$，满足 $a’$ 的长度为偶数，$a_i$ 现在的值即为 $a’$ 区间的异或和。</p><p>如果不存在 $a’$，必然有 $n$ 是奇数，手动模拟发现 $a_i$ 现在的值是整个序列的异或和，我们称它为“特殊点”。</p><h2 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h2><p>令 $f(l,r)$ 表示把 $[l,r)$ 中的区间拆到一个线段树节点下，最小的元素和。对于长为奇数的区间，不计入“特殊点”，因为它会被更新。边界情况是长度为 $f(i,i+1)=0$。</p><p>枚举分界点 $k$。</p><ul><li>两个子树均为奇数长：$f(l,r)\leftarrow f(l,k)+f(k,r)+2S$，其中 $S$ 表示 $[l,r)$ 区间的异或和。</li><li>否则：$f(l,r)\leftarrow f(l,k)+f(k,r)$。</li></ul><p>最后输出时处理全局中的“特殊点”。</p><p>时间复杂度 $O(n^3)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">505</span>;<br><span class="hljs-type">const</span> ll INF = <span class="hljs-number">1LL</span> &lt;&lt; <span class="hljs-number">62</span>;<br><span class="hljs-type">int</span> N;<br>ll arr[MXN], pfs[MXN];<br>ll mns[MXN][MXN];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) cin &gt;&gt; arr[i], pfs[i + <span class="hljs-number">1</span>] = pfs[i] ^ arr[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">len</span>(<span class="hljs-number">2</span>); len &lt;= N; ++len) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">l</span>(<span class="hljs-number">0</span>); l + len &lt;= N; ++l) &#123;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">r</span><span class="hljs-params">(l + len)</span></span>;<br>      <span class="hljs-function">ll <span class="hljs-title">s</span><span class="hljs-params">(pfs[r] ^ pfs[l])</span></span>;<br>      mns[l][r] = INF;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(l + <span class="hljs-number">1</span>); i != r; ++i)<br>        mns[l][r] = <span class="hljs-built_in">min</span>(mns[l][r], mns[l][i] + mns[i][r] +<br>            ((i - l) % <span class="hljs-number">2</span> + (r - i) % <span class="hljs-number">2</span> == <span class="hljs-number">2</span> ? (<span class="hljs-number">2</span> * s) : <span class="hljs-number">0LL</span>));<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; mns[<span class="hljs-number">0</span>][N] + (N &amp; <span class="hljs-number">1</span> ? pfs[N] : <span class="hljs-number">0LL</span>) &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 省选联考 2025 图排列</title>
    <link href="/sol-LGP11832/"/>
    <url>/sol-LGP11832/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>喜欢这个题，推理链长而完整，考察代码实现但不严重，没什么很一拍脑袋的步骤，场上差最后一步而只有 52 分是一款我的问题。</p><h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>给一简单无向图，求字典序最小的排列 $p$，满足将每条边 $(u<em>i,v_i)$ 视作区间 $[\min(p</em>{u<em>i},p</em>{v<em>i}), \max(p</em>{u<em>i},p</em>{v_i}))$ 后，区间要么相离，要么一者包含另一者。点数 $n\le 10^5$，边数 $m\le 2n$，保证有解。</p><h2 id="性质-AC：图为一棵树"><a href="#性质-AC：图为一棵树" class="headerlink" title="性质 AC：图为一棵树"></a>性质 AC：图为一棵树</h2><p>手玩，每个点一定是形如：有些子树在它左边、有些子树在它右边，子树之间两两不交，而这个结构可以向子树递归。那只关心每个子树答案的首位，在该点处排序即可。考虑到随便选根，根可能被某条边代表的区间包含，所以以编号最小的点作为根，它必然在答案的首位。</p><h2 id="性质-C：多个联通块的合并"><a href="#性质-C：多个联通块的合并" class="headerlink" title="性质 C：多个联通块的合并"></a>性质 C：多个联通块的合并</h2><p>手玩，不同联通块之间要么相互包含，要么相离。根据字典序最小的贪心想法，考虑对每个联通块求出答案，按首位排序，依次输出。如果发现下一个联通块的首位要小于即将要输出的数，就跳到下一个联通块。</p><h2 id="环的情况"><a href="#环的情况" class="headerlink" title="环的情况"></a>环的情况</h2><p>手玩，发现环上的点出现的顺序必然是：环的某个顺序的某个循环表示。建立圆方树，圆点遵循上面的规则，方点就是把儿子按环上的顺序依次排序，选取正序和逆序中更优者。</p><h2 id="点双的性质"><a href="#点双的性质" class="headerlink" title="点双的性质"></a>点双的性质</h2><ol><li>此点双不含同胚于 $K_4$ 的子图。$K_4$ 表示大小为 $4$ 的完全图。也就是说此点双是广义串并联图。手玩可证。</li><li>此点双不含同胚于以下结构的子图（$K_{2,3}$）：</li></ol><p><img src="https://s2.loli.net/2025/03/04/Lier5C6bPfwdla7.png" alt="sol-LGP11832-1.png"></p><p>考虑三个环 <code>1 2 5 3</code>、<code>1 2 5 4</code>、<code>1 3 5 4</code> 都要符合上述对于环的分析，手玩发现不可能。这里同时证明了点双哈密顿环的存在性。</p><p>总结一下：这个点双形如一个圆，上面有一些不相交的弦。这里哈密顿环的唯一性也显然（删去任意一条环边原图将不再是点双，非环边则反之，暴力方法可以获得 72 分）。把哈密顿环找到，按环的方法做即可。</p><h2 id="广义串并联图方法"><a href="#广义串并联图方法" class="headerlink" title="广义串并联图方法"></a>广义串并联图方法</h2><p>由广义串并联图的套路，以及这是针对点双，考虑在点双上面不断地缩二度点和叠合重边来找到哈密顿环。</p><p>简单地说，你发现缩二度点的过程拉成重构树，环上的点就已经排好序。所以一开始认为所有的边都有效，叠合重边的时候把长度为 1 的边删去即可。</p><p>总复杂度 $O(n\log n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">100005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXV = MXN * <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> T, N, M, V;<br><span class="hljs-type">int</span> dfn[MXN], low[MXN], did;<br><span class="hljs-type">int</span> cid, stk[MXN], top;<br><span class="hljs-type">int</span> que[MXN], qh, qt;<br><span class="hljs-type">bool</span> instk[MXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; to[MXN], comps[MXN], nto[MXV];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; segs[MXV];<br>set&lt;<span class="hljs-type">int</span>&gt; rese[MXN], vire[MXN];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(getchar())</span></span>;<br>  <span class="hljs-keyword">while</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">while</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = x * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>), c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(x);<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">11</span>];<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">while</span> (x) buf[d++] = x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>, x /= <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">while</span> (d) <span class="hljs-built_in">putchar</span>(buf[--d]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build_scc</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q, <span class="hljs-type">int</span> s)</span> </span>&#123;<br>  nto[p].<span class="hljs-built_in">push_back</span>(s);<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">otop</span><span class="hljs-params">(top)</span></span>;<br>  stk[++otop] = p;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(stk[top--])</span></span>;<br>    instk[c] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : to[c]) &#123;<br>      <span class="hljs-keyword">if</span> (instk[i] &amp;&amp; dfn[i] &gt;= dfn[p]) &#123;<br>        rese[c].<span class="hljs-built_in">insert</span>(i), rese[i].<span class="hljs-built_in">insert</span>(c);<br>        vire[c].<span class="hljs-built_in">insert</span>(i), vire[i].<span class="hljs-built_in">insert</span>(c);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == q) <span class="hljs-keyword">break</span>;<br>  &#125;<br>  qh = qt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(top + <span class="hljs-number">1</span>); i &lt;= otop; ++i) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(stk[i])</span></span>;<br>    <span class="hljs-keyword">if</span> (rese[c].<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) que[qt++] = c;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (qh != qt) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(que[qh++])</span></span>;<br>    <span class="hljs-keyword">if</span> (rese[c].<span class="hljs-built_in">size</span>() != <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(*rese[c].begin())</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">y</span><span class="hljs-params">(*next(rese[c].begin()))</span></span>;<br>    rese[x].<span class="hljs-built_in">erase</span>(c), rese[y].<span class="hljs-built_in">erase</span>(c);<br>    <span class="hljs-keyword">if</span> (rese[x].<span class="hljs-built_in">find</span>(y) != rese[x].<span class="hljs-built_in">end</span>()) &#123;<br>      vire[x].<span class="hljs-built_in">erase</span>(y), vire[y].<span class="hljs-built_in">erase</span>(x);<br>      <span class="hljs-keyword">if</span> (rese[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) que[qt++] = x;<br>      <span class="hljs-keyword">if</span> (rese[y].<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) que[qt++] = y;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      rese[x].<span class="hljs-built_in">insert</span>(y), rese[y].<span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(que[qh - <span class="hljs-number">1</span>])</span>, <span class="hljs-title">y</span><span class="hljs-params">(que[qh])</span></span>;<br>  <span class="hljs-keyword">if</span> (vire[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) vire[x].<span class="hljs-built_in">insert</span>(y), vire[y].<span class="hljs-built_in">insert</span>(x);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">c</span>(*vire[p].<span class="hljs-built_in">begin</span>()), <span class="hljs-built_in">l</span>(p);;) &#123;<br>    nto[s].<span class="hljs-built_in">push_back</span>(c);<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(*vire[c].begin() + *next(vire[c].begin()) - l)</span></span>;<br>    <span class="hljs-keyword">if</span> (n == p) <span class="hljs-keyword">break</span>;<br>    l = c, c = n;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(top + <span class="hljs-number">1</span>); i &lt;= otop; ++i) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(stk[i])</span></span>;<br>    rese[c].<span class="hljs-built_in">clear</span>(), vire[c].<span class="hljs-built_in">clear</span>();<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> f)</span> </span>&#123;<br>  low[p] = dfn[p] = did++;<br>  instk[p] = <span class="hljs-literal">true</span>, stk[++top] = p;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q : to[p]) &#123;<br>    <span class="hljs-keyword">if</span> (q == f) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (dfn[q] == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-built_in">build</span>(q, p);<br>      low[p] = <span class="hljs-built_in">min</span>(low[p], low[q]);<br>      <span class="hljs-keyword">if</span> (low[q] == dfn[q]) &#123;<br>        nto[p].<span class="hljs-built_in">push_back</span>(q);<br>        instk[q] = <span class="hljs-literal">false</span>;<br>        --top;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (low[q] == dfn[p]) &#123;<br>        <span class="hljs-built_in">build_scc</span>(p, q, V++);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low[p] = <span class="hljs-built_in">min</span>(low[p], dfn[q]);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>  segs[p].<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">if</span> (p &lt; N) segs[p].<span class="hljs-built_in">emplace_back</span>(p, p);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q : nto[p]) &#123;<br>    <span class="hljs-built_in">calc</span>(q);<br>    segs[p].<span class="hljs-built_in">emplace_back</span>(segs[q][<span class="hljs-number">0</span>].first, q);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p &lt; N)<br>    <span class="hljs-built_in">sort</span>(segs[p].<span class="hljs-built_in">begin</span>(), segs[p].<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (segs[p].<span class="hljs-built_in">back</span>().first &lt; segs[p][<span class="hljs-number">0</span>].first)<br>    <span class="hljs-built_in">reverse</span>(segs[p].<span class="hljs-built_in">begin</span>(), segs[p].<span class="hljs-built_in">end</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> ci)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [fir, q] : segs[p]) &#123;<br>    <span class="hljs-keyword">if</span> (q == p) comps[ci].<span class="hljs-built_in">push_back</span>(p);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">generate</span>(q, ci);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> layer)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : comps[layer]) &#123;<br>    <span class="hljs-keyword">while</span> (top != cid &amp;&amp; comps[top][<span class="hljs-number">0</span>] &lt; i) <span class="hljs-built_in">output</span>(top++);<br>    <span class="hljs-built_in">write</span>(i + <span class="hljs-number">1</span>), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">read</span>(), T = <span class="hljs-built_in">read</span>(); T--;) &#123;<br>    N = <span class="hljs-built_in">read</span>(), M = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) to[i].<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); M--;) &#123;<br>      x = <span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>, y = <span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>;<br>      to[x].<span class="hljs-built_in">push_back</span>(y), to[y].<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    did = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">fill</span>(dfn, dfn + N, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N + N; ++i) &#123;<br>      segs[i].<span class="hljs-built_in">clear</span>();<br>      nto[i].<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    V = N;<br>    cid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (~dfn[i]) <span class="hljs-keyword">continue</span>;<br>      top = <span class="hljs-number">-1</span>, <span class="hljs-built_in">build</span>(i, <span class="hljs-number">-1</span>);<br>      <span class="hljs-built_in">calc</span>(i);<br>      comps[cid].<span class="hljs-built_in">clear</span>(), <span class="hljs-built_in">generate</span>(i, cid++);<br>    &#125;<br>    top = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (top != cid) <span class="hljs-built_in">output</span>(top++);<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    cout &lt;&lt; flush;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>图论</tag>
      
      <tag>广义串并联图</tag>
      
      <tag>外平面图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - GDOI 2025</title>
    <link href="/rec-2025gdoi/"/>
    <url>/rec-2025gdoi/</url>
    
    <content type="html"><![CDATA[<p>2024-2025 赛季，此一役。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p><em>2025.2.28.</em></p><p>试机，学习了 <code>ulimit</code>，原来 vim 每次 <code>:!</code> 都是开一个受外部限制的临时终端，而 <code>ulimit -s</code> 一开始的 <code>8192</code> 是假的，后面第一次修改以后就不能再开大。以及 <code>$VIMRUNTIME/.vimrc</code>，获得 <code>set undofile</code>。</p><p>似乎应该写点板子，然后就开了 QOJ 板子赛，写了点字符串板子，即使我知道现在已经不喜欢考字符串了，似乎已经是数数+数据结构的世界了。</p><p>十分紧张，23:30 上床睡觉。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p><em>2025.3.1.</em></p><p>0:30 起床？？？？？天崩。2:30 左右才再次入睡，6:30 起来后感觉整个人很奇怪。</p><p>酒店早餐太多人，去吃了麦，感觉面包很奇怪。</p><p>酒店门口有很多小卡片。</p><h3 id="Keep-Dreaming"><a href="#Keep-Dreaming" class="headerlink" title="Keep Dreaming"></a>Keep Dreaming</h3><p>你好，为什么我的虚拟机一闪一闪？</p><p>9:30 才过 T1，我觉得可以甩锅的，不过没啥意义，我已经习惯了比赛只打一半时间。</p><p>直觉告诉我 T3 比 T2 可做。玩一玩，会了 AC，想想没 A 怎么做，会了。</p><p>T2，发现自己会 0 种处理 DAG 的手法。其实是想过这个问题是不是不弱于 DAG 可达性问题来着，可是当时不敢咬死最优复杂度不会好于 $O(\frac{nm}{w})$，太生疏了。最后直接拼了 $O(qm)$。</p><p>想想圆方树，方点要对儿子有一个序，相当于是我有一个圆，上面有一些不交弦，然后要找出这个圆。怎么找？朴素的找哈密顿环肯定假的，应该还有点性质。这个图是一个广义串并联图，然后捏？</p><p>存在 72 pts 做法，但感觉好难写啊。</p><h3 id="Awake"><a href="#Awake" class="headerlink" title="Awake"></a>Awake</h3><p>果然大家都是 252。</p><p>bitset 学艺不精，虽说现在来想似乎一下子也想不到。</p><p>精力少了很多，摆摆摆。写了个树 Hash。即使知道还没考的就是数数了，唉。</p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p><em>2025.3.2.</em></p><h3 id="Remain-Loving"><a href="#Remain-Loving" class="headerlink" title="Remain Loving"></a>Remain Loving</h3><p>你好，你们联合省选为什么一天考两个题？怎么我前两年都没遇到过这天大好事。</p><p>你好，你们联合省选为什么考过了重塑时光还要再考一遍？</p><p>我好，为什么我没有切主旋律？场上又推不明白？</p><p>T3 好神秘啊，感觉到一种树形结构。但是答案上界是 $O(2^n nm)$，那是不是常数较小可以拿 32 pts。严格一点应该是对着差分序列搜，首位元素是在一个区间里，但是好难写啊。序列哈希。样例过了，丢。</p><p>回到 T2，贝尔数：能写？推推推，怎么手算不明白……</p><p>T1 拍拍拍，然后开始发呆（可是明明阅读了 Qingyu 的 <a href="https://qoj.ac/blog/qingyu/blog/786">Emergency Kit</a>，为什么还不能做到充分尊重自己的省选机会？），大概估算一下大众分吧，是不是大家都会 T2 了，假设并非人人都是去年 E 金切 D1T3，那就是 $100+100+52+100+100+32=484$……而我是 $100+20+52+100+24+32=328$……好吧……</p><p>？？突然就考试结束了，匆忙地关闭窗口，希望这里没有误操作吧，写游记的当下回想起来还是惶恐，大概也是有点疲劳了。file checker 没出问题应该是没出问题。</p><h3 id="Faded"><a href="#Faded" class="headerlink" title="Faded"></a>Faded</h3><p>黄队说 T3 可以把答案卡的很大，那就坠机了。$304$，还要预留第二天爆零的可能。</p><p>果然还是不够，不够，不够。</p><h2 id="After-Story"><a href="#After-Story" class="headerlink" title="After Story"></a>After Story</h2><p>Arcaea 飞升 12.70。过了几天就到了 12.85，然后板子就坏了。</p><p>看了看周围的说法，那自己踮踮脚伸伸手能够够到的应该是 $100+100+100+100+64+32$，如果真的做得到就好了。</p><p>T3 的思维链已经快到了，可是还差那一步啊。差那一步创造，差那一步坚定，差那一步勤恳。</p><p>本赛季每场比赛都只能打出自己的最低最稳发挥（唯一有意思的是 D1T3 吧），思维链尚可，但见过的太少了，D1T2、D1T3、D2T2 都是如果再见多一点就能再会一点。</p><p>数数和数据结构的世界，再往里走一走吧。继续。我不会停下的。</p><hr><p>为什么同机房有 4 个（包括我）同级的标准分差不超过 1？？？？？为什么要这样折磨我们？？？？？算一下自己大概在 D3 左右，那应该是没辙。</p><h2 id="True-Failure"><a href="#True-Failure" class="headerlink" title="True Failure"></a>True Failure</h2><p>$100+20+52+40+24+8$。很好。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AGC064D Red and Blue Chips</title>
    <link href="/sol-AGC064D/"/>
    <url>/sol-AGC064D/</url>
    
    <content type="html"><![CDATA[<p>写这篇单纯是因为我读到的这题题解没有一篇讲的是俺听得懂的话（捂脸）。感觉是独立很难做的题目。</p><h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>有 $n$ 个只含 <code>RB</code> 的字符串 $S_i$，一开始每个字符串长度均为 $1$，保证 $S_n$ 是 <code>B</code>。对 $i$ 从 $1$ 到 $n-1$ 依次做如下操作：选择一个 $j$ 满足 $i&lt;j\le n$ 且 $S_j$ 末字符为 <code>B</code>，然后将 $S_i$ 拼接到 $S_j$ 前面。问可以生成的 $S_n$ 个数 $\bmod\ 998244353$。$2\le n\le 300$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>令输入的串为 $S$，生成的串为 $T$，经典的想法是为 $T$ 设计一个判定算法。</p><p>显然 $T<em>n$ 是 <code>B</code>。从 $S_1$ 到 $S</em>{n-1}$ 考虑会感觉每一位都没有一个位置，不如从 $S_{n-1}$ 到 $S_1$，依次考虑填入 $T$。</p><p>发现 $S_n$ 之前的一串极长的 <code>R</code> 必然成为 $T$ 的一个前缀，因为它们是最后放到 $S_n$ 开头的。然后将会扫到一个 <code>B</code>，假设它是 $S_b$，它会填到上述 <code>R</code> 前缀的后面、$T_n$ 的前面的某个位置。接下来扫到的一串极长的 <code>R</code>，在原来的过程中只有两种选择：放到 $S_b$ 前面或放到 $S_n$ 前面。如果选择的是放到 $S_n$ 前面，那么应该恰好在移动后的 $S_b$ 后面，因为它恰好在 $S_b$ 缀到 $S_n$ 前缀过去，$T$ 形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">RRRRR....BRRRR.............B<br></code></pre></td></tr></table></figure><p>如果选择的是放到 $S_b$ 的最前面，那应该是紧跟在上一次 <code>R</code> 的后面，而要在其它缀到 $S_b$ 前面的串之前，$T$ 形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">RRR RRRR........B..........B<br></code></pre></td></tr></table></figure><p>再下一个 <code>B</code>（以下为区分标为 <code>b</code>），可以填到两个空段的某一处，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">RRRRR....b...BRRRRR....b...B<br></code></pre></td></tr></table></figure><p>再然后的 <code>R</code>，类比上述推演可知，必然在以下之一：</p><ul><li><code>b</code> 前面空段的最前；</li><li>紧随 <code>b</code> 之后；</li><li>剩下那个空段的最前，表示和 <code>b</code> 的去向不同。</li></ul><p>归纳一下，相当于是 <code>B</code> 会插到某个位置，然后 <code>R</code> 可以插到最前，也可以紧随任意除了 $S_n$ 以外的 <code>B</code> 之后。就像是，每插入一个 <code>B</code>，就会把 $T$ 中它后面的一段连续的 <code>R</code> 给启用，表示可以往里面填 <code>R</code>。如果不能填 <code>R</code> 就是方案不合法。</p><p>这样的判定还不是 DFA，不够确定。考虑填 <code>B</code>，肯定希望接下来能容纳 <code>R</code> 的能力尽量强，所以除了第一段 <code>R</code> 被动地启用，后面都肯定会挑 $T$ 中一段最长的 <code>R</code> 来启用。</p><p>那就可以进一步形式化：假设 $S$ 中 <code>B</code> 有 $m$ 个，从右往左第 $i+1$ 个 <code>B</code> 右边的 <code>R</code> 有 $s_i$ 个，并令 $s_m=n-m$；假设把 $T$ 中除了第一段 <code>R</code> 以外的 <code>R</code> 段从长到短排序，令其长度前缀和为 $t_i$。则判定条件为：$\forall 1\le i\le m,t_i\ge s_i$。</p><p>把所有合法的 $t_1$ 都启用，后面的从长到短往里面填，最后要乘上多重集排列，转移有一个阶乘逆的系数，这是显然的分组背包，不讲了。复杂度看起来是 $O(n^3\log n)$，但是不太知道官方题解怎么能分析到 $O(n^3)$，可能是写法不太一样。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>你都会了，还要代码干嘛，套路卷积而已。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这个题的性质太深奥了。上述理解有点暴力，但还是可以做出题的。其他题解有提到树形结构，也许可以帮助你获得更好的直觉，只是我还没悟到/ll。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - NOIP 2024</title>
    <link href="/rec-2024noip/"/>
    <url>/rec-2024noip/</url>
    
    <content type="html"><![CDATA[<p>以为不写 CSP 游记就可以让 2024-2025 赛季开一个好头，真的是荒谬至极，但是我再也忍受不了了。</p><p>T1，30 分钟左右过了。T2，20 分钟左右过了。T4 没有秒，发现链版本没有落脚点，那就完了，感觉 DS 写 32 分可以了。只要 T3 过了，332 就是一个非常理想的分数了，对于我来说。对吧，我想着。</p><p>数数嘛，每个点周围的边会形成一条链嘛，那是不是直接看有几边存在起点就行了。诶，不行，恶心的点只是在于同一种树会被算多次。我到底在数什么？</p><p>我到底在数什么？</p><p>这时离结束还有 90 min，想应该只和每个点的首边和末边有关吧。但好像画出来，整个图会比较支离破碎。没关系，我们尝试 DP 一下。</p><p>我们尝试 DP 一下。</p><p>时间结束了。</p><hr><p>第二天想清楚这就是一个以叶子为根的链剖分，要换根在叶子处统计，代码一遍通过了（如果不包括忘记输出 <code>endl</code> 的话）。</p><p>272。这就是我训练了 3 个月的结果，这就是 4.5h 中 3h 啥都没干可以获得的分数。</p><p>3 个月的模拟赛，极少的挂分，较高的名次（最厉害的人都去打其他比赛了），我误以为自己还是有两把刷子的。或者从十连测后面两场打 10 分和 0 分的时候，最迟是 NOIP 前最后一场模拟赛的 T1 挂成 20 分，就应该醒过来了。挂分越来越少，甚至于在 2024-2025 赛季迄今做到 0 挂分，但是实力真的提升了吗？以前不会的 ad-hoc，以前不会的容斥，以前不会的 DP，以前不会的 DS，现在会了吗？以前稳不住的心态，现在稳住了吗？以前动不了的脑子，现在动起来了吗？以前落后的名次，现在提起来了吗？好像还不如以前，上限看起来还高一些，现在完全是依靠别人都在挂分挂成我的朴素分数。</p><p>那我还应该干什么？我应该不干什么？我应该更多地做专题题单？随机做 CF？应该开点科技？应该补题？应该放松？应该紧张？应该关注他人与名次？应该放下他人与名次？</p><p>无法得知应该向哪里看齐，无法得知应该如何改进，无法得知需要突破什么，无法得知等待到什么时候，无法得知什么是正确的选择，甚至无法得知是进步与否，连这个方法究竟是否适合我都无从知晓。好像我离开了哪里，哪里就会有所进步。而除了科技的学习，从来无法观测到我自己在的时候进步的出现。那我应该去哪里？</p><p>我再也忍受不了了。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces 2039 F1/F2 Shohag Loves Counting</title>
    <link href="/sol-CF2039F/"/>
    <url>/sol-CF2039F/</url>
    
    <content type="html"><![CDATA[<p>我不会的题，那就是好题。</p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>假设有一个数组 $a$，$f(k)$ 表示 $a$ 所有长度为 $k$ 的子区间的最大值的 $\gcd$，$a$ 是好的当且仅当在定义域内 $f(k)$ 两两不同。求有多少个值域为 $[1,m]$ 的整数的任意长度的 $a$ 是好的。对 F1 Easy Version，$\sum m\le 10^5$；对 F2 Hard Version，$m\le 10^6$。</p><h2 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h2><p>$f(k)$ 两两不同，首先要定长区间最大值集合两两不同。从 $k=2$ 考虑，就是要求 $\nexists i\ \text{s.t.}\ a<em>i\ge a</em>{i-1},a<em>i\ge a</em>{i+1}$。然后发现对后续的过程还要求 $a_i$ 两两不同。</p><p>手动模拟后总结一下：好的序列必须是一个严格单谷序列，并且从小到大排序后，所有后缀 $\gcd$ 两两不同。</p><h2 id="Easy-Version"><a href="#Easy-Version" class="headerlink" title="Easy Version"></a>Easy Version</h2><p>既然是后缀，$\sum m$ 也很小，考虑从大到小插入数。令 $f<em>i$ 维护当前后缀 $\gcd$ 为 $i$ 的序列个数，然后每次长度加一的时候因为最小值有两个位置可以插入（当前最小值的左右），所以 $\times$ 贡献过去。每次插入一个数 $i$，考虑 $f_j$ 向 $f</em>{\gcd(i,j)}$ 贡献。直接做是 $O(m^2\log m)$。</p><p>看到 $\gcd$ 一个想法是莫反。推一推式子，假设当前考虑对 $f_j$ 的增量，且暂且不考虑贡献时 $\gcd(i,j)&lt;j$ 的限制：</p><script type="math/tex; mode=display">\begin{aligned}&\sum_k f_k[\gcd(k,i)=j] \\=& \sum_k f_{jk}[\gcd(k,\frac{i}{j})=1] \\=& \sum_k f_{jk}\sum_{d\mid \gcd(k,\frac{i}{j})} \mu(d) \\=& \sum_{dj\mid i} \mu(d)\sum_k f_{djk} \\ \end{aligned}</script><p>实时维护一下 $g<em>i=\sum_j f</em>{ij}$，遍历每个 $i$ 的因子 $j$，套一层遍历每个 $\frac{i}{j}$ 的因子 $d$，把 $\mu (d)g_{dj}$ 加入贡献中。最后把限制减掉 $f_j$ 对自身的贡献，这部分的贡献 $\times 2$。然后新建一个点的贡献就是给 $f_i$ 做一次 $+1$。细节上，这些都是同时做的，所以把所有的贡献暂存然后再一起加回去。</p><p>单次时间 $O(\sum<em>{1\le i\le n}\sum</em>{d\mid i}\sigma(d))$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">100005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DVS = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> T, N, cnt[MXN], sum[MXN], ans, delta[MXN], mu[MXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; fac[MXN];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  cnt[i] = (cnt[i] + v) % DVS;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : fac[i]) sum[j] = (sum[j] + v) % DVS;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != MXN; ++i) &#123;<br>    fac[i].<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(i + i); j &lt; MXN; j += i) fac[j].<span class="hljs-built_in">push_back</span>(i), mu[j] -= mu[i];<br>    mu[i] = (DVS + mu[i]) % DVS;<br>  &#125;<br>  cin &gt;&gt; T;<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    cin &gt;&gt; N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) cnt[i] = <span class="hljs-number">0</span>, sum[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(N); i; --i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : fac[i]) &#123;<br>        delta[j] = (DVS - cnt[j]) % DVS;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : fac[i / j])<br>          delta[j] = (delta[j] + mu[k] * <span class="hljs-number">1LL</span> * sum[j * k]) % DVS;<br>        delta[j] = delta[j] * <span class="hljs-number">2</span> % DVS;<br>      &#125;<br>      delta[i] = (delta[i] + <span class="hljs-number">1</span>) % DVS;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : fac[i]) <span class="hljs-built_in">add</span>(j, delta[j]), delta[j] = <span class="hljs-number">0</span>;<br>    &#125;<br>    ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) ans = (ans + cnt[i]) % DVS;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Hard-Version"><a href="#Hard-Version" class="headerlink" title="Hard Version"></a>Hard Version</h2><p>发现强制要求从小往大插，离线存一下答案。</p><p>那好吧，令 $f_{i,j}$ 表示当前位的后缀 $\gcd$ 填 $i$，当前位本身是 $ij$。再次考虑莫反算贡献，枚举当前 $i$ 的每个因子 $j$：</p><script type="math/tex; mode=display">\begin{aligned} &\sum_{k,l} f_{k,l}[\gcd(kl,j)=k] \\=& \sum_{k,l} f_{k,l}[\gcd(l,\frac{j}{k})=1] \\=& \sum_{kd\mid j} \mu(d) \sum_{l} f_{k,dl}\end{aligned}</script><p>你以为这里要两维都记然后达成 $O(n\log n)$ 的空间复杂度？不用！只要存 $g<em>i=\sum</em>{d\mid i} \mu(d) \sum<em>{l} f</em>{\frac{i}{d},dl}$，每次查询 $g_{kd}$ 即可。复杂度不变。</p><p>这么做还是不考虑贡献时 $\gcd(i,j)&lt;j$ 的限制，所以仍然要除去 $s<em>i=\sum_k f</em>{i,k}$ 对自身的贡献。那么空间上只存 $g,s$ 两个。空间是 $O(n)$ 的。</p><p>每次加入一个数 $i$，对所有 $j\mid i$ 的 $f<em>{j,\frac{i}{j}}$ 做更新，而且每个都要 $+1$。而答案的差分即为 $f</em>{i,1}$，前缀和一下即可。</p><p>时间有点紧（虽然我没卡常），可以通过存因数的时候先做 <code>vector::reserve()</code> 加速。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">1000005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DVS = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> T, N, cnt[MXN], sum[MXN], ans[MXN], delta[MXN], mu[MXN];<br>vector&lt;<span class="hljs-type">int</span>&gt; fac[MXN];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  cnt[i] = (cnt[i] + v) % DVS;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != MXN; ++i) fac[i].<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != MXN; ++i) &#123;<br>    fac[i].<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(i + i); j &lt; MXN; j += i) fac[j].<span class="hljs-built_in">push_back</span>(i), mu[j] -= mu[i];<br>    mu[i] = (DVS + mu[i]) % DVS;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != MXN; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : fac[i]) &#123;<br>      delta[j] = (DVS - cnt[j]) % DVS;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : fac[j]) delta[j] = (delta[j] + sum[k]) % DVS;<br>      delta[j] = (delta[j] + delta[j] + <span class="hljs-number">1</span>) % DVS;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : fac[i]) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : fac[i / j])<br>        sum[j * k] = (sum[j * k] + mu[k] * <span class="hljs-number">1LL</span> * delta[j]) % DVS;<br>      cnt[j] = (cnt[j] + delta[j]) % DVS;<br>    &#125;<br>    ans[i] = (ans[i - <span class="hljs-number">1</span>] + cnt[i]) % DVS;<br>  &#125;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>  <span class="hljs-keyword">while</span> (T--) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans[N]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
      <tag>莫比乌斯反演</tag>
      
      <tag>平衡规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 2024 十一月做题记录</title>
    <link href="/sol-2024nov/"/>
    <url>/sol-2024nov/</url>
    
    <content type="html"><![CDATA[<h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>Vjudge 没做，但是感觉挺难的。</p><h3 id="Luogu-P5607-Ynoi2013-无力回天-NOI2017"><a href="#Luogu-P5607-Ynoi2013-无力回天-NOI2017" class="headerlink" title="Luogu P5607 [Ynoi2013] 无力回天 NOI2017"></a>Luogu P5607 [Ynoi2013] 无力回天 NOI2017</h3><p>察觉到奇偶性的关键，尝试把偶数个数的线性基建出来，发现刚好是差分数组的线性基。奇数个数的情况就是随便多插一个数进去算。</p><h3 id="Codeforces-1320D-Reachable-Strings"><a href="#Codeforces-1320D-Reachable-Strings" class="headerlink" title="*Codeforces 1320D Reachable Strings"></a>*Codeforces 1320D Reachable Strings</h3><p>没写，但应该等价。</p><p>直接考虑最小表示，类似于把 <code>11</code> 拖到最前面，后面的 <code>1</code> 都是形单影只，而且这种情况下 <code>0</code> 连续段长度（广义）不变。所以把所有 <code>11</code> 删掉，直接比哈希值就可以了。另一种理解方法：相邻 <code>0</code> 的距离的奇偶性不变，维护这个东西的哈希值，注意头加一个 <code>0</code> 尾加一个 <code>0</code>。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><h3 id="A-串串游戏（string）"><a href="#A-串串游戏（string）" class="headerlink" title="A 串串游戏（string）"></a>A 串串游戏（string）</h3><p>遇到字典序，直接逐位考虑。逐位枚举，记一个子序列自动机即可。</p><h3 id="B-最长上升子序列（lis）"><a href="#B-最长上升子序列（lis）" class="headerlink" title="B 最长上升子序列（lis）"></a>B 最长上升子序列（lis）</h3><p>逐个间隔考虑，上面的每层都是 $2$ 的次幂，最后一层要拉出来讨论，可能以最后一层或倒数第二层为本位。</p><h3 id="C-墙（wall）"><a href="#C-墙（wall）" class="headerlink" title="C 墙（wall）"></a>C 墙（wall）</h3><p>逐位考虑贡献，发现类似于左边点乘右边，不好做，所以考虑从另一维入手，即值域。（等于转大于应该是显然的。）把式子推清楚就很好写了。</p><p>11.29 补题完毕。</p><h3 id="D-有理数（number）"><a href="#D-有理数（number）" class="headerlink" title="D 有理数（number）"></a>D 有理数（number）</h3><p>手动通分肯定是要的。逐个质因子讨论对乘积的贡献，发现如果两个数对这个质因子的最大次数不等，只能取小的，对最大次数相等的情况会有额外贡献，枚举额外贡献（注意范围）开 <code>map</code> 即可。时间：能过。</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>ZR 十连，跟没打一样，无法集中精力。不想说话。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><h3 id="AGC002E-Candy-Piles"><a href="#AGC002E-Candy-Piles" class="headerlink" title="AGC002E Candy Piles"></a>AGC002E Candy Piles</h3><p>观察，发现每个 1 都会从边界往内延伸一条斜线，即可。</p><h3 id="Codeforces-1930H-Interactive-Mex-Tree"><a href="#Codeforces-1930H-Interactive-Mex-Tree" class="headerlink" title="Codeforces 1930H Interactive Mex Tree"></a>Codeforces 1930H Interactive Mex Tree</h3><p>神了，dfs 序有两个：入栈序和出栈序。【如何高级地理解出栈序呢。】</p><h3 id="Codeforces-1819D-Misha-and-Apples"><a href="#Codeforces-1819D-Misha-and-Apples" class="headerlink" title="Codeforces 1819D Misha and Apples"></a>Codeforces 1819D Misha and Apples</h3><p>枚举最后一次删空，后面的不能再删空是容易判的，当前点能被删空判定法是枚举上一次删空，讨论中间的前驱情况，然后这个点是有单调性的。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><h3 id="A-序列-sequence"><a href="#A-序列-sequence" class="headerlink" title="A 序列 (sequence)"></a>A 序列 (sequence)</h3><p>尺取，实际表现中正常 gcd 快于 $O(1)$ gcd，菜。</p><h3 id="D-牛仔-nz"><a href="#D-牛仔-nz" class="headerlink" title="D 牛仔 (nz)"></a>D 牛仔 (nz)</h3><p>考虑算贡献，也就是钦定一个区间，算有多少个序列。</p><p>如果模式串是牛仔序列，则整个串都是。</p><p>如果模式串并非两两不同，则左右是独立的，从中间往两边分别 DP（更简洁！），做点乘即可。</p><p>否则左右不独立，考虑从左往右 DP，每次都加上贡献，贡献除以一个系数，并且如同其它 DP 一样更新。</p><h3 id="C-长者-young"><a href="#C-长者-young" class="headerlink" title="C 长者 (young)"></a>C 长者 (young)</h3><p>我不会枚举，我不会搜索。</p><p>XOR-MST 的框架都是类似的。讨论左右两个联通块的连边，转为计算连边大于等于某个数的方案数，直接搜索即可。</p><h3 id="B-道路（road）"><a href="#B-道路（road）" class="headerlink" title="B 道路（road）"></a>B 道路（road）</h3><p>二分。每个点都会连一个后缀，只要这个图可以成为一个欧拉回路（除了后缀连边可以任意重边）即可（有点像是，哈密顿回路转欧拉回路）。</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>越来越理解不了，各种理解不了。</p><h3 id="A-纵使日薄西山"><a href="#A-纵使日薄西山" class="headerlink" title="A 纵使日薄西山"></a>A 纵使日薄西山</h3><p>两个两个枚举，FWT。既然是降难度，然后值域比较小，就是扑空的次数很少，暴力即可。</p><h3 id="B-即便看不到未来"><a href="#B-即便看不到未来" class="headerlink" title="B 即便看不到未来"></a>B 即便看不到未来</h3><p>这怎么会得了的？</p><p>考虑减量。考虑三维最小的位置，然后贪心删掉一个最小代价的。</p><h3 id="C-此时此刻的光辉"><a href="#C-此时此刻的光辉" class="headerlink" title="C 此时此刻的光辉"></a>C 此时此刻的光辉</h3><p>随便写一个状压搜索，逐位加，用平衡说明复杂度正确。</p><h3 id="D-盼君勿忘"><a href="#D-盼君勿忘" class="headerlink" title="*D 盼君勿忘"></a>*D 盼君勿忘</h3><p>观察不难，剩下就是硬推组合和式，然后树上启发式算增量。不太想做。</p><h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><h3 id="A-飞翔（fly）"><a href="#A-飞翔（fly）" class="headerlink" title="A 飞翔（fly）"></a>A 飞翔（fly）</h3><p>可以直接算边权。</p><h3 id="B-子序列们（sub）"><a href="#B-子序列们（sub）" class="headerlink" title="B 子序列们（sub）"></a>B 子序列们（sub）</h3><p>区间 DP，以最终存活为分界点。</p><h3 id="C-钙绿（probability）"><a href="#C-钙绿（probability）" class="headerlink" title="C 钙绿（probability）"></a>C 钙绿（probability）</h3><p>记得超乎其外，做好预处理。</p><h3 id="D-动态树（tree）"><a href="#D-动态树（tree）" class="headerlink" title="*D 动态树（tree）"></a>*D 动态树（tree）</h3><p>根号重构。可以做长剖或转二维上 KD-Tree。</p><h3 id="Luogu-P9846-ICPC2021-Nanjing-R-Paimon’s-Tree"><a href="#Luogu-P9846-ICPC2021-Nanjing-R-Paimon’s-Tree" class="headerlink" title="Luogu P9846 [ICPC2021 Nanjing R] Paimon’s Tree"></a>Luogu P9846 [ICPC2021 Nanjing R] Paimon’s Tree</h3><h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><h3 id="QOJ-9132-Painting-Fences"><a href="#QOJ-9132-Painting-Fences" class="headerlink" title="QOJ 9132 Painting Fences"></a>QOJ 9132 Painting Fences</h3><p>发现只关心一个黑矩形扩展为全局。这边界讨论真够阴间的。</p><h3 id="QOJ-9167-Coprime-Array"><a href="#QOJ-9167-Coprime-Array" class="headerlink" title="QOJ 9167 Coprime Array"></a>QOJ 9167 Coprime Array</h3><p>质因数分解后讨论。答案很小。</p><h3 id="Codeforces-1479C-Continuous-City"><a href="#Codeforces-1479C-Continuous-City" class="headerlink" title="Codeforces 1479C Continuous City"></a>Codeforces 1479C Continuous City</h3><p>二进制拆分。</p><h3 id="Codeforces-1994H-Fortnite"><a href="#Codeforces-1994H-Fortnite" class="headerlink" title="Codeforces 1994H Fortnite"></a>Codeforces 1994H Fortnite</h3><p>解除怨念，但不知道怎么造这个题。</p><p>对于题目询问的进一步刻画：每次询问一个 $p$ 进制数 $\bmod m$ 的结果，这个 $p$ 进制数满足最高位及以下每位取值都在 $[1,26]$。</p><p>首先我们会得到 $p$，询问 <code>aa</code> 即可得到 $p+1$，恰好 $p+1&lt;m$。</p><p>假设我们问了 $A\bmod m=a$（$A$ 表示字符串，同时表示 $p$ 进制数），可以得到 $m|(A-a)$——但这并没有意义，因为我们只剩一次了。</p><p>这一次可以获得另一组 $B\bmod m = b$。如果这个 $B$ 满足一些性质，那么 $m$ 可以非常快求出来，我们要非常非常快。</p><p>关键想法：我们不考虑除法，考虑减法，比如 $(A-a)-(B-b)=m$，意思就是两个相邻的 $m$ 的倍数差为 $m$。</p><p>所需要的条件是 $A-a-m\le B<A-a$，由于 $m>a$，即 $m\ge a+1$，则 $A-a-m\le A-2a-1$。那么只要 $[A-2a-1, A-a-1]$ 有至少一个可以询问的 $B$ 就可以了，无论取最小的还是最大的都可以。令 $A$ 为 <code>zzzzzzzz</code> 即可。</p><h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><h3 id="A-ti"><a href="#A-ti" class="headerlink" title="A ti"></a>A ti</h3><p>从循环位移的角度刻画。</p><h3 id="B-tii"><a href="#B-tii" class="headerlink" title="B tii"></a>B tii</h3><p>分数考虑转斜率……</p><h3 id="C-tiii"><a href="#C-tiii" class="headerlink" title="C tiii"></a>C tiii</h3><p>找到一种单调性，发现是速度，有序 DP。</p><h3 id="D-tiv"><a href="#D-tiv" class="headerlink" title="*D tiv"></a>*D tiv</h3><p>把图形拆开成 LCA 处的邻域和其余每个点的 $d$ 层儿子，第一部分点分治，第二部分 dsu on tree，扫描线。</p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>现在打十连都不太认真。但是这一把的确是很难。</p><h3 id="A-种花"><a href="#A-种花" class="headerlink" title="A 种花"></a>A 种花</h3><p>单调栈。</p><p>其他的目前都不会。</p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><h3 id="ARC106E-Medals"><a href="#ARC106E-Medals" class="headerlink" title="ARC106E Medals"></a>ARC106E Medals</h3><p>二分答案，用 Hall 定理，做高维前缀和。</p><h3 id="Codeforces-1342F-Make-It-Ascending"><a href="#Codeforces-1342F-Make-It-Ascending" class="headerlink" title="*Codeforces 1342F Make It Ascending"></a>*Codeforces 1342F Make It Ascending</h3><p>状压，把状态的一维和答案交换，因为具有单调性。之所以没过是因为，我没有较小的常数因子。【数据删除】。【数据删除】。【数据删除】。</p><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><h3 id="A-定向越野（walk）"><a href="#A-定向越野（walk）" class="headerlink" title="A 定向越野（walk）"></a>A 定向越野（walk）</h3><p>猜一个结论，发现是对的……</p><h3 id="B-字符串（str）"><a href="#B-字符串（str）" class="headerlink" title="B 字符串（str）"></a>B 字符串（str）</h3><p>扫描线容易想到，KMP 过程中维护左端点集合：这个东西可以扩展，蛮有细节的。办法就是先加入自身，跳 <code>next</code> 删单点，右移一位就把 <code>next</code> 右移一位的删除同态加入。以后不乱写 KMP 了呜呜呜，border 就直接用 KMP 的写法多简洁。</p><h3 id="C-数数（count）"><a href="#C-数数（count）" class="headerlink" title="C 数数（count）"></a>C 数数（count）</h3><p>摩尔投票的人数是可以扩展的。</p><h3 id="D-逃脱（esc）-USACO18JAN-Cow-at-Large-P"><a href="#D-逃脱（esc）-USACO18JAN-Cow-at-Large-P" class="headerlink" title="D 逃脱（esc）/ USACO18JAN Cow at Large P"></a>D 逃脱（esc）/ USACO18JAN Cow at Large P</h3><p>思路感觉其实不难。刻画一下条件然后直接点分治就好了。留意这里是【距离最近的叶子】，不在乎任何子树关系。</p><h3 id="ARC125F-Tree-Degree-Subset-Sum"><a href="#ARC125F-Tree-Degree-Subset-Sum" class="headerlink" title="ARC125F Tree Degree Subset Sum"></a>ARC125F Tree Degree Subset Sum</h3><p><del>首先我们发现它是一个二元卷积，那完蛋了。</del></p><p>我们发现 $y-x$ 固定时，$x$ 是一个区间。？？？然后就做完了，这个背包改一下多重背包然后直接跑就行了。</p><h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><h3 id="A-数的拆分-number-Luogu-P8778-蓝桥杯-2022-省-A-数的拆分"><a href="#A-数的拆分-number-Luogu-P8778-蓝桥杯-2022-省-A-数的拆分" class="headerlink" title="A 数的拆分 (number) / Luogu P8778 [蓝桥杯 2022 省 A] 数的拆分"></a>A 数的拆分 (number) / Luogu P8778 [蓝桥杯 2022 省 A] 数的拆分</h3><p>Powerful Number 性质，发现筛到 $V^{\frac{1}{5}}$ 为止，质因数仅四个，性质仍然优良。</p><h3 id="B-括号序列-bracket-LibreOJ-6043-「雅礼集训-2017-Day7」蛐蛐国的修墙方案"><a href="#B-括号序列-bracket-LibreOJ-6043-「雅礼集训-2017-Day7」蛐蛐国的修墙方案" class="headerlink" title="B 括号序列 (bracket) / LibreOJ 6043 「雅礼集训 2017 Day7」蛐蛐国的修墙方案"></a>B 括号序列 (bracket) / LibreOJ 6043 「雅礼集训 2017 Day7」蛐蛐国的修墙方案</h3><p>我们发现把二元环贪心掉，剩下爆搜，跑得够快。</p><h3 id="C-数据结构-struct-UOJ-637-【美团杯2021】A-数据结构"><a href="#C-数据结构-struct-UOJ-637-【美团杯2021】A-数据结构" class="headerlink" title="C 数据结构 (struct) / UOJ 637 【美团杯2021】A. 数据结构"></a>C 数据结构 (struct) / UOJ 637 【美团杯2021】A. 数据结构</h3><p>扫描线。难点在于想到算贡献，然后快速刻画条件：比如说 $x$ 不出现，就是把所有的 $x$ 包含了，并且不包含任何一个 $x-1$。后面一个条件直接拿相邻的同色数讨论就可以了。</p><h3 id="D-构造数组-array-Luogu-P8863-「KDOI-03」构造数组"><a href="#D-构造数组-array-Luogu-P8863-「KDOI-03」构造数组" class="headerlink" title="D 构造数组 (array) / Luogu P8863 「KDOI-03」构造数组"></a>D 构造数组 (array) / Luogu P8863 「KDOI-03」构造数组</h3><p><del>首先我们发现它是一个 $n$ 元卷积，那完蛋了。</del></p><p>对每种数讨论。假设当前的状态是操作序列有若干个 $0$/$1$/$2$（假设我知道现在总共有多少个数，那只要知道一个就全知道了），然后<strong>我们认为它们已经填进去了</strong>！然后要填某个数直接枚举一下组合数一下就可以了。注意组合数细节。</p><h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><h3 id="Luogu-P6377-PA2010-Termites-P3210-HNOI2010-取石头游戏"><a href="#Luogu-P6377-PA2010-Termites-P3210-HNOI2010-取石头游戏" class="headerlink" title="Luogu P6377 [PA2010] Termites / P3210 [HNOI2010] 取石头游戏"></a>Luogu P6377 [PA2010] Termites / P3210 [HNOI2010] 取石头游戏</h3><p>什么时候才会做博弈论题？什么时候才会动脑筋？</p><p>我们没有任何入手点，除了数组本身。然后我们发现，如果它有良好的单调性，我们会做。所以考虑不单调的部分。比如说，单峰：我们发现峰左右两个点一定是同一个人取的，所以可以缩，所有都会变成单谷。但是对于只有单边能选的连续段，在里面还会有一串递增，这一串递增长度为偶的时候大家都不想取，只有最后只剩它们了才会取（奇的时候把外面的端点删掉就一样了）。代码实现上，用栈做，维护两人的差值。</p><h3 id="Luogu-P9346-无可奈何花落去"><a href="#Luogu-P9346-无可奈何花落去" class="headerlink" title="Luogu P9346 无可奈何花落去"></a>Luogu P9346 无可奈何花落去</h3><p>第一次不好算，但是凋零的状态好办，所以让每个凋零的时刻都有 $1$ 的贡献，背包一下。</p><h3 id="Luogu-P8820-CSP-S-2022-数据传输"><a href="#Luogu-P8820-CSP-S-2022-数据传输" class="headerlink" title="Luogu P8820 [CSP-S 2022] 数据传输"></a>Luogu P8820 [CSP-S 2022] 数据传输</h3><p>既然是静态，考虑倍增，算 $(\min, +)$ 矩阵乘积。注意 $k=3$ 可以经过路径外的点。在 LCA 处要讨论一下。</p><h3 id="QOJ-9562-欧伊昔"><a href="#QOJ-9562-欧伊昔" class="headerlink" title="QOJ 9562 欧伊昔"></a>QOJ 9562 欧伊昔</h3><p>考虑推广 FWT，直接可以做到 $O(9^n)$。取众数用容斥，其它的同行同列两格可以合并，就可 $O(6^n)$。拉丁方就挑一行循环一下。但是大家的常数较小，我不说话了。</p><h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><h3 id="A-数字（number）"><a href="#A-数字（number）" class="headerlink" title="A 数字（number）"></a>A 数字（number）</h3><p>数位 DP 板子。注意 $n=0$！！！挂 T1 这辈子有了。</p><h3 id="B-加训（train）"><a href="#B-加训（train）" class="headerlink" title="B 加训（train）"></a>B 加训（train）</h3><p>手动讨论一下，发现只关心左边的 <code>R</code> 和右边的 <code>L</code>，个数可以算，前缀和一下即可。</p><h3 id="C-排序（sort）"><a href="#C-排序（sort）" class="headerlink" title="C 排序（sort）"></a>C 排序（sort）</h3><p>显然是按前缀最大值归并。每次会把一个块劈开，平均每个根要 $O(1)$ 获取。细节上注意以前切过一刀的地方以后也跳不过去。</p><h3 id="D-改造（modification）"><a href="#D-改造（modification）" class="headerlink" title="D 改造（modification）"></a>D 改造（modification）</h3><p>Reverse LIS 改，考虑以终为始，什么样的序列给什么样的 $k$ 贡献，关心的是取出来的子序列的连续段数。注意钦定最左段和最右段是否被选，若不被选则下一段必被选，否则不优。什么时候才能场切反悔贪心……</p><h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p>So hard。</p><h3 id="A-书架（book）-Codeforces-802C-Heidi-and-Library-hard"><a href="#A-书架（book）-Codeforces-802C-Heidi-and-Library-hard" class="headerlink" title="*A 书架（book）/ Codeforces 802C Heidi and Library (hard)"></a>*A 书架（book）/ Codeforces 802C Heidi and Library (hard)</h3><p>认为书是一股流，并没有被丢掉，只是被放在旁边。</p><h3 id="B-序列（seq）"><a href="#B-序列（seq）" class="headerlink" title="*B 序列（seq）"></a>*B 序列（seq）</h3><p>没听懂。好像可以序列分治。</p><h3 id="C-异或（xor）"><a href="#C-异或（xor）" class="headerlink" title="*C 异或（xor）"></a>*C 异或（xor）</h3><p>对线性空间计数，就是对最简线性基计数。DP 还没想明白。</p><h3 id="D-颜色（color）-AtCoder-nikkei2019-qual-f-Jewels"><a href="#D-颜色（color）-AtCoder-nikkei2019-qual-f-Jewels" class="headerlink" title="*D 颜色（color）/ AtCoder nikkei2019_qual_f Jewels"></a>*D 颜色（color）/ AtCoder nikkei2019_qual_f Jewels</h3><p>神秘反悔贪心。</p><p>晚上打了 ABC，但是很简单，可惜的是吃了两发罚时，失败。</p><h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><p>ARC 187，D 晚开是策略大失败。</p><h3 id="A-Add-and-Swap"><a href="#A-Add-and-Swap" class="headerlink" title="A Add and Swap"></a>A Add and Swap</h3><p>在 B 后切出，真是笨完了。</p><p>考虑对一个点连续做两次操作，相当于给它和它后面一位同时 $+k$，所以只做这种事情可以把除了最后一位以外的做到不降。</p><p>假设对最后一位往前移偶数位，直到前面单调不降，后面全体加一些 $k$ 即可。如果到了第二位，还不是单调不降，做一次。还是不行，那就是无解。反正我不会。</p><h3 id="B-Sum-of-CC"><a href="#B-Sum-of-CC" class="headerlink" title="B Sum of CC"></a>B Sum of CC</h3><p>这个简单一点。考察两个点不联通的情况。假设从左到右可以用几个极小正方形覆盖所有点，那么这些正方形互不联通。所以直接考虑每个断点左右会不会分隔开即可。</p><h3 id="C-1-Loop-Bubble-Sort"><a href="#C-1-Loop-Bubble-Sort" class="headerlink" title="*C 1 Loop Bubble Sort"></a>*C 1 Loop Bubble Sort</h3><p>好像是刻画成前缀最大值数量相关，然后不会了。</p><h3 id="D-Many-Easy-Optimizations"><a href="#D-Many-Easy-Optimizations" class="headerlink" title="D Many Easy Optimizations"></a>D Many Easy Optimizations</h3><p>这个赛时会了，但是写不动。</p><p>对每个右端点维护最大的左端点，每次加入一个数是区间取 $\min$，维护连续段即可，事实上只要在起点维护即可。11.20 补题完毕。</p><h3 id="E-Replace-Triplets"><a href="#E-Replace-Triplets" class="headerlink" title="*E Replace Triplets"></a>*E Replace Triplets</h3><p>没研究，不会。</p><h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><h3 id="AGC009D-Uninity"><a href="#AGC009D-Uninity" class="headerlink" title="AGC009D Uninity"></a>AGC009D Uninity</h3><p>神了。首先发现要求最大深度最小的点分树，但先不要直接把点分治糊上去……</p><p>把点分树上深度记在每个点上，对这个东西的约束是：任意两个相等的点路径上必然有至少一个数比它们大。然后乖乖地随便找个根做树上 DP 即可。</p><h3 id="ARC139D-Priority-Queue-2"><a href="#ARC139D-Priority-Queue-2" class="headerlink" title="ARC139D Priority Queue 2"></a>ARC139D Priority Queue 2</h3><p>这我哪会啊？？考虑对于排名相关，就画横线，大于小于分为 <code>01</code> 再做。这题一样，这样刻画就行了。</p><h3 id="Luogu-P8173-CEOI2021-Newspapers"><a href="#Luogu-P8173-CEOI2021-Newspapers" class="headerlink" title="Luogu P8173 [CEOI2021] Newspapers"></a>Luogu P8173 [CEOI2021] Newspapers</h3><p>服了。阴间分讨，阴间构造性思维。</p><p>首先有环不行，感觉是对的嘛。然后我们构造一个链的答案，这个我也不太会，反正就是 $2\sim n-1$ 再 $n-1\sim 2$。</p><p>接下来很神。考虑以链为本位，往外面挂点，发现挂的点深度超过 $2$ 就会无解，反正我构造不出来。</p><p>然后把直径取出来做一做就好了。</p><h2 id="19"><a href="#19" class="headerlink" title="19"></a>19</h2><h3 id="A-战队分配（team）"><a href="#A-战队分配（team）" class="headerlink" title="A 战队分配（team）"></a>A 战队分配（team）</h3><p>正负拆贡献，感觉挺灵机一动的。</p><h3 id="B-货车运输（cargo）"><a href="#B-货车运输（cargo）" class="headerlink" title="B 货车运输（cargo）"></a>B 货车运输（cargo）</h3><p>容易想到钦定一个有序。另一个，我们关注前面还有几位没填和目前总和，即得 DP。</p><h3 id="C-甜果（sugar）"><a href="#C-甜果（sugar）" class="headerlink" title="C 甜果（sugar）"></a>C 甜果（sugar）</h3><p>转概率。看起来是内向基环树，但把确定的点拎出来发现只是剖成几棵树。对于一个深度的答案是确定的，注意不能瞎猜，打个表就好了。</p><h3 id="D-打平就能出线！（qualify）"><a href="#D-打平就能出线！（qualify）" class="headerlink" title="*D 打平就能出线！（qualify）"></a>*D 打平就能出线！（qualify）</h3><p>什么？二分、分类讨论，想必是 T1 难度吧！什么？怎么赛时最高分 10 分？</p><h3 id="Luogu-P6105-Ynoi2010-y-fast-trie"><a href="#Luogu-P6105-Ynoi2010-y-fast-trie" class="headerlink" title="Luogu P6105 [Ynoi2010] y-fast trie"></a>Luogu P6105 [Ynoi2010] y-fast trie</h3><p>原来的想法可以，就是把 $&lt;C$ 和 $\ge C$ 的分开来讨论，然后对一个点 $x$ 同时在 $C-1-x$ 的位置记录，然后就是一个可以合并的东西。卡空间，所以平衡树。卡常，所以不可以无旋 Treap，Splay 直接过了。</p><h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><p>喜欢 ty round，每次都有濒死的感受。</p><h3 id="A-迷宫（maze）"><a href="#A-迷宫（maze）" class="headerlink" title="A 迷宫（maze）"></a>A 迷宫（maze）</h3><p>大家好，我们卡常。</p><p>有 $O(nmk)$ 做法，但不想恶心自己。</p><h3 id="B-玩具-toy"><a href="#B-玩具-toy" class="headerlink" title="B 玩具(toy)"></a>B 玩具(toy)</h3><p>比 T1 简单。从左往右，每种移动都是贪心做最远。</p><h3 id="C-权重-weight"><a href="#C-权重-weight" class="headerlink" title="C 权重(weight)"></a>C 权重(weight)</h3><p>点分治/dsu on tree，用 01-Trie 统计。清空不用递归，直接赋总和与根为空！</p><h3 id="D-周长-perimeter-ARC063F-すぬけ君の塗り絵-2"><a href="#D-周长-perimeter-ARC063F-すぬけ君の塗り絵-2" class="headerlink" title="D 周长(perimeter) / ARC063F すぬけ君の塗り絵 2"></a>D 周长(perimeter) / ARC063F すぬけ君の塗り絵 2</h3><p>分治是好想的，单调栈，同时搞搞区间加全局查最值。但是我们发现除去显然的下界，答案必然过横竖两条中线之一……妈呀……</p><p>现在是任何数据结构都可以干掉我了。我完了。</p><h3 id="Luogu-P8866-NOIP2022-喵了个喵"><a href="#Luogu-P8866-NOIP2022-喵了个喵" class="headerlink" title="Luogu P8866 [NOIP2022] 喵了个喵"></a>Luogu P8866 [NOIP2022] 喵了个喵</h3><p>昨晚做到今天。</p><p>$k=2n-2$ 早就会了。对于多出来的一个，你可以考虑一些灵活一点的方法，连带后面的内容一起考虑进来。假设我们放到空栈，接下来一定要有新的空栈，就是一个在栈底的，它的上面被消了。如果下一个在栈底的不能被顶消，就干脆把当前放到它上面，然后底消。（自己做的时候多讨论了次数是否为 $0$ 的 case，但是不用，因为偶数次都会自己抵消，借鉴了 HF zzh 老师才知道。）代码细节很多，我写了一个结构维护所有栈的信息，然后用 <code>extract()</code> 和 <code>append()</code> 来临时取走/加入某个栈，用 <code>push()</code> 和 <code>eliminate()</code> 做顶消和底消。但是这个东西不能和 <code>bel[]</code> 同时维护，所以很细。</p><h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><p>拜谢原创题领域大神 yukimianyan。</p><h3 id="A-Soso-的期望并查集（exsodsu）"><a href="#A-Soso-的期望并查集（exsodsu）" class="headerlink" title="A Soso 的期望并查集（exsodsu）"></a>A Soso 的期望并查集（exsodsu）</h3><p>（带权）并查集模拟，使用期望的线性性。</p><h3 id="B-Soso-的模法矩阵（modmat）"><a href="#B-Soso-的模法矩阵（modmat）" class="headerlink" title="B Soso 的模法矩阵（modmat）"></a>B Soso 的模法矩阵（modmat）</h3><p>变进制数模板题。或者根据模数的倍数关系想到。</p><h3 id="C-Soso-的排列（soperme）"><a href="#C-Soso-的排列（soperme）" class="headerlink" title="C Soso 的排列（soperme）"></a>C Soso 的排列（soperme）</h3><p>排列是变进制数，所以考虑数位 DP，逐位跳，从低到高位再从高到低位。</p><h3 id="D-走路（walk）-QOJ-8557-Goldberg-Machine"><a href="#D-走路（walk）-QOJ-8557-Goldberg-Machine" class="headerlink" title="D 走路（walk）/ QOJ 8557 Goldberg Machine"></a>D 走路（walk）/ QOJ 8557 Goldberg Machine</h3><p>不带修：P7831。知道了欧拉环游序的结论，对每个点都有一个时间戳，单次修改是区间时间戳 $\pm 1$，然后查询可以二分，分块做到 $O(n\sqrt{n\log n})$，注意到块内值域较小。</p><p>被 VJudge 猜结论虐杀了。</p><h3 id="QOJ-9453-Graph-Generator"><a href="#QOJ-9453-Graph-Generator" class="headerlink" title="QOJ 9453 Graph Generator"></a>QOJ 9453 Graph Generator</h3><p>倒着想，正着做。</p><h3 id="QOJ-7866-Gym-104891J-Teleportation"><a href="#QOJ-7866-Gym-104891J-Teleportation" class="headerlink" title="QOJ 7866 / Gym 104891J Teleportation"></a>QOJ 7866 / Gym 104891J Teleportation</h3><p>关键是想到交换一二操作顺序，注意到第一步必走的细节。</p><h3 id="QOJ-9135-Teleports"><a href="#QOJ-9135-Teleports" class="headerlink" title="QOJ 9135 Teleports"></a>QOJ 9135 Teleports</h3><p>区间 DP，同层做最短路。</p><h2 id="22"><a href="#22" class="headerlink" title="22"></a>22</h2><h3 id="Codeforces-1458D-Flip-and-Reverse"><a href="#Codeforces-1458D-Flip-and-Reverse" class="headerlink" title="Codeforces 1458D Flip and Reverse"></a>Codeforces 1458D Flip and Reverse</h3><p>这能独立做出来是没想到的。把每个数换成 $-1$ 的次幂，发现这个操作刚好是这样折线图的 reverse。一次 reverse 中边的种类不变，只在乎后面还是否存在，要逐位贪心，认为找一条欧拉路径即可。</p><p>这里以上是独立解答。</p><h3 id="QOJ-7861-Gym-104891E-Inverse-Topological-Sort"><a href="#QOJ-7861-Gym-104891E-Inverse-Topological-Sort" class="headerlink" title="QOJ 7861 / Gym 104891E Inverse Topological Sort"></a>QOJ 7861 / Gym 104891E Inverse Topological Sort</h3><p>发现关键是最后一个卡脖子的数，认为这样子拼起来的图可以就是可以，不行就是无解。注意 check 同时检查最大最小序列是否相同……</p><h3 id="QOJ-9246-Dominating-Point"><a href="#QOJ-9246-Dominating-Point" class="headerlink" title="QOJ 9246 Dominating Point"></a>QOJ 9246 Dominating Point</h3><p>这个手玩没想到，就是假设 $p$ 两步内到不了 $q$，则 $\forall x, p\to x\implies q\to x$，这是一个非常好的性质，然后就可以按出度排序做。</p><h3 id="QOJ-8517-Interesting-Paths"><a href="#QOJ-8517-Interesting-Paths" class="headerlink" title="QOJ 8517 Interesting Paths"></a>QOJ 8517 Interesting Paths</h3><p>这个好题。考虑把贡献只记在一条边上，就会有一些边不给算，发现你从 $1$ 开始搞一棵不到达 $n$ 的生成树即可，所以答案只和 $n,m$ 有关，注意把 $1$ 不可达或不可达 $n$ 的删掉。</p><h3 id="QOJ-9141-Array-Spread"><a href="#QOJ-9141-Array-Spread" class="headerlink" title="QOJ 9141 Array Spread"></a>QOJ 9141 Array Spread</h3><p>这个是神题。处理分数除了设数、斜率以外的方法：钦定最小值为 $1$，最大值不超过此值。二分，可以有理数逼近，也可以发现分母分子不超过连续段个数，然后直接在 Farey 序列上二分。</p><h3 id="Codeforces-1290D-Coffee-Varieties-hard-version"><a href="#Codeforces-1290D-Coffee-Varieties-hard-version" class="headerlink" title="Codeforces 1290D Coffee Varieties (hard version)"></a>Codeforces 1290D Coffee Varieties (hard version)</h3><p>我们发现 $k$ 为块长是不可以的，所以选取 $\frac{k}{2}$……</p><p>剩下的就是考虑每次处理一对很浪费，考虑做最小链覆盖，一个好的写法是做成欧拉回路。</p><h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><h3 id="NOIP-模拟"><a href="#NOIP-模拟" class="headerlink" title="NOIP 模拟"></a>NOIP 模拟</h3><h4 id="A-旅游高手（expert）-Luogu-P9373-「DROI」Round-2-构造与取模"><a href="#A-旅游高手（expert）-Luogu-P9373-「DROI」Round-2-构造与取模" class="headerlink" title="A 旅游高手（expert）/ Luogu P9373 「DROI」Round 2 构造与取模"></a>A 旅游高手（expert）/ Luogu P9373 「DROI」Round 2 构造与取模</h4><p>小数模大数值不变。</p><h4 id="B-桜树街道（sakura）"><a href="#B-桜树街道（sakura）" class="headerlink" title="B 桜树街道（sakura）"></a>B 桜树街道（sakura）</h4><p>树上笛卡尔树。</p><h4 id="C-朱雀湖（lake）-QOJ-8211-Enumerating-Substrings"><a href="#C-朱雀湖（lake）-QOJ-8211-Enumerating-Substrings" class="headerlink" title="C 朱雀湖（lake）/ QOJ 8211 Enumerating Substrings"></a>C 朱雀湖（lake）/ QOJ 8211 Enumerating Substrings</h4><p>一点也不简单的计数。</p><p>发现模式串 border 至多有 1 个，所以可以容斥。系数是：</p><script type="math/tex; mode=display">f_i=\begin{cases}0, &i\le 0;\\i-\sum_{i-k< j< i}f_j, &i> 0;\end{cases}</script><p>得到 $f_i=\lceil \frac{i}{k} \rceil$。</p><p>注意模式串的总数不是随便填，所以算无 border 的时候容斥要留意。</p><h4 id="D-小情侣（lovers）-Luogu-P5211-ZJOI2017-字符串"><a href="#D-小情侣（lovers）-Luogu-P5211-ZJOI2017-字符串" class="headerlink" title="*D 小情侣（lovers）/ Luogu P5211 [ZJOI2017] 字符串"></a>*D 小情侣（lovers）/ Luogu P5211 [ZJOI2017] 字符串</h4><p>Significant Suffix 板子题。关键结论：$\forall A,B\in \textrm{SS}, |A|&lt;|B|\implies A\in \textrm{border}(B)\land 2|A|&lt;|B|$。哈希用 $O(\sqrt N)-O(1)$。</p><h3 id="Codeforces-2039-CodeTON-Round-9-Div-1-Div-2-Rated-Prizes"><a href="#Codeforces-2039-CodeTON-Round-9-Div-1-Div-2-Rated-Prizes" class="headerlink" title="Codeforces 2039 CodeTON Round 9 (Div. 1 + Div. 2, Rated, Prizes!)"></a>Codeforces 2039 CodeTON Round 9 (Div. 1 + Div. 2, Rated, Prizes!)</h3><h4 id="A-Shohag-Loves-Mod"><a href="#A-Shohag-Loves-Mod" class="headerlink" title="A Shohag Loves Mod"></a>A Shohag Loves Mod</h4><p>输出值域是长度的两倍，考虑 $2i-1$。</p><h4 id="B-Shohag-Loves-Strings"><a href="#B-Shohag-Loves-Strings" class="headerlink" title="B Shohag Loves Strings"></a>B Shohag Loves Strings</h4><p>发现我们更关心字符是否重复。越短的字符串似乎更容易找，手玩一下，发现 <code>aa</code> 和 <code>abc</code> 两种就可以覆盖所有可能的情况了。</p><h4 id="C1-Shohag-Loves-XOR-Easy-Version"><a href="#C1-Shohag-Loves-XOR-Easy-Version" class="headerlink" title="C1 Shohag Loves XOR (Easy Version)"></a>C1 Shohag Loves XOR (Easy Version)</h4><p>要求 $x\oplus y\le \lfloor\frac{\min(x,y)}{2}\rfloor$，所以枚举一下 $y\le\min (m,2x)$。</p><h4 id="C2-Shohag-Loves-XOR-Hard-Version"><a href="#C2-Shohag-Loves-XOR-Hard-Version" class="headerlink" title="C2 Shohag Loves XOR (Hard Version)"></a>C2 Shohag Loves XOR (Hard Version)</h4><p>喜欢恶心人。</p><p>枚举 $x\oplus y$，逐个 check。根据 $x-y\le x\oplus y\le x+y$ 发现 $x\oplus y$ 较小的时候总是满足，不一定满足的在一个区间，枚举。注意判定的条件！！！！！不能两种都算上了，手动讨论一下。</p><h4 id="D-Shohag-Loves-GCD"><a href="#D-Shohag-Loves-GCD" class="headerlink" title="D Shohag Loves GCD"></a>D Shohag Loves GCD</h4><p>从倍数关系必须满足入手，最容易不为 $\gcd$ 的办法就是比它们都大，毕竟还要字典序最大，发现这时已构造完了。</p><h4 id="E-Shohag-Loves-Inversions"><a href="#E-Shohag-Loves-Inversions" class="headerlink" title="E Shohag Loves Inversions"></a>E Shohag Loves Inversions</h4><p>从第一次出现逆序对数 $\ge 2$ 开始，<strong>如果不插在末尾</strong>，逆序对数就会单调递增。而这之前都是 01 串，手动模拟一下。枚举第一次逆序对数 $\ge 2$ 情景的时间。出现注意末尾多次插入的情况！</p><h4 id="F1-Shohag-Loves-Counting-Easy-Version-F2-Shohag-Loves-Counting-Hard-Version"><a href="#F1-Shohag-Loves-Counting-Easy-Version-F2-Shohag-Loves-Counting-Hard-Version" class="headerlink" title="F1 Shohag Loves Counting (Easy Version) / F2 Shohag Loves Counting (Hard Version)"></a>F1 Shohag Loves Counting (Easy Version) / F2 Shohag Loves Counting (Hard Version)</h4><p>莫反好题啊！另写题解。11.25 完成补题。</p><h4 id="G-Shohag-Loves-Pebae"><a href="#G-Shohag-Loves-Pebae" class="headerlink" title="*G Shohag Loves Pebae"></a>*G Shohag Loves Pebae</h4><p>没看，不会。</p><h4 id="H1-Cool-Swap-Walk-Easy-Version-H2-Cool-Swap-Walk-Hard-Version"><a href="#H1-Cool-Swap-Walk-Easy-Version-H2-Cool-Swap-Walk-Hard-Version" class="headerlink" title="*H1 Cool Swap Walk (Easy Version) / H2 Cool Swap Walk (Hard Version)"></a>*H1 Cool Swap Walk (Easy Version) / H2 Cool Swap Walk (Hard Version)</h4><p>感觉不好写，但是看起来很炫酷。</p><p>赛时只注意到是边界有交的一些 <code>reverse</code>，然后感觉很麻烦。但是完全可以把 <code>reverse</code> 更严格，是因为我们发现每次都会把第一个移到最后，而剩余的是边界无交的，所以可以干脆做成是否邻项交换。然后我们使用奇偶排序，这我哪会啊。就是第一次交换 12、34……，第二次交换 23、45……，再下一次又是 12、34……，太深奥了。这样可以 H1。</p><p>H2 就要求折半，因为上面这个东西是提前钦定 $a_1$ 最小，每次还要复位，所以很低效。所以考虑干脆就着这样做，让这个排列就一直做轮换。认为小于半数的是 A 类，大于等于的是 B 类，在前一半只排 A 类，后一半只排 B 类。还有很多细节，暂且投降。</p><h2 id="25"><a href="#25" class="headerlink" title="25"></a>25</h2><h3 id="Luogu-P5610-Ynoi2013-大学-P3987-我永远喜欢珂朵莉"><a href="#Luogu-P5610-Ynoi2013-大学-P3987-我永远喜欢珂朵莉" class="headerlink" title="Luogu P5610 [Ynoi2013] 大学 / P3987 我永远喜欢珂朵莉~"></a>Luogu P5610 [Ynoi2013] 大学 / P3987 我永远喜欢珂朵莉~</h3><p>暴力除的次数很少，注意是<strong>不考虑除以 $1$ 的情况</strong>！！！（写之前先留意一下自己的结论对不对。于是可以干脆不记录这个因数。）考虑对每个 $x$ 维护它的所有倍数然后二分查找。发现很难做删掉因子，所以<strong>惰性删除</strong>！！！</p><p>一个关键卡常：链式前向星寻址过于底效，摊平的时候不可以逐条链访问！对每位记录一个 <code>bel[]</code>。</p><p>还有一个：并查集的 <code>find()</code> 虽然是递归，但是写 <code>inline</code> 会快很多。</p><h2 id="26"><a href="#26" class="headerlink" title="26"></a>26</h2><h3 id="A-珠子（bead）"><a href="#A-珠子（bead）" class="headerlink" title="A 珠子（bead）"></a>A 珠子（bead）</h3><p>欧拉反演。</p><h3 id="B-机器人（robot）"><a href="#B-机器人（robot）" class="headerlink" title="B 机器人（robot）"></a>B 机器人（robot）</h3><p>换成两个函数的差，然后分奇偶，离散化，差分前缀和。</p><h3 id="C-树（tree）"><a href="#C-树（tree）" class="headerlink" title="C 树（tree）"></a>C 树（tree）</h3><p>赛时做不出来，太幽默了。</p><p>部分分提示拆项，DP 状态是闲置黑点数和闲置白点数。有三类，每个点先把儿子都跑完再做。</p><h3 id="D-钻石岛（island）"><a href="#D-钻石岛（island）" class="headerlink" title="*D 钻石岛（island）"></a>*D 钻石岛（island）</h3><p>大致思路：考虑底面只有 6 种状态，画一下发现类似于走一个欧拉回路/路径，一条边来回走可以刻画一下，最后拆两维解同余不定方程，整一整，嗯。</p><h2 id="27"><a href="#27" class="headerlink" title="27"></a>27</h2><p>会做 0 道计数题，那我完蛋了。</p><h3 id="QOJ-5367-递增树列"><a href="#QOJ-5367-递增树列" class="headerlink" title="*QOJ 5367 递增树列"></a>*QOJ 5367 递增树列</h3><p>观察不难，树上二维卷积还有抽象组合数，我该怎么办？？？</p><h3 id="QOJ-9650-链覆盖"><a href="#QOJ-9650-链覆盖" class="headerlink" title="*QOJ 9650 链覆盖"></a>*QOJ 9650 链覆盖</h3><p>EGF。我该怎么办？？？</p><h3 id="QOJ-9561-树数叔术"><a href="#QOJ-9561-树数叔术" class="headerlink" title="*QOJ 9561 树数叔术"></a>*QOJ 9561 树数叔术</h3><p>观察不到，我该怎么办？？？</p><p>记录一下这个观察：0 肯定只有一个。1 手模一下发现也不得不只有一个。这时候手模多一个！发现 2 可以在 0 到 1 路径上任意放，在其他地方最多放一个。所以结论是这样的：每个数至少有一个，在比他小的虚树上可以随便放，在外面最多放一个。</p><p>然后咋写啊？？？</p><h2 id="28"><a href="#28" class="headerlink" title="28"></a>28</h2><h3 id="A-冒泡（pop）"><a href="#A-冒泡（pop）" class="headerlink" title="A 冒泡（pop）"></a>A 冒泡（pop）</h3><p>手玩得到结论。喜报：<code>n &gt;&gt; 1 | 1</code> 不等于 <code>(n &gt;&gt; 1) + 1</code>。</p><h3 id="B-山路-road"><a href="#B-山路-road" class="headerlink" title="B 山路 (road)"></a>B 山路 (road)</h3><p>找最短路和不同色的次短路。也可以理解为最段路树上对于跨越两棵根的子树的横叉边计算贡献。</p><h3 id="C-机器-machine"><a href="#C-机器-machine" class="headerlink" title="C 机器 (machine)"></a>C 机器 (machine)</h3><p>感觉是好题。赛时所有必要的观察都做了，但是没想到 DP，真是无语。</p><p>以 <code>B</code> 为本位考虑，希望尽量多地做 <code>RRB</code>，如果不巧不得不做 <code>RBB</code> 就会 $+1$ 花费，如果要做奇偶切换就不得不做一次 <code>RB</code>。也就是可以刻画一个方案的花费了。另一个很有用、也可以给出 DP 提示的「有序性」条件是：以终点奇偶性分组，每组内部的起点有序。这个显然。然后我们可以 DP！！！$f_{i,j}$ 表示偶数/奇数分别匹配了多少个，最小花费。构造方案有点麻烦，有两种较为简易的解决办法，但注意麻烦之处都是碰到了起点终点相同的状况。第一种办法让终点代替起点先走，然后起点再代替终点，这是等效的；另一种办法是如果有奇偶转换把它最先做，这样根据有序性以后都不会遇到这种情况。</p><h3 id="Luogu-P9527-JOISC2022-洒水器"><a href="#Luogu-P9527-JOISC2022-洒水器" class="headerlink" title="Luogu P9527 [JOISC2022] 洒水器"></a>Luogu P9527 [JOISC2022] 洒水器</h3><p>拆邻域技巧。</p><h3 id="D-旅行-tour"><a href="#D-旅行-tour" class="headerlink" title="D 旅行 (tour)"></a>D 旅行 (tour)</h3><p>用这个办法，树剖线段树是显然的，每个点上的 tag 种类数非常少，就可以在线了。</p><h2 id="29"><a href="#29" class="headerlink" title="29"></a>29</h2><h3 id="Luogu-P3750-六省联考-2017-分手是祝愿"><a href="#Luogu-P3750-六省联考-2017-分手是祝愿" class="headerlink" title="Luogu P3750 [六省联考 2017] 分手是祝愿"></a>Luogu P3750 [六省联考 2017] 分手是祝愿</h3><p>首先发现一下结果和过程是双射，复原，然后推式子，用差分处理。</p><h3 id="Luogu-P9968-THUPC-2024-初赛-二进制"><a href="#Luogu-P9968-THUPC-2024-初赛-二进制" class="headerlink" title="Luogu P9968 [THUPC 2024 初赛] 二进制"></a>Luogu P9968 [THUPC 2024 初赛] 二进制</h3><p>用链表和一些可删堆模拟，每次只考虑同一长度就很快。记得数组要够大，满 2 的次幂。</p><h3 id="Luogu-P3426-POI2005-SZA-Template"><a href="#Luogu-P3426-POI2005-SZA-Template" class="headerlink" title="Luogu P3426 [POI2005] SZA-Template"></a>Luogu P3426 [POI2005] SZA-Template</h3><p>从 fail 树上考虑：是 $n$ 的祖先，且子树内相邻数差最大不超过自己。</p><p>感觉，这种归纳方式很没有道理，不适合复习。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 2024 十月做题记录</title>
    <link href="/sol-2024oct/"/>
    <url>/sol-2024oct/</url>
    
    <content type="html"><![CDATA[<h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><h3 id="AGC068B-01-Graph-Construction"><a href="#AGC068B-01-Graph-Construction" class="headerlink" title="AGC068B 01 Graph Construction"></a>AGC068B 01 Graph Construction</h3><p>很有意思的构造题。关键是用简明的办法刻画增量的形状，并保持一点 <code>1</code> 的数目为 $n$ 的原则。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>一场 Luogu Div.2 月赛，一般般，最后一题 5 pts 纯属搞笑。</p><h3 id="Luogu-P11143-「SFMOI-Round-I」Strange-Cake-Game"><a href="#Luogu-P11143-「SFMOI-Round-I」Strange-Cake-Game" class="headerlink" title="Luogu P11143 「SFMOI Round I」Strange Cake Game"></a>Luogu P11143 「SFMOI Round I」Strange Cake Game</h3><p>贪心。</p><h3 id="Luogu-P11144-「SFMOI-Round-I」Strange-Madoka-Game"><a href="#Luogu-P11144-「SFMOI-Round-I」Strange-Madoka-Game" class="headerlink" title="Luogu P11144 「SFMOI Round I」Strange Madoka Game"></a>Luogu P11144 「SFMOI Round I」Strange Madoka Game</h3><p>简单模运用交互题。</p><h3 id="Luogu-P11145-「SFMOI-Round-I」Strange-Homura-Game"><a href="#Luogu-P11145-「SFMOI-Round-I」Strange-Homura-Game" class="headerlink" title="Luogu P11145 「SFMOI Round I」Strange Homura Game"></a>Luogu P11145 「SFMOI Round I」Strange Homura Game</h3><p>同上。</p><h3 id="Luogu-P11146-「SFMOI-Round-I」Strange-Train-Game"><a href="#Luogu-P11146-「SFMOI-Round-I」Strange-Train-Game" class="headerlink" title="Luogu P11146 「SFMOI Round I」Strange Train Game"></a>Luogu P11146 「SFMOI Round I」Strange Train Game</h3><p>WC 2024 T3 的区间转前缀和修改做并查集 trick，这次不会再忘了。</p><h3 id="Luogu-P11147-「SFMOI-Round-I」Strange-Dino-Game"><a href="#Luogu-P11147-「SFMOI-Round-I」Strange-Dino-Game" class="headerlink" title="*Luogu P11147 「SFMOI Round I」Strange Dino Game"></a>*Luogu P11147 「SFMOI Round I」Strange Dino Game</h3><p>如果觉得扫描线 <code>set</code> 很麻烦，不妨想想二分……不过可以 <code>set</code>。还没补。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p>题单启动。</p><h3 id="Codeforces-1406E-Deleting-Numbers"><a href="#Codeforces-1406E-Deleting-Numbers" class="headerlink" title="Codeforces 1406E Deleting Numbers"></a>Codeforces 1406E Deleting Numbers</h3><p>筛只考虑素数，分块检验一个质因子，剩下的直接试。小心爆 <code>long long</code>，小心死循环。</p><h3 id="Codeforces-1012E-Cycle-sort"><a href="#Codeforces-1012E-Cycle-sort" class="headerlink" title="Codeforces 1012E Cycle sort"></a>Codeforces 1012E Cycle sort</h3><p>先考虑移动元素个数尽量少，那就是让不在原位的数尽量少，贪心匹配。然后和同种元素相关的不同环可以合并（就是欧拉回路）。然后发现可以增加一些代价换取更少的操作次数，让几个环一起轮换。</p><h3 id="Codeforces-1254E-Send-Tree-to-Charlie"><a href="#Codeforces-1254E-Send-Tree-to-Charlie" class="headerlink" title="Codeforces 1254E Send Tree to Charlie"></a>Codeforces 1254E Send Tree to Charlie</h3><p>发现每条边都 swap 一下，就像是自己和周围一圈点做了一次轮换，而只有一个点可以参与交换，把这个点找出来，看看刚好成一个置换环的方案数。注意里外都要找，然后代码逻辑要细心，不要少 <code>if</code>。</p><p>目前为止是独立解答。</p><h3 id="Codeforces-1292E-Rin-and-The-Unknown-Flower"><a href="#Codeforces-1292E-Rin-and-The-Unknown-Flower" class="headerlink" title="Codeforces 1292E Rin and The Unknown Flower"></a>Codeforces 1292E Rin and The Unknown Flower</h3><p>抽象 ad-hoc。发现一个一个问回超代价，那就问一些二元组，然后可以落实两个字母（除了特殊位置），暴力试。如果是 $n=4$，要特殊的办法，惊奇地发现可以压缩次数，一次出就开始枚举（毕竟 $n$ 很小），到最后还没试出必有 <code>OO</code>，那么左右仅有两种办法，所以考虑试 <code>OOO</code>。太深奥了。</p><h3 id="Codeforces-1033E-Hidden-Bipartite-Graph"><a href="#Codeforces-1033E-Hidden-Bipartite-Graph" class="headerlink" title="Codeforces 1033E Hidden Bipartite Graph"></a>Codeforces 1033E Hidden Bipartite Graph</h3><p>绕弯路也可以发现要找生成树，然后惊奇地发现已经分好层了，那就直接 check 即可。</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>ZR NOIP 10 连 day 5。说错了，是 NOI Plus。C、D 过难，不补。</p><h3 id="A-签到题"><a href="#A-签到题" class="headerlink" title="A 签到题"></a>A 签到题</h3><p>广义逆康托展开，所以是组合数学。非常好卡常！！要有卡常意识，写运算少点的算法。</p><h3 id="B-白石溪"><a href="#B-白石溪" class="headerlink" title="B 白石溪"></a>B 白石溪</h3><p>发现 Baka’s trick 合并复杂度太高，所以对决策单调性用其他的技巧：分治。把当前分治区间下既定决策的先定下来，发现二分决策点但是总复杂度是 $O(\textrm{len})$，细致讨论一下就只有一只 $\log$。</p><p>调试要关注端点到底能取到哪里，讨论还是要细致点。</p><h3 id="C-海棠仙"><a href="#C-海棠仙" class="headerlink" title="*C 海棠仙"></a>*C 海棠仙</h3><p>大概思路是做扫描线历史和，然后拆条件，条件 2、3 既然有单调性就双指针，用 LCT 维护树形，然后咋地。可以看 PetitSouris 老师的题解。</p><h3 id="D-华心彩"><a href="#D-华心彩" class="headerlink" title="*D 华心彩"></a>*D 华心彩</h3><p>感觉很复杂的图论构造。</p><h3 id="Codeforces-1081G-Mergesort-Strikes-Back"><a href="#Codeforces-1081G-Mergesort-Strikes-Back" class="headerlink" title="Codeforces 1081G Mergesort Strikes Back"></a>Codeforces 1081G Mergesort Strikes Back</h3><p>刻画变种 mergesort 的实质是：最低层保留不动，上推时是给前缀最大值们排序，剩下的跟班都跟在对应的前缀最大值后面。所以最低层的贡献直接计算，每两个最低段之间的合并只关心有多少概率形成前缀最大值和自身的反向偏序，枚举对应的元素前缀和处理一下即可。神题。小心左移溢出导致的 ub。</p><h3 id="Codeforces-1284F-New-Year-and-Social-Network"><a href="#Codeforces-1284F-New-Year-and-Social-Network" class="headerlink" title="Codeforces 1284F New Year and Social Network"></a>Codeforces 1284F New Year and Social Network</h3><p>首先由 Hall 定理，$m$ 条路径的虚树边至少 $m$ 条，所以有完美匹配。发现右边的叶子的父边的匹配有一个端点已经确定，所以考虑减量，而其对应的左树上的行为则是缩点，归纳证明完美匹配存在性总有，所以可行。注意不要写 <code>dep[p] &lt;=&gt; q</code> 这样的愚蠢代码。</p><h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><p>Cplus 联测，状态不错，不过还有余地。</p><h3 id="A-花园（garden）"><a href="#A-花园（garden）" class="headerlink" title="A 花园（garden）"></a>A 花园（garden）</h3><p>枚举，慢算法也能过……有很有道理的 $O(nmk+k^5)$ 算法。</p><h3 id="B-逆序对（inverse）"><a href="#B-逆序对（inverse）" class="headerlink" title="B 逆序对（inverse）"></a>B 逆序对（inverse）</h3><p>最优化问题可以只在「有用」的位置计算答案，然后扫描线。</p><h3 id="C-步行（walk）"><a href="#C-步行（walk）" class="headerlink" title="C 步行（walk）"></a>C 步行（walk）</h3><p>树上环游的重心结论。树上倍增处处用，但事实上树剖常数更小。留意取等和奇数 $\div 2$ 取整问题。细致繁琐的容斥。</p><h3 id="D-航行（sail）"><a href="#D-航行（sail）" class="headerlink" title="D 航行（sail）"></a>D 航行（sail）</h3><p>带环 DP 转移肯定考虑高斯消元。发现有效增量的范围为 $O(\sqrt n)$，状态得到压缩。进一步只做 $v=0$ 的 DP，把转移统一化为 $v=0$ 的状态之间的转移。</p><h3 id="Codeforces-1423M-Milutin’s-Plums"><a href="#Codeforces-1423M-Milutin’s-Plums" class="headerlink" title="Codeforces 1423M Milutin’s Plums"></a>Codeforces 1423M Milutin’s Plums</h3><p>SMAWK 算法板子题，注意需要递归。</p><h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><h3 id="Luogu-P10220-省选联考-2024-迷宫守卫"><a href="#Luogu-P10220-省选联考-2024-迷宫守卫" class="headerlink" title="Luogu P10220 [省选联考 2024] 迷宫守卫"></a>Luogu P10220 [省选联考 2024] 迷宫守卫</h3><p>DP（归并排序转移）预处理代价，然后模拟一次树上 DFS，注意对当前点只有不得不选 $w$ 的情况才选呢。</p><h3 id="Luogu-P5518-MtOI2019-幽灵乐团-莫比乌斯反演基础练习题"><a href="#Luogu-P5518-MtOI2019-幽灵乐团-莫比乌斯反演基础练习题" class="headerlink" title="Luogu P5518 [MtOI2019] 幽灵乐团 / 莫比乌斯反演基础练习题"></a>Luogu P5518 [MtOI2019] 幽灵乐团 / 莫比乌斯反演基础练习题</h3><p>推式子魔法。首先简化原式，然后直接莫反，难点在最后一个式子，必须把内部的式子化成足够快的形式才可以，不能太早知足于整除分块套整除分块。然后就是三元合并两元要多试两种可能。最后上记忆化，把相互抵消的乘法省略就过了。</p><h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><p>Cplus 联测，策略严重失误，低估了 T1 难度，忘记了 DP 造自动机的想法，瞎搞容斥，对 T2 的有效重构树想法来不及写好，T3 有更加简洁的 <code>priority_queue</code> 写法，T4 想不清楚也不会树哈希。感觉是一套好的难题，难的好题。事实上应该把暴力都打一打，然后在 T1 写简单的 DP 写法，T2、T3 应该多花点时间搞搞，也不至于赛时只过了 T3 然后非常靠后。</p><h3 id="A-序列（string）"><a href="#A-序列（string）" class="headerlink" title="A 序列（string）"></a>A 序列（string）</h3><p>非常好造自动机。把六种转移写出来：$o\to o,o\to 1,m\to o, x\to 1,m\to x,x\to x + 1$，然后对于前 $i$ 位定义 $\textrm{x}$ 状态为被修改，用值 $x$ 覆盖；定义 $\textrm{o}$ 状态为未被覆盖，$\textrm{ox}$ 为两种状态都可走（前面两个是只能走一种），然后套上面转移即可，但是这么写分讨太磨人。所以不如让状态变为 $(x,0/1)$ 表示 $\textrm{x}$ 状态末尾值为 $x$，能不能走 $\textrm{o}$，另一类状态是只能走 $\textrm{o}$，常数好像较大，但是好写，虽然没写过。</p><h3 id="B-贪吃蛇（snake）"><a href="#B-贪吃蛇（snake）" class="headerlink" title="B 贪吃蛇（snake）"></a>B 贪吃蛇（snake）</h3><p>基本的想法是在值域上扫，模拟每个点每次挑边界上最小点尝试吞并的过程。后面的步骤确实要熟练弄清楚才好办。</p><p>另一个可用的思路是发现最大值答案必定为 $1$，而从大往小扫的时候，当前连通分量最大值的答案可能与边界最小值相同（或者无解，取决于边界最小值和分量内和的大小关系）。这是删的过程，我们考虑加的过程。从小往大加点，往四周尝试连通。如果邻点已经被加入，那么看自己能不能被吞并，若可以就把答案引到自己来；若未被加入就暂不操作。整个过程并查集即可。</p><h3 id="C-蛋糕（cake）"><a href="#C-蛋糕（cake）" class="headerlink" title="C 蛋糕（cake）"></a>C 蛋糕（cake）</h3><p>考虑 DP，$f(i,j)$ 表示删完前 $i$ 个数，已经做了 $j$ 次全局 $-1$ 操作。这个操作的代价只和后缀严格最大值有关，所以只在严格后缀最大值转移。把方程写出来，有点像是把差分数组做全局取 $\min$ 操作，然后做一些差分数组的前缀 $-1$ 和全局加。发现是个凸包，所以维护所有的拐点、最后一段的斜率、整个函数的截距，用 <code>priority_queue</code> 即可。膜拜 Fantasy_Ball 老师帅气的代码。本人 <code>multiset</code> 被卡成 80 分。</p><h3 id="D-简单树上计数（iso）"><a href="#D-简单树上计数（iso）" class="headerlink" title="D 简单树上计数（iso）"></a>D 简单树上计数（iso）</h3><p>简明的换根方法应用。下文定义 $m$ 为原题的 $(n + 1) \div m$。</p><p>首先我们要会树哈希，做法就是 $f(p)\equiv C+\sum_{q\textrm{ is a son of }p} g(f(q))\pmod x$，其中取模直接用 <code>unsigned</code> 自然溢出即可，$g(x)$ 可以做 xor shift 方法，形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> ull <span class="hljs-title">func</span><span class="hljs-params">(ull x)</span> </span>&#123;<br>  x ^= x &lt;&lt; <span class="hljs-number">15</span>;<br>  x ^= x &gt;&gt; <span class="hljs-number">25</span>;<br>  x ^= x &lt;&lt; <span class="hljs-number">27</span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后你就会了有根树的哈希。接着因为要求新的叶子挂在每个点上，所以考虑换根。静态情况是：每个点维护一个 $\texttt{siz}$ 表示还没被放到一个大小为 $m$ 的分量的点数，从下往上累加，一旦遇到 $\texttt{siz}[p] = m$ 的就建树，$\texttt{siz}[p] &gt; m$ 的都失效。根所在的子树大小为 $m - 1$，就不管它。</p><p>然后要检测，检测的方法就是只考虑挂上叶子后的根所在分量是否出现了 $(n + 1) \div m$ 次，让这个叶子为根来算哈希值是容易的。关于它是否出现了若干次，就是每加入一棵大小为 $m$ 的分量，在分量内换根，算出每一个叶子作为根的时候的树哈希值，去重后丢到哈希表里面就行了。</p><p>接下来考虑全局换根。假设从 $p$ 换到 $q$，每次换根有两种情况：</p><ul><li>如果 $\texttt{siz}[q] &lt; m$，$q$ 不可能另起炉灶，所以做小换根（就是同个分量内的换根，只涉及树哈希值的简单运算，在这里还要做 $\texttt{siz}$ 值的修改）。不过换根后 $p$ 可能会出现一棵大小为 $m$ 的分量，要建，并且更新 $q$ 所在分量内的哈希值，或者更新 $\texttt{siz}$。</li><li>否则，如果 $q$ 有一个建好的分量，就把它删了。然后同样考虑重建 $p$ 分量或更新 $\texttt{siz}$。<strong>注意这里不要老是重新计算 $q$ 分量内哈希值，因此需要在预处理的时候即使分量无效也把哈希值处理出来。</strong></li></ul><p>如果去重做法是排序后 <code>unique</code>，复杂度是 $O(n\log n)$。改哈希表可以做到 $O(n)$，但是跑不过排序后 <code>unique</code>。</p><p>关于复杂度的进一步说明：对于某个当前根所在的连通分量，做小换根的时候复杂度均摊为 $O(1)$，建树最多建 $1$ 次，因为某个子树 $\texttt{siz}$ 一旦达到 $m$ 就会被剥离；大换根只会做 $O(n/m)$ 次，每次 $O(m)$，换根运算次数的总复杂度 $O(n)$。</p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>Zhengrui，还行，但是 T3 没冲组合数学的正解，满足于 DP，T1 暴力写挂，T2 没有组合数学头脑，唉唉。</p><h3 id="A-Good-Subsegments"><a href="#A-Good-Subsegments" class="headerlink" title="A Good Subsegments"></a>A Good Subsegments</h3><p>哈希。我们不想枚举很多，关键在于总和不会超过最大值的 $\log n$ 倍，所以在最大值处枚举，然后哈希检验，双模取模即可，这样方便。另一种方式是模拟进位然后做异或哈希。</p><h3 id="B-Easy-Sum"><a href="#B-Easy-Sum" class="headerlink" title="B Easy Sum"></a>B Easy Sum</h3><p>看到奇怪的组合数，尤其是形如 $\binom{a+b}{a}$ 的，要想到两点间格路方案数！所以就转化为对于所有 $(0,k)$ 求它到所有 $(a_i,b_i)$ 的方案数和。直接不好做，所以考虑分块（这是可以想到的）。对于每个块内的点，第一次走出块要么在左边界要么在下边界，分开来讨论，块内的贡献暴力算，边界到所有 $(0,k)$ 的做卷积，平衡时间复杂度得到 $O(n\sqrt n\log n)$。块长适当调大以获得更优表现。</p><h3 id="C-Funny-Cost"><a href="#C-Funny-Cost" class="headerlink" title="C Funny Cost"></a>C Funny Cost</h3><p>首先发现最优解区间两两有交，故左端点都在左边、右端点都在右边。然后考虑具体匹配方案，拿最大值讨论，发现形如滑动窗口。冲好的复杂度就是讨论每个点的贡献，从大到小，计算组合系数，由每个窗口是同等地位、然后讨论每个数的放置即可。</p><p>太晚了，其他杂题都来不及写，诶诶。</p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>Cplus 联测提前享，还行，T3 不会，有点菜。</p><h3 id="A-社团活动（activity）"><a href="#A-社团活动（activity）" class="headerlink" title="A 社团活动（activity）"></a>A 社团活动（activity）</h3><p>区间数据结构板子题。</p><h3 id="B-电梯（lift）"><a href="#B-电梯（lift）" class="headerlink" title="B 电梯（lift）"></a>B 电梯（lift）</h3><p>题解讲得很好。就是盲猜这个背包有非常好的性质可以不做背包，直接往里面加。贪心地从大向小考虑，爆背包就新加一个。同时也可以证明每个大体积其实和体积为 $1$ 的等价。另一种规避讨论的是体积从小往大合并，将第一大和第二大、第三大和第四大……合并。</p><h3 id="C-高速收费（charge）"><a href="#C-高速收费（charge）" class="headerlink" title="C 高速收费（charge）"></a>C 高速收费（charge）</h3><p>这个太牛了。</p><p>平面图最短路等于对偶图最小割，所以就是要把最大流增加 $K$ 的最小费用，做费用流即可。注意无向图最小割的建图方式，双向边都有边权。</p><h3 id="D-抢凳子（chair）"><a href="#D-抢凳子（chair）" class="headerlink" title="D 抢凳子（chair）"></a>D 抢凳子（chair）</h3><p>讨论线性同余，把系数与模数的 $\gcd$ 拎出来算，这个东西发生变化的时候直接暴力重构。求方便可以并查集维护一下冲突的点。但事实上在每个周期，每个余数都只有唯一的根，维护即可。</p><h3 id="Luogu-P7916-CSP-S-2021-交通规划"><a href="#Luogu-P7916-CSP-S-2021-交通规划" class="headerlink" title="Luogu P7916 [CSP-S 2021] 交通规划"></a>Luogu P7916 [CSP-S 2021] 交通规划</h3><p>怨念解除。</p><p>这个割换成平面图最短路，一个无界面如果左右两条线颜色不同就要通过，否则不用。答案形如若干对需要通过的无界面的最短路，由交叉交换的方法可以得到一种最优解可以在环上构成括号匹配，直接区间 DP 即可。这码量太有水平。</p><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><h3 id="Codeforces-1656H-Equal-LCM-Subsets"><a href="#Codeforces-1656H-Equal-LCM-Subsets" class="headerlink" title="Codeforces 1656H Equal LCM Subsets"></a>Codeforces 1656H Equal LCM Subsets</h3><p>首先我们会做可以质因数分解的做法。然后发现不可以，所以考虑自定义一组数，使得出现的数都可以被唯一分解，那就可以了。</p><h3 id="Codeforces-1764G3-Doremy’s-Perfect-DS-Class-Hard-Version"><a href="#Codeforces-1764G3-Doremy’s-Perfect-DS-Class-Hard-Version" class="headerlink" title="Codeforces 1764G3 Doremy’s Perfect DS Class (Hard Version)"></a>Codeforces 1764G3 Doremy’s Perfect DS Class (Hard Version)</h3><p>能区分 $1$ 的就是问 $2$。先考虑 $n$ 是奇数的方法，就是二分的时候看左右两边哪个多一个落单（这个想法非常简洁化了信息），就往那边走。很有意思的简化写法：总是令左端点为 $1$、右端点为 $n$。</p><p>然后考虑 $n$ 是偶数，这时候发现 $n$ 也被区分了。所以如果遇到两边落单的相等，直接 check $n$ 在哪里。方法是直接问 $n$（要不然还怪浪费的嘞）。</p><p>然后我们就可以做到 $2\lceil\log n\rceil+1$，刚好差一点点。考虑优化。优化的思路应该是希望用上已经给到的信息。然后发现二分区间 $=2$ 的时候是一个突破口。如果 $n$ 为偶数且尚未确定 $n$，这里只做一次就可以分辨；否则一定形如 <code>1 x</code> 或 <code>x 1</code>，这时候上面的“落单”的想法就很好派上用场，我们已经由之前的信息获得 <code>x</code> 在当前二分区间的哪一侧，所以这里也可以只用一次查询。</p><p>妈呀，卡常卡疯了。</p><h3 id="UOJ-891-难度查找"><a href="#UOJ-891-难度查找" class="headerlink" title="UOJ 891 难度查找"></a>UOJ 891 难度查找</h3><p>非常好题。首先用 SMAWK 的想法，考虑提取偶数行。接下来就太高妙了：行列互换！当前层最多往右扩展 $n$ 次，则子矩阵要求到前 $(k-n)/2$ 小。整理一下，我们时时维护边界上凹陷处的点，发现复杂度非常好。证明不证，反正没把我搞到 $4n$。</p><h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><h3 id="ZR-NOIP-10-连-day-6"><a href="#ZR-NOIP-10-连-day-6" class="headerlink" title="ZR NOIP 10 连 day 6"></a>ZR NOIP 10 连 day 6</h3><p>摸了，没打满暴力，T3 如果把表打出来，如何也不好说呢。</p><h4 id="A-触不可及"><a href="#A-触不可及" class="headerlink" title="A 触不可及"></a>A 触不可及</h4><p>$O(n3^{\log_2 n})$。无语了。</p><h4 id="B-璀璨冒险人"><a href="#B-璀璨冒险人" class="headerlink" title="B 璀璨冒险人"></a>B 璀璨冒险人</h4><p>汉诺塔基本想法就是化归，实时维护状态长啥样就行了。</p><h4 id="C-蜃楼"><a href="#C-蜃楼" class="headerlink" title="*C 蜃楼"></a>*C 蜃楼</h4><p>打表发现周期。或者，你非常聪明，观察到了。</p><h4 id="D-我以渺小爱你"><a href="#D-我以渺小爱你" class="headerlink" title="*D 我以渺小爱你"></a>*D 我以渺小爱你</h4><p>神秘如斯。我们数学……</p><h3 id="ARC-185"><a href="#ARC-185" class="headerlink" title="ARC 185"></a>ARC 185</h3><p>打过最简单的一把 ARC，E 题太水。</p><h4 id="A-mod-M-Game-2"><a href="#A-mod-M-Game-2" class="headerlink" title="A mod M Game 2"></a>A mod M Game 2</h4><p>怎么大家做这种题这么快的？？</p><p>注意到 $n&lt;m$，考虑只有 Bob 在千方百计使 Alice 输掉，那就会留一张卡，让 Alice 无论何种方式都会在这里输掉，那就是 Alice 只剩一张卡了。所以看 Bob 可不可能留这么一张卡即可。构造可以看眼题解，反正就是可以构造的。</p><h4 id="B-1-and-1"><a href="#B-1-and-1" class="headerlink" title="B +1 and -1"></a>B +1 and -1</h4><p>每加入一个数肯定希望把它和前面的尽量推平，这是不劣的，模拟这个过程，可以全部推平就是成功。细节是：在已推平的高度极差为 $1$，并且这个高度不发生改变，那个拐点是不会右移的，如果不得不右移那是假了。</p><h4 id="C-Sum-of-Three-Integers"><a href="#C-Sum-of-Three-Integers" class="headerlink" title="C Sum of Three Integers"></a>C Sum of Three Integers</h4><p>对两个东西合并，把乘积记在加和处：想到卷积！！！手动讨论有点繁琐。</p><h4 id="D-Random-Walk-on-Tree"><a href="#D-Random-Walk-on-Tree" class="headerlink" title="D Random Walk on Tree"></a>D Random Walk on Tree</h4><p>（于次日补题。）非常好概率期望考察。</p><p>首先考虑简化版本：$m=1$，也就是要知道怎么考虑分叉。无论是递推还是整体刻画都可以得到答案是 $2(\frac{n}{n}+\frac{n}{n-1}+\ldots+\frac{n}{1})-1$。然后分析单叉变深的情况，但其实这里就可以猜最终答案是上面答案的倍数，然后直接写 $m^2$ 倍上去。当讨论一个叉期望要多少次才能走过叶子回到根（事实上我只关注深度的变化，毕竟最后一个叉到底的叶子概率还是均一的），居然要同时讨论上一个数和下一个数，系数都是 $\frac{1}{2}$。这时候，很好的想法是考虑这个东西的差分，然后就非常清晰了，就是 $m^2$ 倍。最后一次不用回到根，那期望步数是刚好折半嘛。</p><h4 id="E-Adjacent-GCD"><a href="#E-Adjacent-GCD" class="headerlink" title="E Adjacent GCD"></a>E Adjacent GCD</h4><p>$\varphi * I=\textrm{id}$。做完了。</p><h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><p>有点难受，可能是每次周末都会把状态弄坏。丧失代码能力。</p><h3 id="D-数字"><a href="#D-数字" class="headerlink" title="D 数字"></a>D 数字</h3><p>从高到低逐位确定，那还是挺常用的数位 DP 思路。让我调了半天的阻碍：发现习惯上从 $0$ 开始进行过程，但是实际上是 $1$，所以需要从低到高找答案的最高位，而带着 $0$ 从上往下找会增大耗费。</p><p>为什么不压位过不去呢，呵呵。</p><h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><p>Cplus，八中公益赛。该拿的分拿的差不多，就差 20。T3、T4 还挺有意思的。</p><p>顺便，【数据删除】你咋那么强？？？打不过【数据删除】，我打什么 OI？？？</p><h3 id="A-3-idots（string）"><a href="#A-3-idots（string）" class="headerlink" title="A 3 idots（string）"></a>A 3 idots（string）</h3><p>简单题。直接讨论 <code>X</code> 在左侧还是右侧，合法的条件是一个是另一个的子序列。</p><h3 id="B-冒泡排序（sort）"><a href="#B-冒泡排序（sort）" class="headerlink" title="B 冒泡排序（sort）"></a>B 冒泡排序（sort）</h3><p>我也不知道我是怎么会的，很难啊。这里选取的刻画冒泡排序的方法是：把每次 swap 记在较小数上，发现每个数要么成了前缀最大值，要么 swap 次数极差不超过 $1$。算一算每个数会被（作为最小值）swap 几次，一轮轮枚举就可以了。</p><h3 id="C-多重集（set）"><a href="#C-多重集（set）" class="headerlink" title="C 多重集（set）"></a>C 多重集（set）</h3><p>怎么现在不会拆条件了呢？这里涉及对 $\min,\max$ 的特殊处理，既然不是与起来的复合条件，就找出每个情况生效的条件，然后直接丢线段树就行了。</p><h3 id="D-简单题（easy）-Codeforces-878-E-Numbers-on-the-blackboard"><a href="#D-简单题（easy）-Codeforces-878-E-Numbers-on-the-blackboard" class="headerlink" title="D 简单题（easy）/ Codeforces 878 E Numbers on the blackboard"></a>D 简单题（easy）/ Codeforces 878 E Numbers on the blackboard</h3><p>这个题真是神了。贪心学艺不精，啊啊啊啊啊。</p><p>考虑增量，贪心意义下每个数要么继续做右儿子，要么从头开始（其实是新树根的右儿子）（除了第一个数，它只能是最左边）。妈呀。然后每个分量如果是正的，肯定希望继续加，所以肯定往前面并。这个东西扫描线的过程中，用并查集维护一下就行了。（冷知识，左端点并不会让右边的合并与否的决策改变，因为这个过程是每次从右往左做的，而且能做早就做了。）代码上留意各种能否取等的细节。</p><h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p>Cplus 联测，C、D 都是 ZR A 班讲过的，场上只会暴力，太菜了。题目名字挺有意思的。前两题和后两题 gap 太大。</p><p>顺便，【数据删除】、【数据删除】你们咋那么强？？？打不过【数据删除】，我打什么 OI？？？</p><h3 id="A-扭曲的（distorted）"><a href="#A-扭曲的（distorted）" class="headerlink" title="A 扭曲的（distorted）"></a>A 扭曲的（distorted）</h3><p>有点脑筋急转弯。发现整个方阵被覆盖的充要条件是四个角被覆盖，所以只有九类点功效不同，然后搜索或者分类讨论。</p><h3 id="B-命运（fate）"><a href="#B-命运（fate）" class="headerlink" title="B 命运（fate）"></a>B 命运（fate）</h3><p>简易计数。$x$ 前面的部分就把挂分当作后缀同时做，就不会对相对排名产生额外的影响，只考虑当前的相邻数对，方案数就是 $\prod (a<em>i-a</em>{i-1}+1)$。后面的部分只在乎挂分的递减，不必考虑相对排名，反正怎么挂都不会变，插板即可。</p><h3 id="C-深奥的（abstruse）-Luogu-P9731-CEOI2023-Balance"><a href="#C-深奥的（abstruse）-Luogu-P9731-CEOI2023-Balance" class="headerlink" title="C 深奥的（abstruse）/ Luogu P9731 [CEOI2023] Balance"></a>C 深奥的（abstruse）/ Luogu P9731 [CEOI2023] Balance</h3><p>我们虚点。我们虚点。我们虚点。</p><p>看到 $2$ 的幂想到分治，这是容易，但是把这个分治拎清楚还挺不容易。你想把一个点的所有移动都刻画出来，那直接在分治的时候考虑是否跨越中点，这是可以覆盖全部情况的，直接只考虑交换 $m+k$ 和 $l+k$ 就够了。对于度数为奇的点，诶诶诶，我们考虑把它往虚拟点连边，这样也只要找每个联通块欧拉回路即可，以定向刻画答案，简洁多了。</p><h3 id="D-困境（dilemma）-Codeforces-1707E-Replace"><a href="#D-困境（dilemma）-Codeforces-1707E-Replace" class="headerlink" title="D 困境（dilemma）/ Codeforces 1707E Replace"></a>D 困境（dilemma）/ Codeforces 1707E Replace</h3><p>我们倍增，我们倍增，我们倍增。</p><p>经典观察是把大的区间看作所有大小为二的子区间的并，发现怎么跳都有这个性质（这个其实部分分也有所提示）。然后，我们知道 $[1,n]$ 只会跳到自己，加上跳的模型，所以这里就是可以倍增的！！！唉。代码细节是，诶，如果把这个思想贯彻始终发现明面上写的是双端闭，实际是前闭后开来的。然后 Sparse Table 要特判空区间。</p><p>打了点 duel，不太打得动。感觉这周有点愚钝，注意力涣散，找点有意思的事情做啊。</p><h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><p>Cplus，不咋地，T3 没写离线、T4 没写扫描线暴力真是错完了，本来是有机会 AK 的。</p><h3 id="A-路径（path）"><a href="#A-路径（path）" class="headerlink" title="A 路径（path）"></a>A 路径（path）</h3><p>简单 DAG 上 DP，或者用拓扑序，如果两个点同时在队列里面说明互不可达，否则就是可以。</p><h3 id="B-异或（xor）"><a href="#B-异或（xor）" class="headerlink" title="B 异或（xor）"></a>B 异或（xor）</h3><p>把区间操作看成差分数组上的两个点同时操作，（模拟样例）发现如果一个子集异或和为 $0$ 就可以节省一次。怎么状压都可以。</p><h3 id="C-距离（distance）"><a href="#C-距离（distance）" class="headerlink" title="C 距离（distance）"></a>C 距离（distance）</h3><p>首先考虑简化版本（感谢部分分）想到点分治；所以只要对 $x$ 和 $y$ 同时做点分树上操作即可，但是我们发现在线的话空间是过不了的！！！哈希表也承受不了，所以把所有询问在 $x$ 一维点分治下去，同时对 $y$ 在点分树上做操作，空间复杂度少掉一只 $\log$。其实应该可以继续少，但是估计很难写呢。</p><h3 id="D-花之舞（flower）"><a href="#D-花之舞（flower）" class="headerlink" title="D 花之舞（flower）"></a>D 花之舞（flower）</h3><p>删掉的点至少有一个是一个最优解的端点。</p><p>扫描线。扫描线。扫描线。支持 $O(n^2)$ 扫描线暴力打败常数较大 $O(n\log n\log w)$ 弱正解。</p><p>我常数咋这么大？</p><h3 id="Luogu-P4769-NOI2018-冒泡排序"><a href="#Luogu-P4769-NOI2018-冒泡排序" class="headerlink" title="Luogu P4769 [NOI2018] 冒泡排序"></a>Luogu P4769 [NOI2018] 冒泡排序</h3><p>好题。</p><p>一个数如果只往左走，那么右边没有数小于它；如果只往右走，那么左边没有数大于它。这里的条件化简（重要！）：不存在一个点，使得左边有大于它的数，右边又有小于它的数，也就是不存在子序列 ${a,b,c}$ 满足 $a&gt;b&gt;c$。</p><p>数位 DP 的基本方法是枚举没压到这一位上的所有方案，然后把这一位压到边界再往下做。所以需要一种快速计数的办法。</p><p>打表发现如果没有任何限制，总数是卡特兰数，所以尝试模拟括号序列与满足上述条件的双射，维护一个指针 $i$，初始在第 $0$ 位：</p><ul><li>如果走到左括号，就把 $i$ 向右移动一位；</li><li>如果从左括号走到右括号，就输出 $i-1$；</li><li>如果从右括号走到右括号，就输出最小的没被输出的数。</li></ul><p>这样就建立好了联系。于是每次数数就只要数括号序列的个数，实际上是数不经过一条直线的格路的个数。每次枚举当前位，复杂度是 $O(n^2)$。如果当前位的边界不合法，可能的情况还是可以格路数出来，直接 <code>break</code>。</p><p>每枚举完一次，以后的枚举区间都不超过本次的枚举区间。发现有点像二叉树，不断向右走，而按朴素方法每次都在枚举右儿子区间大小，这不优。我们知道当前位填任意数的总和，用格路算，那可以变为枚举左儿子区间大小，总复杂度就是 $O(n)$。而在 ZR 2997，则是遍历二叉树的每个节点，所以应该遍历较小的子区间，复杂度是 $O(n\log n)$。</p><h3 id="Codeforces-1442F-Diffrentiating-Games"><a href="#Codeforces-1442F-Diffrentiating-Games" class="headerlink" title="Codeforces 1442F Diffrentiating Games"></a>Codeforces 1442F Diffrentiating Games</h3><p>神了，我们博弈论。怎么想到的啊。</p><p>每轮问 $20$ 次，总共只能问 $20$ 个点，别读错题。</p><p>题目强调可以环，想想环如何呢。然后我们就有「很有效率」做法，就是只考虑有自环的情况。发现这样的点不可能必败。而其它部分都是 DAG。</p><p>既然要用 $20$ 个点回答答案，首先要一个 $20$ 个点的完全 DAG，这样才能保证 SG 值互不相同，不会有任意两个点不能被区分。这 $20$ 个点取拓扑序最后 $20$ 个肯定是容易一点。假设这个点集是 $S$，每次一个一个问 $S$ 中的点，信息量最大，同时如果有一次输出 <code>Lose</code> 说明 $x$ 和这个点重合，直接输出即可。</p><p>接着考虑剩下的点，我们令它们都有自环。假设 $x$ 到询问的点有直接连边，下一步直接把 $x$ 移过去状态是必败态，所以必胜；否则无论怎么移都不会走到必败态，自环的点不会输，不同的点是必胜态，所以平手。所以让有自环的点到 $S$ 连边的终点集合两两不同即可。总次数：补完是 $\frac{20\times 19}{2}=190$，剩下的发现 $\binom{20}{3}=1140 &gt; n$，所以每个点最多改 $3$ 次边，加上自环，次数是 $4\times (1000-20)=3920$，总共 $4110$ 次，而且实际上跑不满。</p><h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><p>VJudge 写完了。</p><h3 id="QOJ-9126-Number-of-Abbreviations"><a href="#QOJ-9126-Number-of-Abbreviations" class="headerlink" title="QOJ 9126 Number of Abbreviations"></a>QOJ 9126 Number of Abbreviations</h3><p>一个删除方案对应一个 $t$，但是删除方案可能会到达同一个 $t$，算重首先长度相同，考虑滑动窗口方式 check，如果丢弃的字符和新加的字符相同就会算重，简化一下就是每对相同点对都会算重一次，直接算。</p><h3 id="QOJ-9443-Left-Equals-Right"><a href="#QOJ-9443-Left-Equals-Right" class="headerlink" title="QOJ 9443 Left Equals Right"></a>QOJ 9443 Left Equals Right</h3><p>直接背包吧，两边分别排列即可。</p><h3 id="QOJ-9435-Welcome-to-NPCAPC"><a href="#QOJ-9435-Welcome-to-NPCAPC" class="headerlink" title="QOJ 9435 Welcome to NPCAPC"></a>QOJ 9435 Welcome to NPCAPC</h3><p>理论上可以预处理矩阵的 $2^k$ 幂，然后优化矩阵快速幂，毕竟列矩阵乘起来而已。另一种办法是容斥，算有多少种不包含为子序列。</p><h3 id="QOJ-9116-DRD-String"><a href="#QOJ-9116-DRD-String" class="headerlink" title="QOJ 9116 DRD String"></a>QOJ 9116 DRD String</h3><p>最长 border 模拟 KMP 不好做，考虑取最短 border，只有对 $D$ 的限制是不含 border，从 $O(n^2)$ 发现可以优化为 $O(n)$ 递推，最后把 $R$ 为空的状态减掉。</p><h3 id="QOJ-9122-Japanese-Gift-Money"><a href="#QOJ-9122-Japanese-Gift-Money" class="headerlink" title="QOJ 9122 Japanese Gift Money"></a>QOJ 9122 Japanese Gift Money</h3><p>手模一下发现就是变进制数下有任何一位是奇数即可。然后直接数位 DP 一下。</p><h3 id="QOJ-9442-Music-Game"><a href="#QOJ-9442-Music-Game" class="headerlink" title="QOJ 9442 Music Game"></a>QOJ 9442 Music Game</h3><p>第一个切掉的，呃呃。</p><p>把 DP 写出来（右边往左边贡献），发现交换相邻数只会导致这里 DP 值发生常数的变小，所以可以排序，然后 DP 就可以了，把 $f_0$ 作为未知数，解一元一次同余方程。</p><h3 id="QOJ-9115-Contour-Multiplication"><a href="#QOJ-9115-Contour-Multiplication" class="headerlink" title="QOJ 9115 Contour Multiplication"></a>QOJ 9115 Contour Multiplication</h3><p>异或就考虑 01-Trie。把每个 tag 一起从上往下推，发现复杂度是对的。</p><h3 id="QOJ-9449-New-School-Term"><a href="#QOJ-9449-New-School-Term" class="headerlink" title="QOJ 9449 New School Term"></a>QOJ 9449 New School Term</h3><p>第二个切掉的，呃呃。</p><p>这种直接考虑从大往小贪心，判定有两个条件，一是没有奇环，这个用种类并查集即可；一是可以平分，这个把每个分量的左右差绝对值丢去做背包卷积算方案数 check，要删除分量直接除以这个多项式即可。</p><h3 id="QOJ-9411-Cosmic-Travel"><a href="#QOJ-9411-Cosmic-Travel" class="headerlink" title="QOJ 9411 Cosmic Travel"></a>QOJ 9411 Cosmic Travel</h3><p>还是 01-Trie，预处理每个子树出任何数的答案，每一层多计算本位的贡献，询问就转前缀和然后从上往下模拟，运用预处理的信息即可。</p><h3 id="Luogu-P4897-【模板】最小割树（Gomory-Hu-Tree）"><a href="#Luogu-P4897-【模板】最小割树（Gomory-Hu-Tree）" class="headerlink" title="Luogu P4897 【模板】最小割树（Gomory-Hu Tree）"></a>Luogu P4897 【模板】最小割树（Gomory-Hu Tree）</h3><p>注意每次连边是在选中的源汇之间连，就可以了。原理就是：假设 $S-T$ 最小割为 $C(S,T)$，把 $V$ 分为 $V_S$ 和 $V_T$，则 $\forall x\in V_S, y\in V_T, |C(x,y)|\le |C(S,T)|$，因为这组割就在那里。</p><h3 id="Luogu-P5632-【模板】Stoer-Wagner"><a href="#Luogu-P5632-【模板】Stoer-Wagner" class="headerlink" title="Luogu P5632 【模板】Stoer-Wagner"></a>Luogu P5632 【模板】Stoer-Wagner</h3><p>不太会证。假设我现在有两个点 $s,t$，求出了它们的最小割，以后我就可以把它们缩成一个点考虑。我们找一种比较好的选择 $s,t$ 的方式。就是每次在当前图维护一个集合 $A$，令 $w(x)=\sum_{y\in A}e(y,x)$，每次把 $w(x)$ 值最大的 $x$ 加入 $A$，可以证明最后一个加入 $A$ 的点 $t$，满足 $\forall s\in A/{t},C(s,t)=w(t)$。不太会证。</p><h3 id="Luogu-P3227-LOJ-2384-HNOI2013-切糕"><a href="#Luogu-P3227-LOJ-2384-HNOI2013-切糕" class="headerlink" title="Luogu P3227 / LOJ 2384 [HNOI2013] 切糕"></a>Luogu P3227 / LOJ 2384 [HNOI2013] 切糕</h3><p>这就是我的 Luogu 800 AC，呵呵。对 $x,y$ 平面考虑，每个点只有一个决策，所以求最小割，一个点应该是一条从 $S$ 到 $T$ 的路径，每条边分别是对应的决策，取一个即可。相邻决策离得过远会不合法，具体而言就是 $|x<em>1-x_2|&gt;D$ 会不合法，也就是 $x_1-x_2&gt;D\land x_2-x_1&gt;D$。对于 $x_1-x_2&gt;D$，割不合法就是在 $x_1$ 的出发点往 $x_2$ 的后面还有一条边权为 $\inf$ 的边，其实就是往 $p_i$ 向 $p’</em>{i-D}$ 连边。特判 $D=1$。</p><h2 id="19"><a href="#19" class="headerlink" title="19"></a>19</h2><p>Cplus 联测，场上会 D 却没写完，输。顺便，【数据删除】你咋那么强？？？打不过【数据删除】，我打什么 OI？？？</p><h3 id="A-冒泡排序（bubble）"><a href="#A-冒泡排序（bubble）" class="headerlink" title="A 冒泡排序（bubble）"></a>A 冒泡排序（bubble）</h3><p>实际上就是对 $\bmod k$ 同余类排序。</p><h3 id="B-染色（color）"><a href="#B-染色（color）" class="headerlink" title="B 染色（color）"></a>B 染色（color）</h3><p>条件化简！！不要拘泥于必须谨慎书写的 DP。首先留意到只要算 $\bmod 2$，所以考虑 <code>bitset</code>。考虑判定，注意到从 $a$ 可以到达 $a’$ 的条件是把相邻点缩起来变成 $b$ 和 $b’$，满足 $b’$ 是 $b$ 的子序列。所以数 $b’$ 个数后再考虑有多少个 $a’$，这个是可以组合数算的，而组合数即使不用 Lucas，直接 $O(\frac{n^2}{w})$ 杨辉三角也是可以的。每个 <code>bitset</code> 第 $i$ 位表示长 $i$ 的子序列，毕竟我们只关心长度和字符。从右往左的话，直接对每个首字符维护对应的 <code>bitset</code>，同时维护一个全局异或和，模拟一下就可以了。</p><h3 id="C-图（graph）"><a href="#C-图（graph）" class="headerlink" title="*C 图（graph）"></a>*C 图（graph）</h3><p>不可做。毕竟我做的题少，这什么套路完全不懂啊。</p><h3 id="D-山峦（mountain）"><a href="#D-山峦（mountain）" class="headerlink" title="D 山峦（mountain）"></a>D 山峦（mountain）</h3><p>很好难题。正解是状态数 DP，然后做高维后缀和，听说还要判一些无解。其实直接转格路，不越转不交，带 $x$ 做 LGV 然后拉插还原多项式即可，复杂度瓶颈居然是每次算单点值，单点次数为 $O(n^2)$，$O(n^2)$ 个点，插值 $O(n^3)$ 次，复杂度来到 $O(n^7)$，绷。代码细节在于：插 $t$ 个值次数会来到 $x^t$，要算到这一位；然后好好算偏移量。</p><h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><p>ZR NOIP 十连 Day 7。原题太多被 unr 了。T4 我们数数真是太厉害了。</p><p>今天晚上理一理后面自己可以多做一点的小目标。</p><p>感觉不会的题主要集中在计数、DP、数据结构（无论是序列还是二维还是树形）、贪心、逆天图论，倍增也不会做，还有点观察题。感觉啥都要做，要不要板刷 Ynoi 捏，或者做点模拟。</p><h3 id="A-水题-Mini"><a href="#A-水题-Mini" class="headerlink" title="A 水题 Mini"></a>A 水题 Mini</h3><p>既然随意重排，感觉一下在一些限制下才会爆最优解，应该是把两个数组排序后有序地匹配，然后直接 DP 即可。</p><h3 id="B-水题"><a href="#B-水题" class="headerlink" title="B 水题"></a>B 水题</h3><p>感觉就非常二分，有单调性。两个人能到的范围都是一个区间，如果下一个点没人能到就失败，如果只有一个人就让他过去，如果两个人都能到，嘿嘿，现在的状态变成一个人变成废人，另一个人还保持原来的区间，但总共有两种决策。共同点是一定有一个人过去了，可以发现把不走的那个人的区间变为这两个人的当前区间取并后，总是有合法对应方案的。</p><p>C 是原，QOJ 9411，就在上面。</p><h3 id="D-水题-Pro-Max"><a href="#D-水题-Pro-Max" class="headerlink" title="D 水题 Pro Max"></a>D 水题 Pro Max</h3><p>非常好计数 DP，还带容斥，多久没有带脑子计数 DP 了呢。</p><p>众数感觉很难刻画，但是众数不超过某个数好像有点办法。枚举 $i$，只要算有多少个序列满足每个数出现次数都不超过 $i$ 即可。这里容斥是可以想到的，钦定 $j$ 种数超限，乘上 $(-1)^j$ 的系数即可。复杂的在于怎么不算重不算漏。这时候的钦定大法！！！只在最后 $i+1$ 个把这个超限的数钦定下来（就应该这么设啊！），令 $f_{j,k}$ 表示已经钦定了 $j$ 种数超限，填了 $k$ 位，转移就考虑下一个空位，两种转移是填没钦定的数和新钦定一种数。本题卡常，可以考虑巴雷特约减或者卡寻址。</p><h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><p>MX-S，打破防了，T2、3 跟博弈爆了，T4 弃疗。</p><h3 id="A-youyou-的垃圾桶（wxyt）"><a href="#A-youyou-的垃圾桶（wxyt）" class="headerlink" title="A youyou 的垃圾桶（wxyt）"></a>A youyou 的垃圾桶（wxyt）</h3><p>整体只会做 $\log$ 次，剩下的二分即可。一种 $O(n\log n+q)$ 的更优做法是利用答案的单调递减，维护差分数组，手动减小答案即可。</p><h3 id="B-youyou-不喜欢夏天（summer）"><a href="#B-youyou-不喜欢夏天（summer）" class="headerlink" title="B youyou 不喜欢夏天（summer）"></a>B youyou 不喜欢夏天（summer）</h3><p>场上不会，盒盒。</p><p>对 <code>01</code> 的处理是要点，要么它选了至少 $2m$ 个是只选 <code>1</code>，多出来的都有正收益，要么全部都是两个都选，其余的决策不优，这是关键。DP 是平凡的。</p><h3 id="C-youyou-的序列-II（seq）"><a href="#C-youyou-的序列-II（seq）" class="headerlink" title="C youyou 的序列 II（seq）"></a>C youyou 的序列 II（seq）</h3><p>抽象博弈，抽象代码。</p><p>yy 的两个限制是同向的，所以要么可以选到最大长度，要么选不了，如果一个点不能被任何一个可以选的区间覆盖，那它对 yy 的防守是没用的。youyou 要把所有数标记为红，首先所有数要能被标记为红，就要每个数都不超过 $w_1$。假设现在有一些蓝色格子，youyou 无法把所有数都一下子标记为红，就是 yy 总是有一些区间，把 A 染红 B 还不是红的，那么把 A 染回去就可以了，那 youyou 就前功尽弃了。所以条件是 youyou 可以一下子把 yy 的区间全部染红。</p><h3 id="D-youyou-的三进制数（ternary）"><a href="#D-youyou-的三进制数（ternary）" class="headerlink" title="*D youyou 的三进制数（ternary）"></a>*D youyou 的三进制数（ternary）</h3><p>不会。</p><h3 id="Luogu-P6328-我是仙人掌"><a href="#Luogu-P6328-我是仙人掌" class="headerlink" title="Luogu P6328 我是仙人掌"></a>Luogu P6328 我是仙人掌</h3><p>发现 $n$ 很小，对每个点都处理出距离不超过 $i$ 的点是可以承受的复杂度。但是每个询问都形如“或”，所以考虑 <code>bitset</code> 模拟这个或操作，仍然是可以承受的。</p><h3 id="Luogu-P6327-区间加区间-sin-和"><a href="#Luogu-P6327-区间加区间-sin-和" class="headerlink" title="Luogu P6327 区间加区间 sin 和"></a>Luogu P6327 区间加区间 sin 和</h3><p>使用三角形的和差公式同时维护 $\sin$ 和和 $\cos$ 和即可。</p><h2 id="22"><a href="#22" class="headerlink" title="22"></a>22</h2><p>Cplus，题目不错，T4 场上没写完，纯笨，T1 挂分了。</p><h3 id="A-town"><a href="#A-town" class="headerlink" title="A town"></a>A town</h3><p>从下往上。一条边可以被断，当且仅当下面的分量异或和为 $x$，断完之后会与 $0$ 等价，所以一个联通块的异或和只可能是 ${s_i,s_i\oplus x}$ 之一，直接数就可以了。对每个点，先考虑儿子往上 merge，再考虑自己的父边是否断开，要注意如果是根是不可以做后者的转移的！否则 $x=0$ 的时候会多算。</p><h3 id="B-str"><a href="#B-str" class="headerlink" title="B str"></a>B str</h3><p>考虑针对左端点 DP，假设 $i$ 接在前驱 $j$ 后面，如果 $j$ 后缀大于 $i$ 后缀，发现是没用的，否则 $j$ 无论多长都可以，$i$ 从 LCP 时候开始全上即可，LCP 可以 $O(n^2)$ 递推。</p><h3 id="C-perm-P4778-Counting-swaps"><a href="#C-perm-P4778-Counting-swaps" class="headerlink" title="C perm / P4778 Counting swaps"></a>C perm / P4778 Counting swaps</h3><p>拆成每个置换环的问题，发现答案是 $n^{n-2}$，组合一下即可。这里的证明？？</p><h3 id="D-number"><a href="#D-number" class="headerlink" title="D number"></a>D number</h3><p>造自动机（这个还挺难的，只能搜索或者用严谨的推理，有大样例的话还行），矩阵快速幂。如果 $t\le 10^6$，就要光速幂。虽说，其实是等比矩阵列求和，导致我场上写不完，有点菜。</p><h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><p>联测。这么出题不会被喷么。</p><h3 id="A-mex-序列-Codeforces-1613D-MEX-Sequences"><a href="#A-mex-序列-Codeforces-1613D-MEX-Sequences" class="headerlink" title="A mex 序列 / Codeforces 1613D MEX Sequences"></a>A mex 序列 / Codeforces 1613D MEX Sequences</h3><p>DP，状态只包括 $\operatorname{mex}$ 和是否存在 $\operatorname{mex}+1$，单次转移 $O(1)$。</p><h3 id="B-判断题-P5326-ZJOI2019-开关"><a href="#B-判断题-P5326-ZJOI2019-开关" class="headerlink" title="B 判断题 / P5326 [ZJOI2019] 开关"></a>B 判断题 / P5326 [ZJOI2019] 开关</h3><p>神了，九条可怜。集合幂级数魔法啊。</p><p>写一下式子，下面用异或卷积做。令 $g<em>=p_i$（这里表示概率而非输入的数），$f$ 为答案，有 $f=f\ast g+cx^{\varnothing}+\sum_S x^S$（$f</em>{\varnothing}=0$ 要特殊修正）。手动做 FWT 得到 $f’<em>S=f’_Sg’_S+c+2^n[S=\varnothing]$，$S=\varnothing$ 时 $g’</em>\varnothing=1$，$c=-2^n$，否则 $f’_S=\frac{c}{1-g’_S}$。</p><script type="math/tex; mode=display">\begin{aligned}f_S&=\frac{1}{2^n}\sum_T (-1)^{|S\cap T|}f'_T \\&=\frac{f'_\varnothing}{2^n}+\frac{1}{2^n}\sum_{T\neq\varnothing} (-1)^{|S\cap T|}\frac{c}{1-g'_T}\end{aligned}</script><p>$S=\varnothing$ 时 $0 = \frac{f’<em>\varnothing}{2^n}+\frac{1}{2^n}\sum</em>{T\neq\varnothing}\frac{c}{1-g’_T}$。</p><script type="math/tex; mode=display">\begin{aligned}f_S&=\frac{1}{2^n}\sum_{T\neq\varnothing} ((-1)^{|S\cap T|}-1)\frac{c}{1-g'_T} \\&= \sum_{T\neq\varnothing} \frac{2[|S\cap T|\equiv 1 \pmod 2]}{\sum_i p_i-\sum_i (-1)^{[i\in T]}p_i} \\&= \sum_{T\neq\varnothing} \frac{2[|S\cap T|\equiv 1 \pmod 2]}{\sum_i 2[i\in T]p_i} \\&= \sum_{T\neq\varnothing} \frac{[|S\cap T|\equiv 1 \pmod 2]}{\sum_{i\in T}p_i}\end{aligned}</script><p>对 $\sum_i p_i$ DP 计数即可。</p><h3 id="C-连通性-P8860-动态图连通性"><a href="#C-连通性-P8860-动态图连通性" class="headerlink" title="C 连通性 / P8860 动态图连通性"></a>C 连通性 / P8860 动态图连通性</h3><p>非常好最短路题目。</p><p>首先我会乱搞，随便找一条路径，如果影响这条路径就尝试重构。然后，考虑是不是可以找到某一条最优的路径，假设 $t_i$ 表示第 $i$ 条边第一次被删的时间，那么这条路径满足 $\sum 2^{q-t_i}$ 最小（没出现过的边权为 $0$）。这里我们就可以主席树了，但是还不够。考虑在 Dijkstra 算法过程中只需要能够正确地比较两条路径的大小即可。假设有两条路径，末边的起点分别是 $a,b$，末边长度分别为 $e_a,e_b$，它们现在同时躺在堆里，既然是同时，说明两条路径的长度都不小于 $\min(d_a,d_b)$，不妨令 $d_a\le d_b,d_a+e_a\ge d_b$，如果 $d_a+e_a&gt;d_b+e_b$，则 $e_a&gt;e_b$。$e_a\le e_b$ 时，总有 $d_a+e_a\le d_b+e_b$，所以比较 $d+e$ 和比较 $e$ 是等价的。【我是不是在写批话？】</p><h3 id="D-数颜色"><a href="#D-数颜色" class="headerlink" title="D 数颜色"></a>D 数颜色</h3><p>我们数据结构……好难写啊，为什么点分树常数这么大。</p><p>既然数颜色，考虑邻域中的某个颜色的点，只要存在就让此颜色加一。发现虚树中这样的点形成一个联通块。这里对于“这样的点 $p$”明确一下限制：$r_p+\operatorname{dis}(p,x)\le d$，其中 $r_p$ 表示虚树内离 $p$ 最近的此颜色的点与 $p$ 的距离。也就是说，这个虚树中的点被激活，当且仅当至少有一个该颜色的点被激活。数联通块，想到点边容斥，即点数减边数为联通块数。边存在当且仅当两端都存在，所以边的邻域其实是两个点的邻域交。这里可能出现不存在中点的情况，为了规避繁琐写法可以直接把每条边倍长，则必然存在中点。然后就变为树上邻域数点了，这个点分树一下就可以了。每次询问逐级上跳，需要二分，毕竟有 $r$ 的存在，所以复杂度是 $O(n\log n+q\log^2 n)$。目前感觉常数很大，有无优化呢。</p><h2 id="24"><a href="#24" class="headerlink" title="24"></a>24</h2><p>Cplus，T3 挂分，T4 注意力不集中。</p><h3 id="A-法国"><a href="#A-法国" class="headerlink" title="A 法国"></a>A 法国</h3><p>这次学聪明了，答案单调递增，每次尝试能不能往下开。如果分母改变就重新计算，这里次数是调和级数。需要在线做单点加和区间求和，用树状数组，总复杂度 $O(n+q+V\log^2 V)$。</p><h3 id="B-酒杯"><a href="#B-酒杯" class="headerlink" title="B 酒杯"></a>B 酒杯</h3><p>感觉不用生成函数太难理解怎么想到倍增的。每一行的转移都有点不一样，想到还挺不容易的。</p><p>从递推式开始，$F<em>i(x)$ 是每行的指数型生成函数，$G_i(x)=1-e^{2^i x}$，有 $F_i(x)=F</em>{i-1}(x)G<em>{i-1}(x)$，$F_0(x)=1$。这个求积考虑倍增，令 $H_i(x)=\prod</em>{0\le k&lt;i}G<em>k(x)$，有 $H_i(x)=H</em>{i-1}(x)H_{i-1}(2^{i-1}x)$，乘到答案去也是同理的。</p><h3 id="C-铲雪"><a href="#C-铲雪" class="headerlink" title="C 铲雪"></a>C 铲雪</h3><p>可持久化李超线段树。注意判无解宁愿使用 <code>&gt;= INF - EPS</code>……</p><h3 id="D-飒妃客厮-·-啊瑞-CodeChef-TASUFFIX"><a href="#D-飒妃客厮-·-啊瑞-CodeChef-TASUFFIX" class="headerlink" title="D 飒妃客厮 · 啊瑞 / CodeChef - TASUFFIX"></a>D 飒妃客厮 · 啊瑞 / CodeChef - TASUFFIX</h3><p>冷静分析，对于 SA 中相邻的两个点 $i,j$：</p><ul><li>若 $s_j&gt;s_i$，必然符合条件，在“摇聚”的条件下有 $s_j=s_i+1$。</li><li>若 $s<em>j=s_i$，仍然要符合 SA 的性质，则要满足 $\textrm{rk}</em>{i+1}&lt;\textrm{rk}_{j+1}$。注意，空串的 $\textrm{rk}$ 为极小值，而非极大值（虽然我没有挂这里）。</li></ul><p>所以只要满足，$s_j$ 就会有两种决策，否则没有。直接用文艺平衡树维护区间操作，每一段内部计数、段的“末端”（就是内部无法计数的地方，一个段只有一对）计数、段间计数。复杂度 $O(m\log n)$。</p><p>代码细节包括：reverse 操作要交换左右儿子（这个没写也是没谁了）；段内无论是递增还是递减，除去末端每一对都是可以贡献的，这个手动讨论一下就发现了。</p><h2 id="26"><a href="#26" class="headerlink" title="26"></a>26</h2><h3 id="Luogu-P8867-NOIP2022-建造军营"><a href="#Luogu-P8867-NOIP2022-建造军营" class="headerlink" title="Luogu P8867 [NOIP2022] 建造军营"></a>Luogu P8867 [NOIP2022] 建造军营</h3><p>缩点，树上 DP，以点为本位，限制就是联通的树边必选，其它随便。注意点不一定呈一个联通块哦。</p><h3 id="CSP-S-2024"><a href="#CSP-S-2024" class="headerlink" title="CSP-S 2024"></a>CSP-S 2024</h3><p>CSP-S 2024。不是很想写游记，既没啥仪式感，也没啥值得大书特书的情节，只知道脑袋没放歌，输麻了，但好像也没啥办法。T4 没有对着部分分打，以为 140 min 时间总是充裕的，可以冲，还是菜了，大意了。又是和二叉树爆了的一场。</p><p>必须铭记：若没有 public 文件夹，手动建立。</p><h4 id="A-决斗"><a href="#A-决斗" class="headerlink" title="A 决斗"></a>A 决斗</h4><p>分析一下，就是求众数出现次数。</p><h4 id="B-超速检测"><a href="#B-超速检测" class="headerlink" title="B 超速检测"></a>B 超速检测</h4><p>分加速、匀速、减速讨论，留意二分细节，然后区间不为空就是计入，最后若干个区间，避免特殊讨论就按右端点排序，贪心选最靠右的。</p><h4 id="C-染色"><a href="#C-染色" class="headerlink" title="C 染色"></a>C 染色</h4><p>DP，$f<em>i$ 表示两个指针分别在 $i,i-1$ 时候的最优答案，发现以 $a</em>{i-1}$为下标开个桶，全局操作打个 tag 即可。</p><h4 id="D-擂台游戏"><a href="#D-擂台游戏" class="headerlink" title="*D 擂台游戏"></a>*D 擂台游戏</h4><p>我怎么知道这道题不可做呢。场上尝试 $O(tn\log n)$ 失败了，打了 $O(tn^2\log n)$。</p><h2 id="27"><a href="#27" class="headerlink" title="27"></a>27</h2><p>对本周的期待：把 CSP-S T4 补了，Ynoi 的 P5354 写一下，迷宫守卫补一下，感觉数据结构是比较明确可以加训的点。其它的，图论观察、容斥、DP 状态设计这些，做到再说，其实把以前的 AtCoder 没补完的题补一补都差不多了。</p><h3 id="ZR-NOIP-十连-Day-8"><a href="#ZR-NOIP-十连-Day-8" class="headerlink" title="ZR NOIP 十连 Day 8"></a>ZR NOIP 十连 Day 8</h3><p>摸鱼，怎么大家都不发挥。</p><h4 id="A-说谎"><a href="#A-说谎" class="headerlink" title="A 说谎"></a>A 说谎</h4><p>无脑做法：爆搜找规律。</p><h4 id="B-离歌"><a href="#B-离歌" class="headerlink" title="B 离歌"></a>B 离歌</h4><p>一般子序列计数，且模式串很短，直接考虑矩阵乘法的形式，用树上前缀和拆一拆。感觉空间好像撑不住，就多跑几次 dfs。</p><h4 id="C-爱错"><a href="#C-爱错" class="headerlink" title="C 爱错"></a>C 爱错</h4><p>容易想到的是找一个比较大的数，用一个 2 操作和一个 1 操作找到一个 $n$ 的倍数，假设这个是 $m=kn$。$k$ 为奇数的时候直接问 $\lfloor\frac{3n}{2}\rfloor$，这个数一定卡在两个 $n$ 的倍数之间（考场上没想到是 $\frac{3}{2}$ 呜呜）。否则就要二分 $n$ 有几个 $2$ 因子，其实也就是二分 $k$ 有几个，这里需要特判 $n$ 是 $2$ 的幂的情况。但是现在次数还是太大，是 $2+\log \log n$。我们考虑找的这个比较大的数是随机随出来的，那么随 $t$ 次，期望 $2$ 的最大次数约是 $\log t$，这个其实就是倒过来算一算错误率。所以只要在这个大小内二分 $k$ 中 $2$ 的次数即可。</p><h4 id="D-过火"><a href="#D-过火" class="headerlink" title="D 过火"></a>D 过火</h4><p>对单个分析得到结论是：从大到小排，答案是 $\sum a_i(\lfloor\frac{i}{k}\rfloor+1)$。如果是在线，就是把 $n$ 个元素拍成矩阵，取短边，用平衡树做即可。但是我们可以离线，所以考虑直接把全部数离线下来。$k$ 可以很小，所以指针本位不好做，所以对值域分块。每次操作就是把一个点设为 0、另一个设为 1，这两块重构，中间的要快速支持指针右移/左移 1，就是考虑块内的变化，以 $\textrm{rk}\bmod k$ 为标准分等价类，类数是 $\min{b,k}$ 的。清晰还是挺好做的。要开 <code>__int128</code>，不过 std 忘了，不过不影响场上得分！</p><h3 id="ARC-186"><a href="#ARC-186" class="headerlink" title="ARC 186"></a>ARC 186</h3><p>只会 BD，有点奇怪吧。</p><h4 id="B-Typical-Permutation-Descriptor"><a href="#B-Typical-Permutation-Descriptor" class="headerlink" title="B Typical Permutation Descriptor"></a>B Typical Permutation Descriptor</h4><p>刻画，发现画成树后，$0\sim n$ 是一个 dfs 序，固定根的时候每个儿子的大小顺序一定，其它的随便排。</p><h4 id="D-Polish-Mania"><a href="#D-Polish-Mania" class="headerlink" title="D Polish Mania"></a>D Polish Mania</h4><p>刻画，看看如何判定，像是你有一个累加器，每次把下一个数加上去，然后减一，如果中途不为负数且最后是 $-1$ 就判定正确，发现这就是不越过某条直线的格路，对字典序的刻画也是套路，详见冒泡排序一题。</p><h4 id="C-Ball-and-Box"><a href="#C-Ball-and-Box" class="headerlink" title="C Ball and Box"></a>C Ball and Box</h4><p>次日补题。赛场上策略假了，以为只会买 $m$ 个盒子，过不去样例，难绷。</p><p>策略应该是这样：假设 Mr. Box 选择集合 $S$，那么首先要求 $|S|\ge m$，Mr. Ball 会掐容量最小的加到满，然后逼迫往下买盒子，或者对方不干了。收益就是容量最大的 $m-1$ 个只有 $1$ 的容量，其它都会用满，减去买背包的花费。这个枚举最小容量的，实时贪心地维护较大容量的策略即可。</p><h4 id="A-Underclued"><a href="#A-Underclued" class="headerlink" title="A Underclued"></a>A Underclued</h4><p>次日补题。神了哥们。</p><p>看到矩阵，并且行和列有一定独立性，一种图论建模方式是建成二分图。然后就简单一点，一条边非 fixed 当且仅当它在一个 SCC 里面，然后直接做三维背包就可以了（左侧被定过 SCC 的点数，右侧被定过 SCC 的点数，还有非 fixed 的边数）。</p><h4 id="E-Missing-Subsequence"><a href="#E-Missing-Subsequence" class="headerlink" title="E Missing Subsequence"></a>E Missing Subsequence</h4><p>神神神，刻画、分类讨论的大神题目。下面规定 $f(x)$ 是题目求的那个集合，不限序列长度。一个小性质：这样的序列一定包含所有长度小于 $m$ 的合法数列为子序列。</p><p>考虑其它子序列里面，如果首位就是 $x<em>1$，假设 $x_1$ 首次出现在 $a_i$（必然存在啊），则有 ${a</em>{i+1},\ldots,a_n}\in f({x_2,\ldots,x_m})$。如果首位不是 $x_1$，后面的要存在，最难的是要求 ${x’_1,x_2,\ldots,x_m}$ 存在：</p><ul><li>如果 $x<em>1=x_2$，那么要求所有其它的数都在 $a_1,\ldots,a</em>{i-1}$ 出现，这样后面的 ${x_3,\ldots,x_m}$ 必定存在，$x’_1,x_2$ 也存在了。</li><li>发现关键其实是 $x_2$ 的出现，$x_1\neq x_2$ 时假设 $x_2$ 在 $a_i$ 前面最后一次出现是 $a_j$（这里和题解写的不一样，尚未理解），那么要求所有其它的数都在 $a_j$ 之前出现过。</li></ul><p>然后每次加一个数就是从后一位的状态往前面加一个串，这个形式是背包卷积。</p><p>后日补题完毕。</p><h2 id="29"><a href="#29" class="headerlink" title="29"></a>29</h2><p>我哪知道到处都是刻画，我该怎么办？</p><h3 id="A-随机游走-walk"><a href="#A-随机游走-walk" class="headerlink" title="A 随机游走(walk)"></a>A 随机游走(walk)</h3><p>邻项交换。</p><h3 id="B-分发奖励-reward"><a href="#B-分发奖励-reward" class="headerlink" title="B 分发奖励(reward)"></a>B 分发奖励(reward)</h3><p>扫描线，线段树。</p><h3 id="C-卡路里-calorie"><a href="#C-卡路里-calorie" class="headerlink" title="C 卡路里(calorie)"></a>C 卡路里(calorie)</h3><p>单调栈，二维前缀和。还有决策单调性做法，服了，把 $n$ 开到 $5000$ 全部突突了。</p><h3 id="D-传话游戏-message"><a href="#D-传话游戏-message" class="headerlink" title="D 传话游戏(message)"></a>D 传话游戏(message)</h3><p>这个太神了，但是没想到多项式做法有点可惜，可能太摆了。考场上就想到一个演绎的办法是：每个数删掉的时候，保证删掉后的后继与它不相等。却没有进一步简化条件再做，急了。而且部分分写挂，既然把所有颜色减去 $1$ 判定就应该判是不是 $0$，而且组合数也把 $n-1$ 写成 $n$，唉。</p><p>把这个判定条件形式化一下就是，假设 $S<em>1$ 的第 $i$ 位存活到 $S</em>{t<em>i}$ 为止，那么要求 $\nexists i&lt;j,a_i=a_j,\min</em>{i\le k<j}t_k<t_j$。所以要把计数对象转为更加熟悉的数列，并且继续做到令 $j$ 为满足 $j>i,t_j&gt;t_i$ 的最小值，则 $a_j\neq a_i$。然后来数数列。这个条件转化很重要。</p><p>向右看齐，想到单调栈，实际就是要把区间最大值拿出来，做区间 DP，每个区间向右看齐的对象是开的右端点，现在我们的状态设计有三维：区间左端点、右端点、最大值（这里，钦定同样为最大的取最左的，因为这里只是钦定了左侧的看齐对象，必须严格大于左侧，右侧可以不必）。转移可以前缀和优化，剩下的优化空间在最大值一维，最大值取决于 $n$，所以考虑这一位有没有什么特点。</p><p>接下来一步非常魔幻，不过应该对这种只涉及加法和乘法的区间 DP 都适用。我们认为 $f_{l,r,i}$ 对于同一组 $(l,r)$ 而言，是一个关于 $i$ 的多项式，次数为 $r-l$，也就是说它的前缀和的多项式的次数为 $r-l+1$，把转移式拉出来就可以证明了。另，这个多项式在 DP 中不好转移，但是我们可以直接拉插。嗯，这题就做完了。</p><h3 id="Luogu-P5435-基于值域预处理的快速-GCD"><a href="#Luogu-P5435-基于值域预处理的快速-GCD" class="headerlink" title="Luogu P5435 基于值域预处理的快速 GCD"></a>Luogu P5435 基于值域预处理的快速 GCD</h3><p>想要 $O(1)$ gcd，必须预处理，$\sqrt V$ 以内的可以在 $O(V)$ 时间预处理完毕，所以对于每个询问，想要把它分成一些不超过 $O(\sqrt V)$ 的数的乘积。分解的障碍是，可能有一个很大的质因子，不过质数求 gcd 挺容易的，所以也挺接受的。所以假想最优时每个 $V$ 以内的数 $x$ 都可以写成三个数 $(x_1,x_2,x_3)$ 的乘积，这三个数要么不超过 $\sqrt x$，要么是质数。</p><p>也就是希望最小值最大，那就会希望先把大的质因子丢进去，然后再用小的把它平均一些。事实上这是可以的，形式化地，令 $x$ 的最小质因子为 $d$，$\frac{x}{d}$ 的分解从小到大为 $(x’_1,x’_2,x’_3)$，则 ${x_1,x_2,x_3}={dx’_1,x’_2,x’_3}$。$x=1$ 分解是 $(1,1,1)$。</p><p>证明：考虑 $x$ 只有不超过 $3$ 个质因子，它们不会同时乘在同一位，所以每个数要么是 $1$ 要么是质数。对于其它情况，必有 $d\le x^{\frac{1}{4}}$，则 $x’_1\le \sqrt[3]{\frac{x}{d}}$，$dx’_1\le\sqrt x$。</p><h2 id="30"><a href="#30" class="headerlink" title="30"></a>30</h2><p>每次 ty round 都会挂飞，不过这个 T2 确实是不擅长的，但不妨碍我完全不想补它。加训数据结构。</p><h3 id="A-铭记-remember"><a href="#A-铭记-remember" class="headerlink" title="A 铭记(remember)"></a>A 铭记(remember)</h3><p>位运算求和，经典想法是拆位。</p><h3 id="B-世界-world"><a href="#B-世界-world" class="headerlink" title="*B 世界(world)"></a>*B 世界(world)</h3><p>刻画一下，发现只会往右走，最后才可能回头。所以算每一个前缀 $\min$ 到底的答案，然后前后以 $2$ 的代价来回推就行。前面几个 gap 的规则是比较大的几个会被推平成某个值 $v$ <strong>或 $v-1$</strong>，二分。具体算，感觉有点繁琐，冷却一下吧。</p><h3 id="C-桥梁-bridge"><a href="#C-桥梁-bridge" class="headerlink" title="C 桥梁(bridge)"></a>C 桥梁(bridge)</h3><p>好像有简洁一点的做法。直观理解就是，把关键边和关键点拎出来，其它的直接求最小生成森林，然后把虚森林拉出来，枚举决策。写挂的点：虚树加入的 LCA 可能比当前链顶还高，要判栈空。</p><h3 id="D-生长-growing"><a href="#D-生长-growing" class="headerlink" title="*D 生长(growing)"></a>*D 生长(growing)</h3><p>好像是比较神奇的数据结构，把<strong>合并</strong>拉出来，还有什么单调性，还没研究。</p><h2 id="31"><a href="#31" class="headerlink" title="31"></a>31</h2><p>原。</p><h3 id="A-草莓-guiltiness"><a href="#A-草莓-guiltiness" class="headerlink" title="A 草莓(guiltiness)"></a>A 草莓(guiltiness)</h3><p>邻项交换贪心。</p><h3 id="B-三色-color"><a href="#B-三色-color" class="headerlink" title="B 三色(color)"></a>B 三色(color)</h3><p>三个指针为 DP 状态，发现与上一个最末指针差异很小，一个点位一旦被删除永不复用，单维护变化，维护行、列和，维护有效状态。</p><h3 id="C-博弈-game"><a href="#C-博弈-game" class="headerlink" title="C 博弈(game)"></a>C 博弈(game)</h3><p>打表得到结论，从低到高位建 01-Trie 来算。</p><p>D 是 1024 打的 D。</p><h3 id="Luogu-P5354-Ynoi2017-由乃的-OJ"><a href="#Luogu-P5354-Ynoi2017-由乃的-OJ" class="headerlink" title="Luogu P5354 [Ynoi2017] 由乃的 OJ"></a>Luogu P5354 [Ynoi2017] 由乃的 OJ</h3><p>树剖、线段树。位运算做到 $O(1)$ 合并。</p><h3 id="Project-Euler-813-XOR-Powers"><a href="#Project-Euler-813-XOR-Powers" class="headerlink" title="Project Euler 813 XOR-Powers"></a>Project Euler 813 XOR-Powers</h3><p>提交于 Hydro 域 stdtr1。</p><p>每次都是做卷积，考虑用 FFT 的方式，奇偶位分开，往下做。</p><h3 id="Codeforces-1519H-Chests-and-Keys"><a href="#Codeforces-1519H-Chests-and-Keys" class="headerlink" title="Codeforces 1519H Chests and Keys"></a>Codeforces 1519H Chests and Keys</h3><p>神了。发现可以用流刻画，用霍尔定理说明左边一定满流，直接枚举匹配。暂时不知道比较直观的理解方法。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Aizu 2993 Invariant Tree</title>
    <link href="/sol-AIZU2993/"/>
    <url>/sol-AIZU2993/</url>
    
    <content type="html"><![CDATA[<p>非常好 Prufer 序列数数，爱了。</p><h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>给定排列 $p$，求有多少棵点为 $1\sim n$ 的无根树，满足对于任意一条边 $x\to y$，边 $p_x\to p_y$ 存在。模 $998244353$。$n\le 5\times 10^5$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这题感觉没部分分做不了。</p><h3 id="从置换环发掘性质"><a href="#从置换环发掘性质" class="headerlink" title="从置换环发掘性质"></a>从置换环发掘性质</h3><p>部分分剑指一元环和二元环，启发我们从排列的置换环角度考虑（虽然好像没部分分也会想到？）。只有一元环，就是 Prufer 序列结论。只有二元环，打表发现结论是 $n^{\frac{n}{2}-1}$，如何理解呢？两个二元环合并，比如 $(a,b)$ 和 $(c,d)$，有两种方式：$a\to c,b\to d$ 或 $a\to d, b\to c$，每个二元环左右两种情况共 $2^{\frac{n}{2}-1}$，形成无根树方案数为 $(\frac{n}{2})^{\frac{n}{2}-2}$，最后要形成一棵树，要再连一条边，只能选择一个二元环连，那就是 $\frac{n}{2}$，乘起来就是结论了。</p><p>所以我们可以想想如何刻画两个环合并的过程。发现条件是两个环大小有因倍关系（否则边数过大），不妨假设 $a|b$，则连的边数为 $b$，方案数为 $a$。此后不可以有大小小于 $b$ 的环与 $b$ 相连，否则边数也是过大。所以一个大小 $&gt;2$ 的环可以向同大小合并，可以向比它小的合并，此后就可以将它删去。</p><p>假设我们做了很多操作，最后没有一元环和二元环，可以发现答案为 $0$。因为一个大小 $&gt;2$ 的环内部不能连边，一旦有连边就会成环。</p><p>那我们对整个算法就有一个雏形：对于 $&gt;2$ 的环，每个大小做计算，然后乘到答案去；对于一元环和二元环最终判断。</p><h3 id="只有一元环和二元环"><a href="#只有一元环和二元环" class="headerlink" title="只有一元环和二元环"></a>只有一元环和二元环</h3><p>我们已有的结论是：两者都没有，答案为 $0$；只有一元环，答案为 $n^{n-2}$；只有二元环，答案为 $n^{\frac{n}{2}-1}$。</p><p>打表发现，两种都有的时候，假设有 $c_1$ 个一元环，$c_2$ 个二元环（$c_1+2c_2=n$），则答案为 $c_1^{c_1-1}n^{c_2-1}$。可以用下方神秘 Lemma 证明。</p><h3 id="大于-2-的环"><a href="#大于-2-的环" class="headerlink" title="大于 2 的环"></a>大于 2 的环</h3><p>考虑大小为 $i$ 的环，假设有 $c_i$ 个，它们应该是自己形成了若干棵有根树，然后往因数合并。假设有 $j$ 棵有根树，那么总贡献是：</p><script type="math/tex; mode=display">\textrm{方案数}\times i^{c_i-j}(\sum_{d|i\land d<i}c_d)^j</script><p>括号内可以调和级数预处理（事实上由于不同的环大小只有 $O(\sqrt n)$ 种，所以可以 $O((\sqrt n)^2)$ 做），枚举 $j$，那么只需要求$n$ 个点划分成 $m$ 棵有根树的方案数。有以下的两条路可走（都是我想不出来的）：</p><h4 id="神秘-Lemma"><a href="#神秘-Lemma" class="headerlink" title="神秘 Lemma"></a>神秘 Lemma</h4><p>方案数为 $\binom{n-1}{m-1}n^{n-m}$。（这里已经考虑了所有根的组合。）</p><p>证明：我们设一个虚点 $0$，让所有的根与它相连，则 $0$ 的度数被钦定为 $m$，也就是它在 Prufer 序列中出现了 $m-1$ 次（另外一个儿子就是最后剩下来的另一个点），这样的序列的个数为 $\binom{n-1}{m-1}n^{n-m}$（注意 Prufer 序列总长为 $n-1$，因为增加了点）。</p><p>那就做完了。把这个式子直接带入只有一元环和二元环的情景，用二项式定理化简就得到结论。</p><h4 id="活用-Prufer-序列"><a href="#活用-Prufer-序列" class="headerlink" title="活用 Prufer 序列"></a>活用 Prufer 序列</h4><p>膜拜传奇大师 qwqUwU。</p><p>我们不枚举根的数目，直接算总贡献。沿用虚点的思想，算 Prufer 序列每一位的贡献。若这一位是 $0$，有 $\sum_{d|i\land d&lt;i}c_d$ 的贡献，令它为 $e_i$；否则有 $i$ 的贡献。然后做序列带权计数，每一步从 $c_i+1$ 种选择变为 $c_i$ 种 $i$ 的贡献或 $1$ 种 $e_i$ 的贡献，总贡献就是 $(e_i+ic_i)^{c_i-1}$。最后一条树边要再乘一遍与 $0$ 相连的 $e_i$ 贡献。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(getchar())</span></span>;<br>  <span class="hljs-keyword">while</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">while</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = x * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>), c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">14</span>];<br>  <span class="hljs-keyword">if</span> (!x) &#123;<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">while</span> (x) buf[d++] = x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>, x /= <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">while</span> (d) <span class="hljs-built_in">putchar</span>(buf[--d]);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">500005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DVS = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> T, N, prm[MXN], ans, cnt[MXN], coe[MXN];<br><span class="hljs-type">bool</span> vis[MXN];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  T = <span class="hljs-built_in">read</span>();<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    N = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) prm[i] = <span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i &lt;= N; ++i) vis[i] = <span class="hljs-number">0</span>, cnt[i] = <span class="hljs-number">0</span>, coe[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">j</span><span class="hljs-params">(i)</span>, <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (!vis[j]) &#123;<br>          vis[j] = <span class="hljs-literal">true</span>;<br>          ++len;<br>          j = prm[j];<br>        &#125;<br>        ++cnt[len];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i)<br>      <span class="hljs-keyword">if</span> (cnt[i])<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(i + i); j &lt;= N; j += i) coe[j] += i * cnt[i];<br>    ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">3</span>); i &lt;= N; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (!cnt[i]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bas</span><span class="hljs-params">((coe[i] + cnt[i] * <span class="hljs-number">1LL</span> * i) % DVS)</span></span>;<br>      ans = ans * <span class="hljs-number">1LL</span> * coe[i] % DVS;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != cnt[i] - <span class="hljs-number">1</span>; ++j) ans = ans * <span class="hljs-number">1LL</span> * bas % DVS;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c1</span><span class="hljs-params">(cnt[<span class="hljs-number">1</span>])</span>, <span class="hljs-title">c2</span><span class="hljs-params">(cnt[<span class="hljs-number">2</span>])</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(c1 + c2 * <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (!c1 &amp;&amp; !c2) &#123;<br>      ans = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!c1) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != c2 - <span class="hljs-number">1</span>; ++i) ans = ans * <span class="hljs-number">1LL</span> * n % DVS;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!c2) &#123;<br>      <span class="hljs-keyword">if</span> (c1 &gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != n - <span class="hljs-number">2</span>; ++i) ans = ans * <span class="hljs-number">1LL</span> * n % DVS;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != c1 - <span class="hljs-number">1</span>; ++i) ans = ans * <span class="hljs-number">1LL</span> * c1 % DVS;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != c2 - <span class="hljs-number">1</span>; ++i) ans = ans * <span class="hljs-number">1LL</span> * n % DVS;<br>    &#125;<br>    <span class="hljs-built_in">write</span>(ans), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
      <tag>排列</tag>
      
      <tag>Prufer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - ARC118E Avoid Permutations</title>
    <link href="/sol-ARC118E/"/>
    <url>/sol-ARC118E/</url>
    
    <content type="html"><![CDATA[<p>不太会容斥原理，选择一个和组合数学基本没啥关系的直接 DP 方法。</p><h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>定义排列 $a$ 权值为：在 $(n+2)\times(n+2)$ 网格图上删掉所有点 $(i,a_i)$，每步只能从 $(i,j)$ 走到 $(i+1,j)$ 或 $(i,j+1)$，从 $(0,0)$ 走到 $(n+1,n+1)$ 的方案数。现在把 $a$ 的若干位隐藏为 $-1$，求所有可能的 $a$ 的权值和。$n\le 200$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先假设完全观察不到容斥，才来暴力刻画 DP 状态。</p><p>考虑以路径为主体，只关心这个路径要走到的下一个点有没有被删掉。而每行、每列（除了 $0$ 和 $n+1$）都恰好有一个点被删掉。</p><p>假设当前路径已经走到 $(x,y)$，那么我们只考虑子矩形 $[0,x]\times[0,y]$ 的总和。每当路径走到 $(x,y+1)$ 或 $(x+1,y)$，都相当于是扩充了一行或一列，这扩充的部分可能有一个被删掉的点，也可能没有。这个删掉的点可能是某个 $-1$ 的决策，也可能是某个既定的决策。但是走到的那个点不可以被删掉，删掉的那个点要么在它下面，要么在它上面（或要么在它左边，要么在它右边）。基于这样的想法，我们设计状态来刻画。</p><p>$f_{x,y,c,a,b}(a,b\in {0,1})$ 意为路径走到了 $(x,y)$，所有合法的状态数。状态是路径和填数方案的总和，填数方案要满足：在子矩形 $[0,x]\times[0,y]$ 中，有 $c$ 个 $-1$ 满足 $a_i&gt;y$，$a$ 指示 $(x,y)$ 左边是否有点被删掉，$b$ 指示下边。</p><p>考虑顺推转移。初始状态是 $f_{0,0,0,0,0}=1$。</p><p>对于向上的转移，如果新的一行删掉的点不在左边，需要满足以下之一：</p><ul><li>$x=n+1$。</li><li>假设 $b$ 为 $a$ 的逆排列（未出现设为 $-1$），$b_{y+1}&gt;x$。</li><li>$b_{y+1}=-1$。</li></ul><p>转移系数为 $1$。</p><p>如果新的一行删掉的点在左边：</p><ul><li>如果有一个既定的点在右边，或者当前在第 $n+1$ 行，不可以转移；</li><li>如果有一个既定的点在左边，那直接转移；</li><li>否则要考虑这个系数，就是在 $(x,y)$ 的左边选择一个 $-1$ 填这个值，是 $c-1$ 或 $c$（因为第 $x$ 列自己可能被计入 $c$）。</li></ul><p>对于向右的转移，如果新的一列删掉的点不在下面，也是要满足三个条件之一，和上面向上转移不考虑删数的对称。</p><p>如果在下面，那么这一位如果有既定的决策也是直接以 $0$ 或 $1$ 为转移系数。否则，就要计算 $(x,y)$ 下方有多少个还未被填的值，这个可以推出。具体来说，令 $\textrm{nc}_i$ 表示有多少个 $j&lt;i$ 满足 $a_j=-1$，令 $\textrm{hc}_i$ 表示有多少个 $j&lt;i$ 满足 $j$ 不存在于输入的 $a$，那么这个系数就是 $\textrm{hc}_y-(\textrm{nc}_i-c)$，视情况加一（因为第 $y$ 行左侧可能有已经确定的 $-1$ 未被去除影响）。</p><p>写转移的时候还要留意一下 $c$ 的变化。</p><p>最终答案就是 $f_{n+1,n+1,0,0,0}$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>细节真的不少。如果会容斥原理还是不要不切实际地写这种东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">205</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DVS = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> N, nc[MXN], hc[MXN], arr[MXN], rev[MXN], cnt[MXN][MXN][MXN][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> ((x += y) &gt;= DVS) x -= DVS;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N;<br>  <span class="hljs-built_in">memset</span>(arr, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> arr);<br>  <span class="hljs-built_in">memset</span>(rev, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> rev);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i)<br>    cin &gt;&gt; arr[i], rev[arr[i]] = i;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">2</span>); i &lt;= N + <span class="hljs-number">1</span>; ++i)<br>    nc[i] = nc[i - <span class="hljs-number">1</span>] + (arr[i - <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>),<br>    hc[i] = hc[i - <span class="hljs-number">1</span>] + (rev[i - <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>);<br>  cnt[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>); x &lt;= N + <span class="hljs-number">1</span>; ++x) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); y &lt;= N + <span class="hljs-number">1</span>; ++y) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">c</span>(<span class="hljs-number">0</span>); c &lt;= x; ++c) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>); a &lt;= <span class="hljs-number">1</span>; ++a) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">b</span>(<span class="hljs-number">0</span>); b &lt;= <span class="hljs-number">1</span>; ++b) &#123;<br>            <span class="hljs-keyword">if</span> (!cnt[x][y][c][a][b]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt;= N + <span class="hljs-number">1</span>) &#123;<br>              <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coe</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>              <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> == N + <span class="hljs-number">1</span> || arr[x + <span class="hljs-number">1</span>] &gt;= y) coe = <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (~arr[x + <span class="hljs-number">1</span>] &amp;&amp; arr[x + <span class="hljs-number">1</span>] &lt; y) coe = <span class="hljs-number">1</span>;<br>              <span class="hljs-keyword">else</span><br>                coe = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, hc[y] - (nc[x + <span class="hljs-number">1</span>] - c - (a &amp;&amp; rev[y] == <span class="hljs-number">-1</span>)));<br>              <span class="hljs-built_in">add</span>(cnt[x + <span class="hljs-number">1</span>][y][c][a][<span class="hljs-number">1</span>],<br>                  cnt[x][y][c][a][b] * <span class="hljs-number">1LL</span> * coe % DVS);<br>              <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> == N + <span class="hljs-number">1</span> || arr[x + <span class="hljs-number">1</span>] &gt; y || arr[x + <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>)<br>                <span class="hljs-built_in">add</span>(cnt[x + <span class="hljs-number">1</span>][y][c + (x != N &amp;&amp; arr[x + <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>)][a][<span class="hljs-number">0</span>],<br>                    cnt[x][y][c][a][b]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> &lt;= N + <span class="hljs-number">1</span>) &#123;<br>              <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coe</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>              <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> == N + <span class="hljs-number">1</span> || rev[y + <span class="hljs-number">1</span>] &gt;= x) coe = <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (~rev[y + <span class="hljs-number">1</span>] &amp;&amp; rev[y + <span class="hljs-number">1</span>] &lt; x) coe = <span class="hljs-number">1</span>;<br>              <span class="hljs-keyword">else</span> coe = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, c - (!b &amp;&amp; arr[x] == <span class="hljs-number">-1</span> &amp;&amp; x != N + <span class="hljs-number">1</span>));<br>              <span class="hljs-built_in">add</span>(cnt[x][y + <span class="hljs-number">1</span>][c - (rev[y + <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>)][<span class="hljs-number">1</span>][b],<br>                  cnt[x][y][c][a][b] * <span class="hljs-number">1LL</span> * coe % DVS);<br>              <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> == N + <span class="hljs-number">1</span> || rev[y + <span class="hljs-number">1</span>] &gt; x || rev[y + <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>)<br>                <span class="hljs-built_in">add</span>(cnt[x][y + <span class="hljs-number">1</span>][c][<span class="hljs-number">0</span>][b],<br>                    cnt[x][y][c][a][b]);<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; cnt[N + <span class="hljs-number">1</span>][N + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - ZR 2925 逆序对(inversion)</title>
    <link href="/sol-ZR2925/"/>
    <url>/sol-ZR2925/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试." data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a4d0404ad887fbd7ad446ba08e1b92dd1252577c4aecc476bf885f7a618bfee2">014d9f2d516394911a9337af4e8d8556f44359f0b55f81c98248536055fd1b85d7b211bfe2f4fe80d966b9463fcb0d3d419bb4c8e328a1d6411081f43deddc5bcd6ff0983581e2161adaa2b9ed64de88666e5fd274b471b92280d9d96fcc5207ee724d11a190ea8f940858694f7dc3b10481ae3c3d9776bcf1bc4266a714de13192f8ecc9a67633d3579e5a6295eede8802f807320ea7ac7c4cce2fbfc2ad42fa39f34401c174b52575eb13388f911032154934c32a9cfd78aca4ce6961481a3cbd6421e805523543b0991e1304e09adbf1ec20f3da960a9229c9f908da9814e6ed049b73d5ae9ee69d2894c92e191b62d9d53a24929bd48e7e0abd5ffd3c0640691db516e21c9a2d249b71e13f0a1db9b051900cd2f0d526e6142de318493d6f867b461090372f95f5ecea84c79c07a69b7465e7fcbc868a0b376f559e5e90b5855b63e1595c553c5ced78e417077997e4296aabda6af460f3f4774ee09103ab05d4d9adbe20ca5e900d695e498530a193695198f017fc8ea9a83c67cc9b24fafd585954d1396bf64656d8ff842380ca334bbcfa4fb23a6ddaf9ddfaf0335471e01cafd5125153137584d82cda0dea57ce7ab0417245601663377f0599483b2c67c0a9dd8378a72d62aeec9ed279ffda9403e4cab4627fd9a9b153080763acb0c71ed97269351ccab7849050b35a895fc4c7d877ff7ea7140ebe414a152c02f640f2f0e911232772db6850ab33dfce23357355be8ea95e89626e49aa16aa62baf9d0b5cf3f502f75270cb648e3d97a9842d55eb8b922ab70cc13b9c42b1bcc23d6376455a8f09aa586e0d6340d5c5c2e5bec86191eef9da16a1e004904c0c5141c64e9756a9d3f393a89dcaa639de4895ac7f601e6f700be766299fa7e101a928d1a7ae59f45511a4ad982568b372d3a74e065684de1f999b48e9378ef2f84a3921265634dfc78937b0d3d9fb9cc2d052d4ae242cf0dc92ced50f1ff0537d4ad3a13a2c1038a094ca1fdeb17be7154ce8aec0d4622aed03b556d5432284b2ea96a94de0ee76c6ab4e4a4c9a98c1eae443d2f22395a70c74466ffdf9832073770720ffdab26f1f8133a336992b3085fc7a1055593675529bc1f3fd83517607098129b08b3946833fb64eab1902998ca8f3f953ba0755f20b762e264dc4407dff5b17ce3f3f8ea9fcffb66c9aa0b51cce067c686973f037a6ac95ed5371a11235f861d05e34f33937269d50f837dfb7fab40e00deaebcac87a6738b155d263c91ebd7baee25057562bca3c3fde4dd966e86a5c272988e282329ccb396dcb8f243b3308af543ab2205fa285e6cf5125a57f2ed8184c2f61db999f62d6bb408b11dfa46b4c05a5360ec787d7028e3a6c93f7b5db1342f390a700bbe6a9d7d9859248f626fb94cc9a314b0c0c86c0c222fade83f5f07e8c7d3ee82d32bb01596d6ad597a8eb0c5b27f0a2a027c693068fa82a8d875950e77545bdfc9f3b7c939e9ba168ba4a93b8c5d6b08e90b50db98b372e70871ff4a2f543156431e392f7d3297890d0aca24ca186d05fdf1e9e31e6ec9ffd50e7044df73e3bf7fc0431e646d1c3f1eb64ae9a760acd8b7e1c738bf682376d2312cdeb033b0ba6905e65c5c44b2c9a883f78c4101fe3396784e33fa632fa750c1996bd4f38faeaa3fbcf8feac6fb7aca7928ae023760bb1d37f59523f3b26b61e5e786f5ba28f4c95825fffcc2383da29f87370ac4a005c576e824c2cb53760162dc8a8e10bc396cea2b789438098c8fa0266618e5b2757473d400587878f555fedbefb55a9963475d8f8e6ed782a20e37f4f64b99c7e464c82035b7ef3d0938044a18fca26ee6dc2787ea024e3566c059c20ab09abd6de639bd1565eabb475d2e287b15bfb92991b75991957b12874c83f12e2a11f14cb72e7bc98d119b2ebba341335e801f57a26bde52fffe2f3d779678a89a6ddf8e5fe5e76c971fd89d691c30d6ece7897aeafc40e5f60f21222830cf62a2ce05aa74103427d8db1e5f1e3882580b4ce84e38246d961e065db2413c43895fd4e500c501f19d25fb37edddf3f47a78973b06435aec428e3f8907efd945734f868740cede83acc7342d9d77a379dd399191ffee0743f8446ebca200eb7a4c66d0dface86c1a0b1b3dc776cd27675fc7ce857f0c8f1068f6e1dfc0a182143bb0681ce9dbec625f5886d0569e548e4c1c0d44c5227b81397b0e29a786aa0756b7e7fafc2ad578fd8c980f7bd970ea492d15bb828d96d42ccb2163e5e05866d9d22d169702dddba744fc92ad5c64b7b43e9f6c4b87d475670d23f19ed6fd0076c9076a7d8880a40d9f27dbde2d3f6a4c0e049d272921d14e665d57f40abadba29db7479a34978678aa774ac543b0cfb23afbf35a1bd53ee71abe6eb0d6b304f4636227f478047fc701d86934abc8408ae8169d8536533f153a63927a1f8bcd260130fa528c4a911e3b7e2412c76181cb46fe5726f615aa08ba6b48ecaa4744768805d9adf23edf83555b6ba2234bf092b59699069e28332b540e70204997acbe4a031f4fd6e41d600760f1174cd7a7ce329a9d9bd132038845d2eca5d122590e393efae6fcf5680ab073dae4c3e1aeb9091f490290f8c66615ffd1732e768c9407a59e057e585ce13714df847d9d795d237c85431b7b39e715e26987e9e474ca9618fcca1239e39633f865dd76ce90a6fa80601844c5352d54a6f29d8b77979432b36dfe5978b8078aa684ad028071ddd044251077e14fe361f9577d8936f79ffb3680b1e52358cbde0dea70eb8d285fad428aec51cc4e3dc9d4812bc257e133533cbf7aa492981fbe1d423365b676ca59022ebe4534ca9327e42b64bf712b449ed9e2629cf9e0b54372ae07aff22219908890069dae1aff249911406344f5df4fee9b8a0e9379709b2ebf83ebfd6754b02036910533fb3d8d516f2914ac5b88fa6bff25c96f55d2b362c9aebcdbed3a25b28d30f78037acc378cb40d1577f568596e658f525ae752aafb997f32b07d029e47e71337c6f09d555776ad38844a21660e5834315c1309778ca4410c711c5247c77d492abb29e841e2356403600fed02550b02eecec5edc5bde9abd62a5430f9f5cf39190b57292757a4563a902252856dfe7428b68920385e4cfb2f7718d83a757a93b9cc146db69a2a406e7f6718cb93f9d004534bd62a33fde4dfcbf3726b7fef69ad75bbfc6710434714a664f080eee451497ddb9578285d286d0bc9b74c31fcb9738f229f48ba947781776ff35cb241f0ed241002a29bb210034b14579ae038766cb31cc5274fb9cdd8576fd27ed12fe85ac99ecc6934a408a40795ff5af02dbd297c7e02995526b2006c13d97c028e1fc79b7d03aeb17496d3730c1a10982e9c97c4bb3d96188124e799386a71eab63dbd352d145e2dfd680e2ce07390db865458c4a43e3d8572f7019a4dd3f4d9d0b0b27dbec7d43d93feeea4aa60104ded2783cb4df06a1340001e80cb1ae29dc6320e1c4232e952da180c49e39c6ca01f2e80f04ce97917f629c49771cdec6b9eb130f5dcb00db68bc8758b69f27e6d6beff126e8ee794cd57455ecccb6362ba19a0bb260146456475b575c6d39db2db01813d02ce45917a866e9c0a791b4664f5ac5aa736bd07e91805d2dccbe3687215bc803e84a3cd27882f88f05e04dc7b3bfebdbc72cd3f349e323a90b239f2615fbe29155199ae1a144f7541c8b846eb90cf5640bb39c8c4196ececc23198c5515ebc4f0ebc16d3f9316b7bfb8d83424d0465cb13aab0f3a941d21a20e5c8685fa989f48c10727e8663763e54c892bb965ecd9011bb514a3c245a5721fcc422f9e83602175ad2f68f45c2863bca21709a189fb005d95dfbb0dde1096a560bf4d3d0eed1c7075a23a11dfd0ba9c2074ffa7c7d760e3d9e6ac6c3e99119872116bcc34819f56ccd3eadf87846a5f8393b49a25b9d4b2b533c77252acaea52c2b41ca067302a40a2a1f7ca23c968b4e8a19a32c986ad169f3caeb14a90f4f56ed7fd9a847473e06f6e8e9bec38c4e145d12ab0854b8e2deb03e7222d505d77c0b5be82a53d526c24b8527f07f4533d549e3892a67f9fde061bbebf005b50f103b96ed6eb610a11e920459d6510488a61b506015d759db4d120f77071b16f618d0421c36b2adcc86e34cf47f6bf98fa20269dbe37628ad206899ec4ab245592c365e30ee44023ab85aa7db17b74773e21ee8b03c44b31b0c1fd2e8f4c695472c8dbeb06742ea038736694a23d76ba00f4bdd0ebe83c656ca1307f6745646cfcf86c338aed811d95871a53c7685d7f2850c9b2a891a1ee8397367dc85c37fdfcca816ee35d0b1755d2abc1fb8da4efda15e94fdff9fff9f145c3c647c8923de14ddd1f94bcdf9d33946fa58fdd5055632f6898550864f84376da2bc5063159d307fb29779b676b705492cddece04c2779042395e8a0d38f8030735ba055ccb3114f1f42015c3f2903676bf7baed6f1eb9f8f6eab31eaa1e3e84f66fe5290a6e5c0cafcc8964f5eceff66d1154f305b41f4c8b2d255f2dc21c661185565a3d54bb6bc5204a513582884636d6d492afdd6f1889788bb77dddeb8cbde9cad0e69fff6fd32a81f4b5ec788e0192d51e13bd9422cb33dd5bace32852b3b8bf05eef898e46f396ad866f89d8675ea7d32ae0fadb5ec76471769c2f7ad1bb6d057caa6a2a38f3a7a7360923e5d240e3d85a3300b491c6ecb45b4f0131363a109c114bca003e7e8a0d14ada8123ab66bb684428e9b2c57863027faa625df36b8a83b34d0753d8dd499f7c8fbfb84fb8f6becc788a13a692ce20a8f4d72dfc4e38024497f369ca0d7bb967fc39d98a6db5d45db5d738736d34b6feadcdfd32c7228d6724a7e0a394c11b71434ac90f9eb09f9f90dbf1016853d52ec7ec81f4d9597d12c17068abcecba90e0ab161cf49da43e4065abade63105f0e6fb378047f0c0ad0f812455ac8223cd126838c7e54679daf89127732f5b4934ebe668d3742860feeaa93517733ba7e764106960dd33cf64c6ec83224926f67c08e014a91d807d603436d252d10bee02e281d0691e83003845641429c48bed5bdb77fdca045ed935e4f5df39c8e6050024586b32bb2a0c6320b36370417a56892cc63fd3a2d17467b628d1272a3d768a0b56662875121e22e04ee29b3b87ce13ae75c3f7af2835ec83ba0ddb9318b50b7a0d335361229d56e15c4fbf3d836de561d18b8c60d8a03f36eff87f0fe5de3d17cd9ccc41fe3071476d4a4a5bda201b67e5aaa68f373c0da71149d126dea14655080515838ffb5525496ec679084bb2cdb986922ed4b57b34dbb7b8ce1c39a93c891a08b09f21f2fd63837cf5b3c723b07ee146781800e8ba21129e5c157eeac95cca3529406082b0705ef7ce03714f458b462440cf1e83a905806337ab8d466485acb0df9ccceb8b52b7ef2e3ddfaab01336f25844a2424b6c998857b3c83d0c616f3b3b750fe70f09e3a5d68f1adb53db48ccb3ddd5cb7a25cad8144408a11c0668421e5acc0b9556e6013dc32d7923f4b290d22b89a134914cd9619209844441537e5a887d8bb45618e11c9f14579c0009a91549413d8ba0c592662f29169b572326fff210586222c530814144694b74033571d98e4e2c0a29f3d14433a25f2e561d4fe2d08fa1785c936a4601a001ba19ed02cf1f925cea490993c4e145ad41b0b2fe6dbcd79df4beb07ef4cc3ad1cbce9ecb5f94b12e59fa4d460186cbbbebd6ed8bca52e1af40248e6d3d6a814be39c0841da7cd5b829de6f525037987631cfba941ccb0d0d0690fd6ac386601857d53a5a6000f5363bce1aec4fc5ea5957a3022ab62f7d952568ed39366bd92853604e32619099f2ed784bb6714a8ebefa2daafc3eb1c065aaffdeb3440f993445bd016c43e1d784504a8e3865f975a5e87eeec0c7c2c12e23583056ced6cb303e9269dbc25e4fbb948b56a342448399265cccae1dcae64cb9e0dfb4a5454babaf4eb6d2183c589e9eb630089ec9dad2f50ff2297949e635802938eff3fbe55c7abe2ebb82e4af139777b95027be5fbd02497e73cb5e833f362855d3c36abf0f22646ec467b71b885972fab2c397d38c2353688227cbf3759612df16dc0c959c6a142427cd7d8eb8bee8d2b7e8f6b1cd40a5fb4795574c1c6eb3007dafaaf22b13ae5935a2578e358e750985be3b69f648a93eb39027168ffffc163e46877c85f014039ceac1a2cc2f335a523b1628c4261b53ef10077c7a7bc69717678553e85b3a83996e8e0b4e40df111c1d6327de1dab8a7f26e9f9b3de4169add1f897bc86633efe1f749f67a7f9461c6a8224153c64cefbd97c224ddda2cd20cba5a1516cf3960c9c6d088f7f3ea70a9056ab4c56fe9063ed2975b6b3d25577af31107ecd23b3a9d1f34012d1c408ecfb53c8d5822a2bea19d16ecf37d37043f7fbb9feab23a96c7c0a57a87e15fddde5c5ec2d120bd5e77e910c26437aadf6245e36f1faf9c985230954a864eb234cb766a83deae1da6fa5b48f54e1715ffea9848948e5f9979687f032e4088e04f2ddd12b34bd94c44087be48d787d9a6db478dccf21619631c6ae16e76a8afc4c210768ab25d5ca4a6ebe09a24ecf06c63920cff53ba9f5da5eb249ee146eae237bf28a44e539d0d03fa6ad7b77cc3f348b56b061fe652d06fa38209685f110bd199a49770614e92aa5a36573a6c77a442d5e1134302e2b59ae823bda4a01c6634ccf2d86f4f724d49be0ec16541acc7241bba3ee4837146110968f3c9f97828a5748a3927cb1d5d812bab0d41a07d300436784839eeebdc2bea5f574f8ce7fcc5aef638b942ac9c95669b4a04acc581cc769a0bd1c506c1776e231fe7b815c0211f9b7904bdd2b8bb5ac6baa9ba51ba912466b6bbda6cb87b3c76954b71272c543c00e8b0cc67650743bc04fa109e84b29a12d22b5a5fb8d29632fd832e8e24c2d8653202c967ce1c8048e8c9236c3ac887495765433228a63605b2a5265a2ca23503f501020480912d4dd2d38b4872fdb439adc90da59455ca34d9d5ec41098781c3f8c3192714e98c464a549adb85cfaf76c263561620f244ddd4d23da6db7f7fd4ff9d672fd0197a4cad3dbf15aaa179624d92b9590b2464577dcac98ea559e31b52f3677e34e5cb7387a910a1e5a04eff95810aa1b0e5095f2953fe1a1c7aefe1b3c35814c598d368a12421706e0e1ce75c23529db8abd7b73dacb2f8da3d1f257e75c4742f3b15227319a90e96e0d2e6622364241cd78c0135f82d4add4e70330d5b1f4da1e3d35720eabb4eb7dccc6572205d8aa7cb47938280a8fe73a9039c0b0adfd77418e4634b9bc9fd199e5618dcd49073eb9a95897b273d1c72fa3b21fda7ea5e863a8bae71958e3ee87fe4937a990c1e5c082eb7fb62fb7f4b7119467abf8ee15f6f0d73d0f89db6cc453be8a4d752edb888b8f05bc0eade452a289fed2ed888f510ea3b8a1bbb6bbd2a3f41fd11b100a0a6569d2cf8d225ca61e220a419cfa0884e60c552cd4ab3a66155992833526c816f3e3554694daeb07eedb39c6b498eacdbe88d4c39c5f36417e57a2ea728f39de891f9e09154291942761d710e1660c2a3c2cfff0b211e700ccb34efa68e21c5f9174073158ec98aef99f623500647ac1094b6fbb5a4ce08e9f7a21768e9e6c6a6e85fd203a61a983a2767c11b856318b07d69954fded4bab4636bca28cb0d5a42042a57dfe5ad5a62e2b2ca45246b5716a1389908b1f32f3f9d28d8f533a30fbbaf696e2c1450e36d16d36d215a7567940590dc3642d27a621733fb37724cb56a1da82df62236de59d6eac5fbb5c3339dcbee507dede5354b5f34db0ac2ecf8d49fb2469ebeb6ccf149b2e5800c0b34fcffd6340fcbc178a0ebec8cef00414dc7e87733e25599977ff3bebb6653db16b4469a458ec5fd29935cb58f0bfe59c4cac0a32a9a09e2bde43050c9461efc13acc5010166ada38cd915131b7bfa3f0c66cdc3b387e23a8213f3e3b625eed115caaee44828bd72a30530fb17ad405980d58bd5f2b8389d5d1e05265fa326541e8d9d928b6ce1e68a19a4be65ad06485d0bd05b77e5faa3363d18fa9f05cfef71a010e4787691dce8d3805affac10ab7ec47abced2930fd0ae2fad1b51c154a4045fa36eb8047334e98ce478c26c7501d687ebfdb82046621db339e77b243bb5fe9eb5863b0c3f97e4c4c5596a1ee64ed4788593ee0f075598ac3ce2921c337c15121f2015fec2336266fe1ecc6d73c2527b7397b09ad16815294528909a9e40c126ea9b171a6f404ade202e75597388feb0f7e365361b49a6ee2fd1b822990949db5230045e29d349175027b2298583524bb670a9ede7a48f40f83cba20a744b3389d225f0756949826fa80c9e640b01988471fd2adfb410318d8429a66a69b59191b5804d40401d5a25b48749255d2c86673cc85a858e7a212d8f718dd12e06006a6370820c97420f0f52a3a97bd074cd7646761abf307c0b1bb2280c3f75d8f6800500bb9930a8bfe3a8b91c8370b7810230ac70a3424f3ad79958c167c89ea96b3dfcdc70daf2fef146bb66e12becc36078f81ddf9013bbfe8ed738a2e1529d7986d5ef1b1048af65c1edcfeedf8ddd896cd1518a0f838bcce897cc81e37064a5a42cff9d687f3b283d5456a101f6eca1783e313f72ba36645b15d6dc124deec1f70ded90ac0a6b660fcf55a18dee9f658d80ecae5873709961a143359c2cd1b4ffd54b49615970983bdf7c50ae921e946827d89a39b65ee466af77bcfdaaf2b1edae752c30dfef610eae251e61e5789044ca802b0b7ea9c566fadbbea73443c274227a45df21a04b66e9906a3b40fdfd319b2271593b6e2fcf0ae0db10e6deec9473e1252d09637ea3abc003c5b1602cc500c07be39e47b0698beee23222db7581b74dc0a6ed01b4ef40b796abf03b66ccfebf3bf6bdd1669db37d0f88ebc1e5d53ca06f9c6f0f85a5a978be51421b2412d8b2b9605afba88801dfd7fb67abd9897a9ec0a545500550251fd0e0a484c04e356a291c5dae7973c452c94bf0b27081c074d6f419fbea06dec93bbeb934a9283b4b7fb67cf49cec5ff321e7dba39403c4ae92e2cfc2314ad858a73e35d79322f831e472af579771a43e105139578f64c65630995ca6f5ae433f416f2c2c180cafb087374561ab0eca3ddaf139949d092db78aa7918198d15d316640fe944fc62f2d94b704c748338b88e7813b9968c0d0a42229f14a9b40e8929eed13f8d8b718264f533da091dde8e0e4dc50a7b6495211f60d9e35bc2f18f29792a6b447f49f7b6c76f279fcc898567c95bfac7eb89b39608dd43fb20a6bf69c684890a860eec993ddb8b4013a226120cab3b22f3050712086582a59bc2ed1186e8ce470b78cf30d0f3cdd8f2e57b68493c8df51498ee7fb220287ea2b1fc3dd7d7063b710e4e4aab11b4c608c5ed8a1bf6a348e3caf47fab6158ea80d659edb3a1a71afe81b7d52b830f9a9d8dcb19cbbbf66c46e0dd4ec1250fd7d58e11a270cf106eec94ed375ba01d863d35df2291ac8510463bba7cc8f716b32480d7a756c5cc024f5be5d7471281d7124f927d845fa026e0749e3897c39a17f53016ccf4bc808136704dcd73cc5cb4aa353c8b53989925e37ab99b610187efeac238f8f8bb6545dc0ca8c50c9e1b05b4f63084856f1ee5b028784aab409147aca24bff90780ae4750e309750bd94bd71b01b5c9879f35e06ce0c8118e41e8ca4b0e4ffc4bf4ffcf0dae9cae0ce3bc467d5e06ff41b38fe3e9eba2542d8fc78f2952215485cacc6aa56d28a3745089afc0925e04a2cb69e6f64602d90bb11fbcafee1c22034ee3ddf08082b60bd5185e1f568d54f7b9e5a377a6357d176364e5f2113855dea8242e471e32da139de49c6c2d4cbe03f6db34a24610c0ced13bda0870f12335c49a2a3e445915eae316c656694955aefcb2d70c35de30355b85ebdde0ad87d61caf683bb714f97b297eafae3c954bdfb51ab83e5633b8894d5b45623dbf7c3cf25c759901598608e75631ef2690633078f10df8631f4f04823d0dd25c423165dde6e9c3916331478329a18ecb72e2533c43e275108ba12cb019198fe1e39c53d1ce6ebf9b0ee9632874dbb84914266cd3c4620bc2bcb7234d1e5b769b8a0a79457e30e111c3ad8151bc19cd94a7c7e472319bb55815bbd08c095e6fd94ef7f045e8055052e210c5900346f987eccc136708497e5902143d854caa825af7f12075d2e02f9c18f8df593af5a848e441a4ceb18f57065a53b2d6587c7df50148720f508ef9cce287464e40faf49732652999938052649207b593a918e1f3cf7404072136ce75fbaf77fcfac286aa90527c41d84a4c54d6060f2372e6792098206d2d1c96c59f2ac82f207a43259aad975aad1fcf8dcf1dde98a5c1b41f38ad2e6d5831eb2c8402c5f59a458a7a290b8d771ebbb0eaafef93e11bb9c9a42d2c0f8719a85f2f0953eaf779d0dd99bbbda7301d0186d0e54e68e92c1fa9b02392b5e76ac5b3a706a9e8429d5ab692c0b8eb3677a0d927541e05b840757e413f95b9bdd6dce028e5c5ffaf83a942ce9a209e0c33a4dcef0058da3473f1198bdd2bd98756e026083a72250095970d85457076954ad631c5cf0de563f37c9f3c589dbe144b1e5f052b047f40ec18ab34805c19f95810ff7f088509f9b5c56f410d3f7da15b031a2b7405fa8eea623225d45eb6738875cc2d638a5cac2ab21942997881782dab532da85dbd1e9d599b54ed815655e27c74e8c7f7280fad9272cc90993355ee1f886b3b7128f984da4a87b4bd5b3de4bf4798cbc914ad39795b91b3f9ea3a2cf5a3af6689caf62cc9a0b760ff4366da5f027807541f8425f7d7f0b9bb4d3a37ad7ff96196935b3de35d371bd99abe2a80ab00e3340d34771eb24d26ed7b5bc44e637a7b8c4657873eb8bde76f4055cf969e3ddee5a17c697dec49198bc12eb5cfaa6f29dfb07627c15ec0fcd81edee362f31bda2f48012bab5cbdf012a3c58d5b839b7a4707e3739c84b673bcc2dc04552281afa4fcd3cbe0df9dfe1abf363fcb7cede5fa52a8875747450192497ef5a4f442415dd8369d17b923a27d6ca5ec17de6c0bda8459f439a25c719bac3dddd7ae917ebd9c88c90880c52ad42ee94ee201da4ec17a9ad8a3b7b616ed57707bc1bdcacbe5edcf58f8e0be95a60de2ea87b601ac24839f27a8205f7fb1261d1dd1f3750e1a9ebeab91a1f29d134bad5b78612b3439fcc2f24e999e7ac3c000d5aae4c8b8306c7653dbca227bedf1950a0607844aa853dcf3d34cf1a3080a85db1c031a1ae9998bdc32f4277b6f465b7b503af91cede4b534a3ab902df15868f08bb56a339d5e40d3b05631d66a428d943c12503ac95411b9ba74d41ded21be600d61596cd34df1680b135945eb734af49c8f3c0992002af00daadee266260dad973acde1aabd07312e8899ad031dab30362f5c77ef157c1bda5ba520e414d62aec453d6f4490ef8d139669c83b34f88660f41dd8b151ef891c7a230f021f4c874b161f6307bc33b187ac740d0a1dddd3de626549cdf6f87ba57e7e5a3b01f52d779201963dab987eaf8b89b8a502f5c816d7cd8ccbfedbe6f47448c3a2956a69405403bb9e5442057cd43a9acf56505002e636504e441724ef5f97a81ceeb9dc68eddae3617386c9509b7d6b56ea6bfb1b1c3de124640052ebc53c12fda7e9dc9fb005edc5e2308160a556a1be186b13293373ae83565af41e87bfa968a70974345c2c8079d3c88271e7932c7cddb65f5fd7b8d81a26a3dbff712b1f1826e4d3e8207118ca9acc1c26472f497b49fe2aca90658ce76556e85cccccdef72bbcdad9a167e02916c0a22be70665a19fd2b238e023e43301bfe4d8f5fd02815bb4a2b2a300b6822060a1d05483cc1065799f89ba2cb9590b080279d83b3aa95f8507d341827d662843dc257c56a3cee72ef05979f339c8298a11f8ee4dd830f195d7f47303b6a54ad641dfbf3c40fbad4ac4d609dfa6a7a76b1c1d761fc77754e5e035bb76619bedba85f9df6efd87317801373462d4deacf3f180f332229dcd7a85e4be3e2a03186940b8ed893c7e543df0b7096653aca46ea4171cc9c81c8687c12a20d3507ffa0c5f1fe993518bc4007ad63984c3459046ee5e2ba26a28812f9732d96371d95c68dfd1014179de45ccf9e55f2b6bd8148a24614f888a017d595a69b6dff3387790db1bfe74006abb1d40fa0e174a31f309916ef7f85dc32a78b5a01a7717150d0683dbd1301a01d6ea5013c685c459e9f94fc4f9ed44e25a5c51e50513f48e3bd31c35b7a10de2155a822c53484005318d8cbe45d3d9b0e8afa81f8d1adb250606a9fdc41e396daa0fadad8d02b57c5c48ddde75ed68ae793d82b91509b264ce1f7edf83f369d2febe189635e38c81bd285553ad333dae533f61f06b1885b15b82469066084ddd6550c69f5ad9d6822002f2ff27cac816151b379a7331ce91839c7f53b424caf5622e462a730f6674e9493ce615e5f6fbfad09b2dcb354c28d696017bbfbe5cb25de0985600025c702f35e39740beb90aec078d6d20c36d8402c4572d4c946c3cae2d695d097eab8718ea5e497f3a5795eed33e2e8e57e8c4efce2ad31b94c6c18f3b46bf907f92db9f5cb20bd87a923967a27a54c5d8011aee7a31decd77008b30cbc0ce2209070276c6c06f034fc7067235860b5bd4b3a9549b0dde8f0cfeb319116048d9cc460334632d94a3a8b84ddc27709046a9857ba0e346a7abda123bec80ad63ee8f354be12c0aa208f21f21b6686c911e4c56ba2ec166bcf28a804ceb9bc1b723ade90bfe8c10d752a2080e439184ae0e900a55a2b90a8ab6722f6c9cf288e155654268cd4223dd6a9cf70990926434f521c8e575d821d600063df9c1f156fd21cb8dba5ae076189eb485ad1d232a14868b8e7280fdc079f91cac3b5a3d1fcef0342b16511a540209652db10d8fc73c50205db14796595f0bb0df90707e2b87b503bc042a38d576693c4a224d4a6dbdc8e117f141ffd8ea5df76e00e243abc467a33dced141a8ac20eeea8b8b97df740fad530260d68d43203d29ebe76231093415a7f47cfd5ec4792b899fa4258e520a019a0a7102a0fa61e8433c297b8f4b22e4722c41775e2f7ef3949f9ce28414f5466a8625edf3646f7e145d6ce50c285242df637dcbc51fe5bf80328eb56785cc663d53c9f60c0de2c11d39e5fbe74f6e364294dfc66f89ba74672074cebd24b713665b27b57217c8807456f7c0d05a70126693b8ce85993407559490f277d2a1dd7bfae6d833d1b27a135bd1154e1a823ec57c1d517a70984c096957561ab19a13a3f36a0edf103503fddf7a0101439bc159f59ed42a00a6f7275dc2d9ddbece802394b562b9b1321a5f5c53b9d1001c0a3a2c2312934f9b9408e6720ad67747c2d6d59570b03ea69c876a2cc788e53ac4e5241f48e7b838520a4f7c54e5ebd895f0b459b86afdf77771e33a3d8e6b1674d07d4ea920c52858b4fba843083d06e19c85786d8bc5d009119571556ca50bf0e32feb2b7f46464ab5d6c4ab9767fca41d90c8dbc215c837eadc7ff3807965204dcb88ea79b296a3f3b1cd0ee795ad295528198469b9fc1ea2235fcb47bc1ca232c906753f09647671ec659ee6b4ade1f112bd6bdb0eccc6b9f4972cc8bed85eb679fcbf042ccd8df93b9c08ec9ab0fa11544db754b98c0dc5761495639521acadb80002dd2c392efb906223b889b7daadb195424c4f8e71d1300b654277c8ad91a6ed8aa8332bdc7e98863ea2958a4d1a0175b8c1be8cf5bb4b1f53448e22e07725640a9dc61420d21a55e9452c1189a15640ce221f6c89de1f6db92793000ef0e51b2dc7cd43a8455ed94c5d4d77fc5284406c75737fe8daa233f20214f81d2839a168c8ef5aa9dedaa6b66ab553aa5db03dbf8378ac10e527db3a1d5c8ff05cee4797ef5fd8e410d45e139731658c60d5a139cf1e0032d641e7bb3052a4c425e4beba65135c62f935f81d4c87ecf1caf2be7fc3f410016ffb085b169b82845dcd85634a8c730a7c711c31d274432251461523d518761f2df488b169a50fa292e8cdfe4cfe941c4f96860adec32ecf0db64b54c59db97617df91735eb1ea566b2ca9161b03c9ed6d8e99e9131d736297d61398e25d02e6c413d2029780add6042e733ba81add6b191eeb7532c9de688618a05b4d8f76a76725ed144ba9f977984bf8f806d94a5a4e1b23a2dc56da1716183c7f1984d0a3a764c0868a9de44288d7711d6eb759d70817c2bab96f43249453b945799a2a55328981c91a608be401fc04c6c34d88687766ed002d4794af66dc2423c7894117e34cbf147737b83b78ee32953dc77fc4931861e264f58d27f64cd4725d5cf2c779dfa3dbe056eede2a7450f9af77d4985fe31112ad74705dfaa85b742f455d2c9fc718a335d5bfb80e0fef39abb62d67ec3c770589895260126d14ed291294a76b4697ab9ba44f79f54f2cf415b3ca36a84e452eb086f55183e878b18814e96a9b055008a6d8b4adbe92efadf0b5c946dea92bd69a23e6bbcf514f35c79a419618802ef54dcf61e2f969f3952a84a6e0997e3305bc1ea3a820b66e51e8663d543bccacfc846a75c038ef5128faf889b033d2331b127b5fffbd02ba557348e72421bf80b4f53f6a48fcb8692655185961011318137b8894a441df4d788fa97a3321255c3a2e005f6f5a9975987e3a9dc9499b99577850e346e3484580033eca86f54dd8e72e627452dc773381ff328eeaa4c84e313f7d52ebe6680638b5aae4fc39acd1e2f680da0db3c033cf1d23f420e90710870ffb6d8512d14caab16c548a3c5a846e69a9b218df408ee223fa9785e291a8b93d35425545a23574c3196345cbc86e774de8e2af936ae2483e94298acccfcd5c40be663215fc21555b55ec9791cbac5e9ecd47b844e09fb3a73f3bab98653beb2af560359dbbcddbbedc88caa6290e79597e525474f5a55b43df1c0c8810a73a6c27be9683e7942c6b982a084fe684fd859ce4ae08a6403a1b5d7e5fe4c95f345c77ea8b52fcee95dd06b5c7c3402403461467c0aba246a5153eb830e584fd9ebd4a2b74edc11dbab19ef88720d1ec2976978ae8e6cc4c94d7ee082e6fe854d77fa537dd3040ac9765c6bc925e52f4cdf0f88774c80bf7af0dbf71350e4e64e71f24faedb80ba8a030528d1ad6c28888dd99c15d58cc7e54094f8862ff484858ea19e5519efe8f6e1f984b9e1a1b4cae07dcfd25cb648392a9ca52a5ae99761aabecdd1a50992632d566bd26ac2bd791627ef266dab3cb24f7d87afd3314a06eb001c0b21c0b470094751dad1e3111170d84227aabd6dc77b874edca71d143a5592bccd5b17a7111765dc3f39beda2d13f50ccca4fb44d7bc7fc900ed24cd35616866acfb2448f35de73f59e13dc0753e67130140bc8f7dbc68d5e5bbce6c3ef0eb293aeab56f5950f86a448ab7b5d741fa6a45859c8abc6c29438f69c502f1c29f841ad0432bded88f20496228420007e2c9372de43215063b587ec39fde5d60b3bdf76ed159f496468ba6f703f5145a75045133b3e18047c4653b4b6e4122a6e0cd56baec0468ef7093b0c608657172efae459507e97dc7bf6d5c94ce90484c3df05c8b3adf6149924fcc450b02523fb1874103ec2a26582d91140eb09beed18e956c0b5e422e5f620b63f59451184e28c44f827a9d595892ac6087379d9d980e57fb22101f745b7c56286ffa0f0cc4740d6671a8ed9ac9af25b448d54e3f2a755089ecfba21a7931c74edeecc8a2f1f2323095f4cde695b3ee66135f5be6047bdefdc4f1d6f58bf6e68ec36bc3506198e82e547e9c33e77786bf2b5ba9901033e1f0e2e3bea61ef35472d7b3a1ebcc2414a4c8f233588d1b584ea7b826cecb3536882b5638a9090f9e3da240e70dc3b03fa8f244488a10d973f1e3c159e0a5ee9ecf1e092e358bffc8887bf6d962610ae7b2feb1db28e4605a3116428759262636fa5ef5664913209b58f43b20888e00e03d4bbd9a323da14c1e54648f784996beb322627589c8260856c2fab67d1a8d64ec17ad1c572c2abe3d1aee61b2d57911c4bcef04b7e457e92e26249649d89fb9b037093d930edc23b706638588f84cab126a6d4d0ab740ccafe3ccede8bf24f02219d2f74c1f80aedfd16cfb4a7b699c57419ff364ca4e13862eb288492d181181a34124a5b3504f41397f69c4d4149168f3a705cdbf93935bfed6e3d8dc1a6bdd8ce878cb9886161ac2ba377862cf22276241f32e9331e02e4fa8de9fa7e470748f501aa98c6f248081f8a7b4a87d180611853ee88c71c2dda5ebe5fd330fa069826025ea2a86e2b527efcccdd2ce07c4cc1a049ebe3c17446aca6ca615febcb720abcb77406c5698306f6806ff7163ad7b24e3d563288b6098aa0ccb0d43843f9c479978541f929eceac53d2ebeaa47adaeb981dbdab9698caedc000b24fa17ed07859fde60ab7f8f1af067b749a8bb28a739a226daeaacb433e87f7d8056d2b2295df75d4ed33a27198257f25fa4d0c4d93e601b0c9e71cefe750fa4fc2f9c76f0e1173997d7e4fc14cb22226bf85cd8d5030125c211a6324075e29fd49939ee3e8a86727d1f8c39ae3a1e93fbd770e535e962f8597878ae532214bf436d824e59834712f4d9c5a4f89b7a7dab669dca66d2e313bceefbbb2bd2aec16d67fd51be35b5d2e3ad2bab373a2d861179fc9bb56cfb6ab4163af358ab1ee9dd57a2f57dc74489de2b0e84bcefa3b29afe31764be6424c743448ac8683327fe8b291935f8432157bbb7f0caabb6db1a41be26bb53e4aec88b41108913e954ce3f8c574b3e5f2218efc934179f24504d5e740416ae86b730ad579cf07ad871e2493498d5eb3f5539bb6e75b8abd31cb4d42fd2715fd969c928223d4738667b290926c117c6e79c1ad3bd387d32619dcbcdea52de0a1a07d9be61177cf95e6b29ff3f60f3ac16b10a0615ed96378ba0b06</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好，请输入密码（我的真名全拼）</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
      <tag>双射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑记录 - 使用 hexo 搭建博客</title>
    <link href="/tech-blog-building/"/>
    <url>/tech-blog-building/</url>
    
    <content type="html"><![CDATA[<p>感觉写这个还是比较有必要的。2024.9.17 配置完成的博客，现在作一下经验总结。持续更新。</p><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><ul><li>安装 Git。<a href="https://git-scm.com/">https://git-scm.com/</a>。</li><li>安装 nodejs 新版。<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>。这里当时以为用 nvm 升级，结果 nvm 只有旧版本，不要用。</li><li>安装 Hexo。<code>npm install hexo -g</code>。</li><li>安装一键部署包。<code>npm install --save hexo-deployer-git</code>。</li></ul><h2 id="配置-SSH-Key"><a href="#配置-SSH-Key" class="headerlink" title="配置 SSH Key"></a>配置 SSH Key</h2><p>这一段，我是直接参照 <a href="https://www.cnblogs.com/chenlove/p/15058170.html">https://www.cnblogs.com/chenlove/p/15058170.html</a>（不如说整个流程都是参照它的），直接做即可。</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>仍然可以查看上面这一篇，或者查看 Hexo 官方文档 <a href="https://hexo.io/zh-cn/docs/setup">https://hexo.io/zh-cn/docs/setup</a>。整体的逻辑就是用 <code>npm</code> 管理所有的软件包。</p><h2 id="编写博客"><a href="#编写博客" class="headerlink" title="编写博客"></a>编写博客</h2><p>使用 Markdown。</p><p>一般有一个 front matter，就是在每篇文章的最上方有这样的文字：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">post</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">...</span><br><span class="hljs-attr">date:</span> <span class="hljs-string">...</span><br><span class="hljs-attr">tags:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">...</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">...</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">...</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>其他是正常的。</p><p>about 页的 layout 设置成 about。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>为了支持 KaTeX 渲染，使用了 <code>hexo-math</code> 和 <code>hexo-renderer-markdown-it-plus</code> 插件。</p><p>我目前使用的主题是 Fluid，官方文档很全面，整体也很好看。不过有一些细节文档没有提及，在下面贴出我的 <code>_config.yml</code> 和 <code>_config.fluid.yml</code>（可能不随时更新）。事实上至今我也不知道到底谁管的大谁管的小，反正都提供参考就是了。</p><h2 id="附加功能"><a href="#附加功能" class="headerlink" title="附加功能"></a>附加功能</h2><p>评论使用 giscus 插件，网页统计使用 busuanzi，具体配置直接看下方的主题配置文件吧，就跟在 post 一段后面。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Hexo Configuration</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="hljs-comment">## Source: https://github.com/hexojs/hexo/</span><br><br><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">SunsetGlow95&#x27;s</span> <span class="hljs-string">Blog</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">SunsetGlow95&#x27;s</span> <span class="hljs-string">Blog</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">SunsetGlow95&#x27;s</span> <span class="hljs-string">Blog</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">SunsetGlow95</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">Asia/Shanghai</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://SunsetGlow95.github.io</span><br><span class="hljs-comment"># permalink: :year/:month/:day/:title/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><br><span class="hljs-comment"># Directory</span><br><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span><br><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">code_dir:</span> <span class="hljs-string">downloads/code</span><br><span class="hljs-attr">i18n_dir:</span> <span class="hljs-string">:lang</span><br><span class="hljs-attr">skip_render:</span><br><br><span class="hljs-comment"># Writing</span><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><br><span class="hljs-attr">external_link:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span> <span class="hljs-comment"># Apply to the whole site</span><br>  <span class="hljs-attr">exclude:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">syntax_highlighter:</span><br><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">enable:</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">prismjs:</span><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># Home page setting</span><br><span class="hljs-comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="hljs-comment"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="hljs-comment"># order_by: Posts order. (Order by date descending by default)</span><br><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br><br><span class="hljs-comment"># Category &amp; Tag</span><br><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><br><span class="hljs-attr">category_map:</span> <span class="hljs-string">游记,</span> <span class="hljs-string">学习笔记,</span> <span class="hljs-string">题解,</span> <span class="hljs-string">闲话</span><br><span class="hljs-attr">tag_map:</span><br><br><span class="hljs-comment"># Metadata elements</span><br><span class="hljs-comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><span class="hljs-attr">meta_generator:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Date / Time format</span><br><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><br><span class="hljs-comment">## You can customize the date format as defined in</span><br><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-MM-DD</span><br><span class="hljs-attr">time_format:</span> <span class="hljs-string">HH:mm:ss</span><br><span class="hljs-comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><span class="hljs-attr">updated_option:</span> <span class="hljs-string">&#x27;mtime&#x27;</span><br><br><span class="hljs-comment"># Pagination</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br><span class="hljs-comment"># Include / Exclude file(s)</span><br><span class="hljs-comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class="hljs-attr">include:</span><br><span class="hljs-attr">exclude:</span><br><span class="hljs-attr">ignore:</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br><br><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:SunsetGlow95/SunsetGlow95.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br><br><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">katex</span><br><br><span class="hljs-attr">archive_generator:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">per_page:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">monthly:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">daily:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">markdown_it_plus:</span><br>    <span class="hljs-attr">pre_class:</span> <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-attr">langPrefix:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br></code></pre></td></tr></table></figure><p><code>_config.fluid.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Hexo Configuration</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="hljs-comment">## Source: https://github.com/hexojs/hexo/</span><br><br><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">SunsetGlow95&#x27;s</span> <span class="hljs-string">Blog</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">SunsetGlow95&#x27;s</span> <span class="hljs-string">Blog</span> <br><span class="hljs-attr">description:</span> <span class="hljs-string">SunsetGlow95&#x27;s</span> <span class="hljs-string">Blog</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">SunsetGlow95</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">Asia/Shanghai</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://SunsetGlow95.github.io</span><br><span class="hljs-comment"># permalink: :year/:month/:day/:title/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><br><span class="hljs-comment"># Directory</span><br><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span><br><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">code_dir:</span> <span class="hljs-string">downloads/code</span><br><span class="hljs-attr">i18n_dir:</span> <span class="hljs-string">:lang</span><br><span class="hljs-attr">skip_render:</span><br><br><span class="hljs-comment"># Writing</span><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><br><span class="hljs-attr">external_link:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span> <span class="hljs-comment"># Apply to the whole site</span><br>  <span class="hljs-attr">exclude:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">syntax_highlighter:</span> <span class="hljs-string">highlight.js</span><br><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">prismjs:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment"># Home page setting</span><br><span class="hljs-comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="hljs-comment"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="hljs-comment"># order_by: Posts order. (Order by date descending by default)</span><br><span class="hljs-attr">index_generator:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br><br><span class="hljs-comment"># Category &amp; Tag</span><br><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><br><span class="hljs-attr">category_map:</span><br><span class="hljs-attr">tag_map:</span><br><br><span class="hljs-comment"># Metadata elements</span><br><span class="hljs-comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><span class="hljs-attr">meta_generator:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Date / Time format</span><br><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><br><span class="hljs-comment">## You can customize the date format as defined in</span><br><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-MM-DD</span><br><span class="hljs-attr">time_format:</span> <span class="hljs-string">HH:mm:ss</span><br><span class="hljs-comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><span class="hljs-attr">updated_option:</span> <span class="hljs-string">&#x27;mtime&#x27;</span><br><br><span class="hljs-comment"># Pagination</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br><span class="hljs-comment"># Include / Exclude file(s)</span><br><span class="hljs-comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class="hljs-attr">include:</span><br><span class="hljs-attr">exclude:</span><br><span class="hljs-attr">ignore:</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br><br><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:SunsetGlow95/SunsetGlow95.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">https://s2.loli.net/2024/10/29/lUILWGcexEiNZjh.png</span><br><br><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://s2.loli.net/2024/10/21/iC5uDOy7pe3PzJw.jpg</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">热忱真理。</span><br>  <span class="hljs-attr">auto_excerpt:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">navbar:</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">SunsetGlow95&#x27;s</span> <span class="hljs-string">Blog</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;home&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-home-fill&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;archive&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/archives/&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-archive-fill&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;category&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/categories/&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-category-fill&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;tag&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/tags/&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-tags-fill&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;links&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/links/&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-link-fill&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;about&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/about/&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-user-fill&#x27;</span>,<br>    &#125;<br><br><span class="hljs-attr">archive:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://s2.loli.net/2024/10/21/iC5uDOy7pe3PzJw.jpg</span><br><br><span class="hljs-attr">category:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://s2.loli.net/2024/10/21/iC5uDOy7pe3PzJw.jpg</span><br><br><span class="hljs-attr">tag:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://s2.loli.net/2024/10/21/iC5uDOy7pe3PzJw.jpg</span><br><br><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://s2.loli.net/2024/10/21/iC5uDOy7pe3PzJw.jpg</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">katex</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">giscus</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-attr">views:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;busuanzi&quot;</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 次&quot;</span><br><br><span class="hljs-comment"># giscus: convert the given js into yaml</span><br><span class="hljs-comment"># 仅供参考，请使用自己在 giscus 获得的标签信息</span><br><span class="hljs-attr">giscus:</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">SunsetGlow95/SunsetGlow95.github.io</span><br>  <span class="hljs-attr">repo-id:</span> <span class="hljs-string">R_kgDOMxNR0g</span><br>  <span class="hljs-attr">category:</span> <span class="hljs-string">Announcements</span><br>  <span class="hljs-attr">category-id:</span> <span class="hljs-string">DIC_kwDOMxNR0s4Co1Jo</span><br>  <span class="hljs-attr">mapping:</span> <span class="hljs-string">pathname</span><br>  <span class="hljs-attr">strict:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">reactions-enabled:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">emit-metadata:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">input-position:</span> <span class="hljs-string">bottom</span><br>  <span class="hljs-attr">theme:</span> <span class="hljs-string">noborder_gray</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">zh-CN</span><br>  <span class="hljs-attr">crossorigin:</span> <span class="hljs-string">anonymous</span><br><br><span class="hljs-comment"># web analytics</span><br><span class="hljs-attr">web_analytics:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">footer:</span><br>  <span class="hljs-attr">statistics:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;busuanzi&quot;</span><br>    <span class="hljs-attr">pv_format:</span> <span class="hljs-string">&quot;总访问量 &#123;&#125; 次&quot;</span><br>    <span class="hljs-attr">uv_format:</span> <span class="hljs-string">&quot;总访客数 &#123;&#125; 人&quot;</span><br><br><span class="hljs-comment"># links page</span><br><span class="hljs-attr">links:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://s2.loli.net/2024/10/21/iC5uDOy7pe3PzJw.jpg</span><br>  <span class="hljs-attr">items:</span><br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;Project Euler&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;数学趣题。&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;https://pe-cn.github.io/images/32x32.png&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://pe-cn.github.io&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;Euclidea&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;尺规作图趣题。&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;https://www.euclidea.xyz/game/assets/favicon.png&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://www.euclidea.xyz/&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;csacademy graph editor&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;图论编辑器。&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;https://csacademy.com/static/favicon.png&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://csacademy.com/app/graph_editor&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;tldraw&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;在线白板。&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;https://www.tldraw.com/apple-touch-icon-180x180.svg&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://www.tldraw.com&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;sm.ms&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;免费图床。&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;https://sm.ms/favicon-32x32.png&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://sm.ms&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;latexlive&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;在线 LaTeX 公式编辑器。&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://www.latexlive.com&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&#x27;caijianhong - 博客园&#x27;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;大神的博客。&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;https://cdn.luogu.com.cn/upload/usericon/509229.png&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://www.cnblogs.com/caijianhong&#x27;</span>,<br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;Exber&#x27;s Blog&quot;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&#x27;大神的博客。&#x27;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;https://cdn.luogu.com.cn/upload/usericon/251130.png&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://rebxe.github.io&#x27;</span>,<br>    &#125;<br><br><span class="hljs-comment"># about page</span><br><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://s2.loli.net/2024/10/21/iC5uDOy7pe3PzJw.jpg</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">https://s2.loli.net/2024/10/29/gWdDbIaXM4Lrc53.png</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;SunsetGlow95&quot;</span><br>  <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;OI / 计算机 / 数学 / 音乐 / 音游 / 魔方&quot;</span><br>  <span class="hljs-attr">icons:</span><br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-codeforces&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://codeforces.com/profile/SunsetGlow95&#x27;</span>,<br>      <span class="hljs-attr">tip:</span> <span class="hljs-string">&#x27;Codeforces&#x27;</span><br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">class:</span> <span class="hljs-string">&#x27;iconfont icon-bilibili&#x27;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://space.bilibili.com/483357008&#x27;</span>,<br>      <span class="hljs-attr">tip:</span> <span class="hljs-string">&#x27;Bilibili&#x27;</span><br>    &#125;<br><br><span class="hljs-comment"># dark mode</span><br><span class="hljs-attr">dark_mode:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">default:</span> <span class="hljs-string">auto</span><br><br></code></pre></td></tr></table></figure><p>如果在加入 <code>hexo-renderer-markdown-it-plus</code> 后未将 fluid 语言调整为 <code>zh-cn</code>，将会变成德语，但不知道为啥。</p><p>我一开始尝试过其他主题，其中觉得比较好看的只有 particlex。但是它不支持 <code>hexo-renderer-markdown-it-plus</code>，代码高亮会死掉。开发者说推荐的渲染器是 <code>hexo-renderer-pandoc</code>，不过我没整成，懒了。</p><p>默认主题是 landscape。</p><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><p>以下全部都是工作目录在博客目录下，终端的命令。</p><ul><li>清空：<code>hexo clear</code>/<code>hexo cl</code>。</li><li>生成网页：<code>hexo generate</code>/<code>hexo g</code>。（它是惰性的，如果需要全部刷新需要先执行 <code>hexo cl</code>。）</li><li>本地预览：<code>hexo server</code>/<code>hexo s</code>。</li><li>上传到 GitHub：<code>hexo deploy</code>/<code>hexo d</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记 - 模拟退火</title>
    <link href="/note-simulated-annealing/"/>
    <url>/note-simulated-annealing/</url>
    
    <content type="html"><![CDATA[<p>早该写了，发现总是忘记，所以不得不写。</p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>最优化问题，并且规模很小。</p><p>你可以把不是模拟退火的用模拟退火做，并且获得不错的分数，只要你善于调整参数。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>假设我们已经有了一个策略，我们对它进行随机扰动，但是要扰动得比较有道理。</p><p>所以我们模拟退火，实时维护一个温度 $T$，初始是初温 $T_0$，每次乘上 $r(0&lt;r&lt;1)$ 以指数级减少，直到 $T$ 小于某个很小的数 $\epsilon$。每次随机扰动规模要和 $T$ 有关。每次扰动出新解：</p><ul><li>如果新解比原解优，则接受；</li><li>否则以 $e^{-\frac{\Delta E}{T}}$ 的概率接受。$\Delta E &gt; 0$，是新旧解优劣程度差的一种量化。</li></ul><p>其他的处理方法：</p><ul><li>可以卡时，就是在时间不超过某个限制时不断重复模拟退火。</li><li>维护全局最优解作为答案。</li></ul><p>我比较喜欢这两个做法吧。</p><p>随便丢几个代码就知道这咋写了。所有的模拟退火题都是板子题。难点可能在于调整参数，包括 $T_0,r,\epsilon,\Delta E$。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>Luogu P2503 [HAOI2006] 均分数据。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">22</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXM = <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> INIT = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> RATE = <span class="hljs-number">0.98</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> ENDS = <span class="hljs-number">1e-4</span>;<br><span class="hljs-type">int</span> N, M, val[MXN], sum[MXM], bel[MXN];<br><span class="hljs-type">double</span> av, tans;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != M; ++i) ans += (av - sum[i]) * (av - sum[i]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(ans / M);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gene</span><span class="hljs-params">(mt19937&amp; rnd)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">mans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">nans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  mans = nans = <span class="hljs-built_in">cal</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> <span class="hljs-built_in">temp</span>(INIT); temp &gt; ENDS; temp *= RATE) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(rnd() % N)</span>, <span class="hljs-title">col</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>      col = <span class="hljs-built_in">rnd</span>() % M;<br>    &#125; <span class="hljs-keyword">while</span> (col == bel[id]);<br>    <span class="hljs-comment">// cout &lt;&lt; id &lt;&lt; &#x27; &#x27; &lt;&lt; col &lt;&lt; &#x27; &#x27;;</span><br>    sum[bel[id]] -= val[id];<br>    <span class="hljs-built_in">swap</span>(bel[id], col);<br>    sum[bel[id]] += val[id];<br>    nans = <span class="hljs-built_in">cal</span>();<br>    <span class="hljs-keyword">if</span> (nans &lt;= mans) &#123;<br>      mans = nans;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rnd</span>() * <span class="hljs-number">1.0</span> / UINT32_MAX &gt; <span class="hljs-built_in">exp</span>(-(nans - mans) / temp)) &#123;<br>      sum[bel[id]] -= val[id];<br>      <span class="hljs-built_in">swap</span>(bel[id], col);<br>      sum[bel[id]] += val[id];<br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; mans &lt;&lt; &#x27; &#x27; &lt;&lt; nans &lt;&lt; endl;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> mans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  random_device sd;<br>  <span class="hljs-function">mt19937 <span class="hljs-title">rnd</span><span class="hljs-params">(sd())</span></span>;<br>  cin &gt;&gt; N &gt;&gt; M;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    cin &gt;&gt; val[i];<br>    bel[i] = <span class="hljs-number">0</span>;<br>    sum[<span class="hljs-number">0</span>] += val[i];<br>    av += val[i];<br>  &#125;<br>  av /= M;<br>  tans = <span class="hljs-built_in">gene</span>(rnd);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">clock</span>() * <span class="hljs-number">1.0</span> / CLOCKS_PER_SEC &lt; <span class="hljs-number">0.3</span>) tans = <span class="hljs-built_in">min</span>(tans, <span class="hljs-built_in">gene</span>(rnd));<br>  cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; fixed &lt;&lt; tans &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>P2538 [SCOI2008] 城堡。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">22</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXM = <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> INIT = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> RATE = <span class="hljs-number">0.98</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> ENDS = <span class="hljs-number">1e-4</span>;<br><span class="hljs-type">int</span> N, M, val[MXN], sum[MXM], bel[MXN];<br><span class="hljs-type">double</span> av, tans;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != M; ++i) ans += (av - sum[i]) * (av - sum[i]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(ans / M);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gene</span><span class="hljs-params">(mt19937&amp; rnd)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">mans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">nans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  mans = nans = <span class="hljs-built_in">cal</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> <span class="hljs-built_in">temp</span>(INIT); temp &gt; ENDS; temp *= RATE) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(rnd() % N)</span>, <span class="hljs-title">col</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>      col = <span class="hljs-built_in">rnd</span>() % M;<br>    &#125; <span class="hljs-keyword">while</span> (col == bel[id]);<br>    <span class="hljs-comment">// cout &lt;&lt; id &lt;&lt; &#x27; &#x27; &lt;&lt; col &lt;&lt; &#x27; &#x27;;</span><br>    sum[bel[id]] -= val[id];<br>    <span class="hljs-built_in">swap</span>(bel[id], col);<br>    sum[bel[id]] += val[id];<br>    nans = <span class="hljs-built_in">cal</span>();<br>    <span class="hljs-keyword">if</span> (nans &lt;= mans) &#123;<br>      mans = nans;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rnd</span>() * <span class="hljs-number">1.0</span> / UINT32_MAX &gt; <span class="hljs-built_in">exp</span>(-(nans - mans) / temp)) &#123;<br>      sum[bel[id]] -= val[id];<br>      <span class="hljs-built_in">swap</span>(bel[id], col);<br>      sum[bel[id]] += val[id];<br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; mans &lt;&lt; &#x27; &#x27; &lt;&lt; nans &lt;&lt; endl;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> mans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  random_device sd;<br>  <span class="hljs-function">mt19937 <span class="hljs-title">rnd</span><span class="hljs-params">(sd())</span></span>;<br>  cin &gt;&gt; N &gt;&gt; M;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    cin &gt;&gt; val[i];<br>    bel[i] = <span class="hljs-number">0</span>;<br>    sum[<span class="hljs-number">0</span>] += val[i];<br>    av += val[i];<br>  &#125;<br>  av /= M;<br>  tans = <span class="hljs-built_in">gene</span>(rnd);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">clock</span>() * <span class="hljs-number">1.0</span> / CLOCKS_PER_SEC &lt; <span class="hljs-number">0.3</span>) tans = <span class="hljs-built_in">min</span>(tans, <span class="hljs-built_in">gene</span>(rnd));<br>  cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; fixed &lt;&lt; tans &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>QOJ 3195 Within Arm’s Reach。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">25</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> T = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> EPS = <span class="hljs-number">1e-13</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> RATE = <span class="hljs-number">0.99</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-type">int</span> N, len[MXN], tx, ty;<br><span class="hljs-type">double</span> tlen, angle[MXN], ans[MXN], dans[MXN], dlen;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">cald</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(x * x + y * y);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">conv</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> theta)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(l * <span class="hljs-built_in">cos</span>(theta), l * <span class="hljs-built_in">sin</span>(theta));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">random</span><span class="hljs-params">(mt19937&amp; rnd)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">rnd</span>() * <span class="hljs-number">2.0</span> / UINT32_MAX - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function">pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">bool</span> output_mode = <span class="hljs-literal">false</span>)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    a = angle[i];<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(conv(len[i], a))</span></span>;<br>    x += vec.first, y += vec.second;<br>    <span class="hljs-keyword">if</span> (output_mode)<br>      cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>) &lt;&lt; fixed &lt;&lt; x<br>           &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>) &lt;&lt; fixed &lt;&lt; y &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(x, y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) cin &gt;&gt; len[i];<br>  cin &gt;&gt; tx &gt;&gt; ty;<br>  tlen = <span class="hljs-built_in">cald</span>(tx, ty);<br>  <span class="hljs-function">mt19937 <span class="hljs-title">rnd</span><span class="hljs-params">((random_device())())</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dlen</span><span class="hljs-params">(cald(calc().first, calc().second))</span></span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">clock</span>() * <span class="hljs-number">1.0</span> / CLOCKS_PER_SEC &lt; <span class="hljs-number">0.9</span>) &#123;<br>    <span class="hljs-function">pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(calc())</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">nlen</span><span class="hljs-params">(cald(vec.first, vec.second))</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> <span class="hljs-built_in">temp</span>(T); temp &gt; EPS; temp *= RATE) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != N; ++i)<br>        angle[i] = ans[i] + <span class="hljs-built_in">random</span>(rnd) * temp / <span class="hljs-number">100</span> * <span class="hljs-number">2</span> * PI;<br>      vec = <span class="hljs-built_in">calc</span>();<br>      <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">clen</span><span class="hljs-params">(cald(vec.first, vec.second))</span></span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(clen - tlen) &lt; <span class="hljs-built_in">abs</span>(nlen - tlen) ||<br>          <span class="hljs-built_in">rnd</span>() &lt; <span class="hljs-built_in">exp</span>((<span class="hljs-built_in">abs</span>(nlen - tlen) - <span class="hljs-built_in">abs</span>(clen - tlen)) * <span class="hljs-number">10000</span> / temp)) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) ans[i] = angle[i];<br>        nlen = clen;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(clen - tlen) &lt; <span class="hljs-built_in">abs</span>(dlen - tlen)) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) dans[i] = angle[i];<br>        dlen = clen;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) angle[i] = dans[i];<br>  <span class="hljs-function">pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">cur</span><span class="hljs-params">(calc())</span></span>;<br>  <span class="hljs-keyword">if</span> (tlen) angle[<span class="hljs-number">0</span>] = <span class="hljs-built_in">atan2</span>(ty, tx) - <span class="hljs-built_in">atan2</span>(cur.second, cur.first);<br>  <span class="hljs-keyword">else</span> angle[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != N; ++i) angle[i] += angle[<span class="hljs-number">0</span>];<br>  <span class="hljs-built_in">calc</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 2024 九月做题记录</title>
    <link href="/sol-2024sep/"/>
    <url>/sol-2024sep/</url>
    
    <content type="html"><![CDATA[<h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><p>Cplus。</p><ul><li>A：分析（<del>猜</del>）性质，分类讨论，计数，容斥。（明明可以 DP 却写了二项式反演。）</li><li>B：乱搞：二分、有理数逼近。正解：扫描线思想，在连续域上 DP：折线维护、凸包。<em>记得处理“空”的情况。</em></li><li>*C：线段树分治，太高了。</li></ul><h2 id="19"><a href="#19" class="headerlink" title="19"></a>19</h2><p>SWERC 2016（QOJ Contest 406/Codeforces Gym 101174），with 深海狂鲨 &amp; yukimianyan. 9 题，余 IJ 未场切。</p><h3 id="A-Within-Arm’s-Reach"><a href="#A-Within-Arm’s-Reach" class="headerlink" title="A Within Arm’s Reach"></a>A Within Arm’s Reach</h3><p>写了笨蛋的模拟退火。</p><ul><li>不要偷懒写差分数组，写绝对角度。</li><li>做修改时正负都要做。</li></ul><p>正解是发现两条臂可以解决很多状态，然后在对应的线段上二分，拿三角函数解出来就可以了。</p><h3 id="B-Briding-Eve"><a href="#B-Briding-Eve" class="headerlink" title="B Briding Eve"></a>B Briding Eve</h3><p>把每个点化成一次函数，找交点，分类讨论后离散化，做前缀加或后缀加，然后求全局最值。</p><h3 id="E-Passwords"><a href="#E-Passwords" class="headerlink" title="E Passwords"></a>E Passwords</h3><p>AC 自动机 DP 套路题。注意不要想当然地用差分统计……</p><h3 id="F-Performance-Review"><a href="#F-Performance-Review" class="headerlink" title="F Performance Review"></a>F Performance Review</h3><p>写了愚蠢的启发式合并。其实结合 dfs 序二维数点一下就可以了。</p><h3 id="G-Cairo-Corridor"><a href="#G-Cairo-Corridor" class="headerlink" title="G Cairo Corridor"></a>G Cairo Corridor</h3><p>队友写了线段树分治，来生成每个点被删的所有情况。事实上似乎可以缩二度点，然后讨论：</p><ul><li>只有至多 $4$ 个点度数为 $1$。</li><li>只有至多 $6$ 个点度数不小于 $3$。（？？？）</li></ul><h3 id="I-The-White-Rabbit-Pocket-Watch"><a href="#I-The-White-Rabbit-Pocket-Watch" class="headerlink" title="I The White Rabbit Pocket Watch"></a>I The White Rabbit Pocket Watch</h3><p>高斯消元后直接最短路即可。之所以没做出来是忽略了：“you’ll be able to find how long it takes you.”要读题。</p><h3 id="J-Risky-Lottery"><a href="#J-Risky-Lottery" class="headerlink" title="J Risky Lottery"></a>J Risky Lottery</h3><p>抽象迭代思维。</p><p>发现最终状态下，选每一个数字能赢的概率相同。否则，就有一个人可以改进自己的策略了（赌最大的概率）。</p><p>所以考虑迭代。每次算出每个数字能赢的概率，如果高于平均数就把选择它的概率调高，否则调低。</p><p>可是为啥退火跑不出来？不太懂。但是这个迭代……真是服了。</p><p>dfs 得写快点，不然跑不动。</p><h3 id="C-D-H-K"><a href="#C-D-H-K" class="headerlink" title="*C, D, H, K"></a>*C, D, H, K</h3><p>听说不难，不看了。</p><h3 id="Codeforces-1762D-GCD-Queries"><a href="#Codeforces-1762D-GCD-Queries" class="headerlink" title="Codeforces 1762D GCD Queries"></a>Codeforces 1762D GCD Queries</h3><p>直接考虑 $n=3$ 的情景。</p><h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><h3 id="Codeforces-1416E-Split"><a href="#Codeforces-1416E-Split" class="headerlink" title="Codeforces 1416E Split"></a>Codeforces 1416E Split</h3><p>扫描线 DP。DP 和 <code>set</code> 维护区间集有代码细节，留意负域。</p><h3 id="Luogu-P7831-CCO2021-Travelling-Merchant"><a href="#Luogu-P7831-CCO2021-Travelling-Merchant" class="headerlink" title="Luogu P7831 [CCO2021] Travelling Merchant"></a>Luogu P7831 [CCO2021] Travelling Merchant</h3><p>以终为始，从大到小转移。高妙图论。</p><h3 id="Luogu-P1587-NOI2016-循环之美"><a href="#Luogu-P1587-NOI2016-循环之美" class="headerlink" title="Luogu P1587 [NOI2016] 循环之美"></a>Luogu P1587 [NOI2016] 循环之美</h3><p>有序化简莫反，杜教筛。找到递归关系。一题多解哦。</p><h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><p>ZR NOIP 10 连 day 4。</p><h3 id="A-朔望"><a href="#A-朔望" class="headerlink" title="A 朔望"></a>A 朔望</h3><p>可以 <code>unsigned long long</code> 高精度。但是乘积的模等于模的乘积的模。</p><h3 id="B-随机"><a href="#B-随机" class="headerlink" title="B 随机"></a>B 随机</h3><p>欧拉回路构造。好像可以找规律。</p><h3 id="C-游走"><a href="#C-游走" class="headerlink" title="C 游走"></a>C 游走</h3><p>简单数数。树边要开两倍！！！。</p><h3 id="D-网络"><a href="#D-网络" class="headerlink" title="*D 网络"></a>*D 网络</h3><p>结论是：重心必然在 dfs 序的中心往上跳的路径上（带权就是带权中心）。其实就是发现向下跳会做，但是不好维护，所以觉得在树上就应该向上跳。但是 dfs 序应用太神秘。</p><p>然后想要查询联通块内每个点到定点的距离。这里用容斥的想法，是全部点到它的距离减去联通块以外的到它的距离，然后子树内的逐个处理有可接受的均摊。</p><p>怎么线段树分治 $\log^2$ 跑不过 $2\times 10^5$ 呢？</p><h3 id="QOJ-8781-Element-Wise-Comparison"><a href="#QOJ-8781-Element-Wise-Comparison" class="headerlink" title="QOJ 8781 Element-Wise Comparison"></a>QOJ 8781 Element-Wise Comparison</h3><p>非常高妙的 <code>bitset</code> 使用。考虑拆解条件，发现是若干个条件的与，然后找到相同的下标，在题意下可以做不带删双指针（即尺取）。</p><h2 id="22"><a href="#22" class="headerlink" title="22"></a>22</h2><p>ARC 184。</p><h3 id="A-Appraiser"><a href="#A-Appraiser" class="headerlink" title="A Appraiser"></a>A Appraiser</h3><p>交互。提取“相同”的优势。</p><h3 id="B-C-D-E"><a href="#B-C-D-E" class="headerlink" title="*B, C, D, E"></a>*B, C, D, E</h3><p>全部不会。菜。B 是：状压 DP，但是赛场上失败，以为可以构造呢。</p><h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><p>Cplus。A：单元答案使用二分，但是可以暴力枚举；B：简单数概率，但是不要想当然暴力；C：晦涩的贪心使用，构造，小心正负边界；D：线段树题，不要忘记 $-1$。</p><h3 id="Luogu-P3266-JLOI2015-骗我呢"><a href="#Luogu-P3266-JLOI2015-骗我呢" class="headerlink" title="Luogu P3266 [JLOI2015] 骗我呢"></a>Luogu P3266 [JLOI2015] 骗我呢</h3><p>关键是注意到格路计数。看到范围扭曲的简单 DP 式考虑。然后反射容斥，记得输入不要写反。</p><h3 id="Luogu-P5068-Ynoi2015-我回来了"><a href="#Luogu-P5068-Ynoi2015-我回来了" class="headerlink" title="Luogu P5068 [Ynoi2015] 我回来了"></a>Luogu P5068 [Ynoi2015] 我回来了</h3><p>调和级数暴力，主客转换，对线段树每个节点做一个 <code>vector</code> 作为 tag。写了快读要用。</p><h3 id="Luogu-P4690-Ynoi2016-镜中的昆虫"><a href="#Luogu-P4690-Ynoi2016-镜中的昆虫" class="headerlink" title="Luogu P4690 [Ynoi2016] 镜中的昆虫"></a>Luogu P4690 [Ynoi2016] 镜中的昆虫</h3><p>元素种类数转 <code>(pre[i],i)</code> 的数点。CDQ 分治。读好题目范围，不要写着 $10^9$ 开了 $10^5$。</p><h3 id="Codeforces-1458E-Nim-Shortcuts-1866I-Imagination-Castle"><a href="#Codeforces-1458E-Nim-Shortcuts-1866I-Imagination-Castle" class="headerlink" title="Codeforces 1458E Nim Shortcuts / 1866I Imagination Castle"></a>Codeforces 1458E Nim Shortcuts / 1866I Imagination Castle</h3><p>模拟 DP/nim 游戏。好诡异的 <code>set</code> 使用。</p><p>另外的规划：发现很多时候主要是计数（包括动态规划）、数据结构和树会出的比较难，所以主要是这两个方面。字符串，不好说会不会考，但要做几个题。至于写挂的情况，感觉是大脑要清楚，逻辑要完整，然后可以自信点放松点，找找状态看吧。蔡队是补题怪物吧……</p><h2 id="24"><a href="#24" class="headerlink" title="24"></a>24</h2><p>Zhengrui，省选难度，严重挂分，被 T2 拖后腿。</p><h3 id="A-1410-超简单题"><a href="#A-1410-超简单题" class="headerlink" title="A 1410 超简单题"></a>A 1410 超简单题</h3><p>子序列自动机，DAG 上类重剖。</p><p>记得开 <code>long long</code>！！</p><h3 id="B-1411-更简单题"><a href="#B-1411-更简单题" class="headerlink" title="B 1411 更简单题"></a>B 1411 更简单题</h3><p>读题（这题面并不好）。发现想要做很多次循环卷积（那就老老实实尝试去做啊），既然浮点数：猜测概率会越来越均匀（或分块），减免操作。</p><p>能写 TLE 不要写没有道理的 WA，比如省去高次项。阴间题不能太耗时间。</p><h3 id="C-1412-最简单题"><a href="#C-1412-最简单题" class="headerlink" title="C 1412 最简单题"></a>C 1412 最简单题</h3><p>猜测结论/化简条件，拟阵贪心（其实就是感觉它非常贪心，然后看能不能类最小生成树算法）。</p><p>贪心学艺不精。好题好题，可看可看。</p><h3 id="Codeforces-1987E-Wonderful-Tree"><a href="#Codeforces-1987E-Wonderful-Tree" class="headerlink" title="Codeforces 1987E Wonderful Tree"></a>Codeforces 1987E Wonderful Tree</h3><p>简单题。贪心，递推。</p><h3 id="Codeforces-1548B-Integers-Have-Friends"><a href="#Codeforces-1548B-Integers-Have-Friends" class="headerlink" title="Codeforces 1548B Integers Have Friends"></a>Codeforces 1548B Integers Have Friends</h3><p>尺取记得清空问题。（也可以 Sparse Table 二分。）</p><h3 id="Codeforces-1495E-Qingshan-and-Daniel"><a href="#Codeforces-1495E-Qingshan-and-Daniel" class="headerlink" title="Codeforces 1495E Qingshan and Daniel"></a>Codeforces 1495E Qingshan and Daniel</h3><p>很有意思的如简单题。分析性质，发现有一边会全部死掉，然后顺下来一个一个耗即可。</p><h2 id="25"><a href="#25" class="headerlink" title="25"></a>25</h2><p>Cplus，也是 Becoder 公益赛，NOIP 难度，T3 想挂了，没对拍但稳定性尚可，所以可能要经常打比赛才有感觉。</p><h3 id="A-多线并行（multi）"><a href="#A-多线并行（multi）" class="headerlink" title="A 多线并行（multi）"></a>A 多线并行（multi）</h3><p>简明的贪心。</p><h3 id="B-空当接球（ball）-QOJ-1963-Squid-Game-大力加强"><a href="#B-空当接球（ball）-QOJ-1963-Squid-Game-大力加强" class="headerlink" title="B 空当接球（ball）/ QOJ 1963 Squid Game 大力加强"></a>B 空当接球（ball）/ QOJ 1963 Squid Game 大力加强</h3><p>非常神秘的构造题，好题好题。致敬喵了个喵。</p><p>首先由奇偶性想到二进制，想要把最低位往上推，但是这样要做非常多次（$O(n\log nm)$）。感觉非常宽松，然后由二进制要想到 01 Trie！加（减）运算由低到高位的 01 Trie 维护，然后做一点自底向上的贪心最低匹配（AGC018F）。然后就对了，嗯嗯（你发现势能增长飞快，复杂度几乎线性）。</p><p>然后发现化简完后还不够小，不能满足题目条件，还有 $O(\log nm)$ 个数，超过了 $2$ 个。所以必须跳出二进制的框架。考虑把最小值一直变小（怎么想到的？），能稳定实现这个的运算是模运算，所以尝试构造一下模运算的写法，那就非常好了。</p><h3 id="C-列序号括（bracket）"><a href="#C-列序号括（bracket）" class="headerlink" title="C 列序号括（bracket）"></a>C 列序号括（bracket）</h3><p>冷知识，两只 $\log$ 可以通过 $10^6$，跑得也很快。好的好的。</p><p>题解做法：既然是括号序列题，一般从内括号到外括号有单调的决策，所以发现外括号删里面必全删。以为从括号序列变为树，结果发现就是要在序列上面做（？）。从后往前，倍增维护。</p><p>其实，用树分析到单调栈的结构就可以倒着做，尝试加入大还是不加入大，更为简易呢。但是要讨论最后没有不合法右括号的后缀，容易想挂。</p><h3 id="D-可爱路径（path）-QOJ-5034-gt-lt"><a href="#D-可爱路径（path）-QOJ-5034-gt-lt" class="headerlink" title="*D 可爱路径（path）/ QOJ 5034 &gt;.&lt;"></a>*D 可爱路径（path）/ QOJ 5034 &gt;.&lt;</h3><p>最短路套 AC 自动机。但是发现一个出边会被走很多次，所以发现其实不用走很多次：就是有一些边大家都会走，发现大家都会走的边就是不考虑其他前缀后走的边，然后这些边只走一遍就可以了。大概分析一下，发现怎么写都是对的，吧（就是，你即便以后的支线有效边都不要也没关系，反正边长不变）。非常好的优化思维。</p><p>等等，被 hack 了？？</p><h3 id="Kilonova-2797-Triunghi"><a href="#Kilonova-2797-Triunghi" class="headerlink" title="Kilonova 2797 Triunghi"></a>Kilonova 2797 Triunghi</h3><p>等腰直角三角形转分治，对这种类滑动窗口但是不好删的询问做一下尺取。</p><p>如果不要 $\log$，按照 $k\times k$ 分成矩阵块，所谓“关键点”，然后针对斜线预处理就可以，感觉精细的。</p><h2 id="26"><a href="#26" class="headerlink" title="26"></a>26</h2><p>Zhengrui，毛营，打得不太舒服。B 题在结束前 5min 发现读错题，说明做打比赛程序上还是要先把题目都仔细看一遍。</p><h3 id="A-Easy-Win"><a href="#A-Easy-Win" class="headerlink" title="A Easy Win"></a>A Easy Win</h3><p>用 SG 函数把要求的转化为 $\oplus (a_i \bmod x)$，转成 $a_i-x\lfloor\frac{a_i}{x}\rfloor$，猜想调和计数枚举每个区间，至此都是简单的。</p><p>想要做区间查询 $a_i-x$ 的异或和。并不好做，所以由 $\oplus$ 想到每位的独立性，逐位枚举。观察在值域线段上，对于一个 $x$，$y-x$ 在第 $d$ 位上的分布是以 $2^d$ 为周期的纹路，所以可以用这种纹路做前缀和，然后特殊地处理边界。实在是想象学。</p><h3 id="B-Cells-Blocking"><a href="#B-Cells-Blocking" class="headerlink" title="B Cells Blocking"></a>B Cells Blocking</h3><p>无路可走，首先猜想和割点有关。接下来的步骤就比较想象学。顺便有一个基本原则：从左上到右下的路径长为 $n+m-1$。</p><p>考虑极左下和极右上的两条路径（下文命名为 $L$ 和 $R$），可以发现所有可能的路径都被夹在中间。所以割点是这两条路的交。要割两个点。首先至少有一个在 $L$ 上（其实对任意一条合法路径都符合，但是这么钦定比较方便找另一个点），枚举这一个，命名为 $P$。$P$ 为割点的情况简易处理，只讨论 $P$ 非割点。然后在新图找新的 $L$（$R$ 是没变），然后继续做割一个点的情形。现在的焦点来到如何快速找到新的 $L$ 和 $R$ 的交。</p><p>既然 $P$ 被 ban，当走到 $P$ 的这个步数，就要走到另一个合法的点 $P’$，其余的都没有关系。处理出对于每个点作为 $P’$ 时的答案，然后就只要找出 $P’$ 即可。既然是第二左下，那就刚好是同步数的斜线上 $P$ 的后继。</p><h3 id="C-Giant-Penguin"><a href="#C-Giant-Penguin" class="headerlink" title="C Giant Penguin"></a>C Giant Penguin</h3><p>当换根、深度这些要素感觉到，就要考虑点分治，这个没啥问题。（感觉英文译名更符合其实质呢，centroid decomposition。）</p><p>对于非树边，强行把与之相关的 $k$ 个点拎出来（取任意一端即可），这样子如果要跨越子树，要么经过重心，要么经过特殊点。</p><p>预处理就是把特殊点和重心拿出来都跑 BFS。带修就是上点分树在特殊点和重心上更新。</p><p>魔改点分治。实质是：把图剖成几个子图，把跨越的拎出来（好像更像猫树分治），发现总是经过有限个关键点。</p><p>写代码上，一个是不要写错求重心，一个是可以多用给子树染色的办法判定对面的点是否在当前子树内，防止奇怪的事情发生。</p><h2 id="27"><a href="#27" class="headerlink" title="27"></a>27</h2><h3 id="Luogu-P3295-SCOI2016-萌萌哒"><a href="#Luogu-P3295-SCOI2016-萌萌哒" class="headerlink" title="Luogu P3295 [SCOI2016] 萌萌哒"></a>Luogu P3295 [SCOI2016] 萌萌哒</h3><p>神题。</p><p>并查集是容易想到的。直接逐位合并并查集复杂度很高，但是询问次数却很少。所以考虑把大区间拆成一些子区间的与，最后要回答询问时再集体 pushdown。这里其实用 Sparse Table 即可，线段树不好做。那也有另外一个视角就是用倍增理解这个过程。</p><h3 id="ZR-2925-逆序对-inversion"><a href="#ZR-2925-逆序对-inversion" class="headerlink" title="ZR 2925 逆序对(inversion)"></a>ZR 2925 逆序对(inversion)</h3><p>非常好 Bijection Proof。</p><p>写了题解。</p><h2 id="28"><a href="#28" class="headerlink" title="28"></a>28</h2><p>Cplus 联测。</p><h3 id="A-a"><a href="#A-a" class="headerlink" title="A a"></a>A a</h3><p>题目名字就是这个，我能怎么办。</p><p>手推，感觉到有简单规律，做完。</p><h3 id="B-b"><a href="#B-b" class="headerlink" title="B b"></a>B b</h3><p>模拟 DP，发现变化量不大。注意 <code>-INF</code>。</p><h3 id="C-c-Codeforces-407D-Largest-Submatrix-3"><a href="#C-c-Codeforces-407D-Largest-Submatrix-3" class="headerlink" title="*C c / Codeforces 407D Largest Submatrix 3"></a>*C c / Codeforces 407D Largest Submatrix 3</h3><p>看到矩形，三次方复杂度，想到枚举三条边。然后就有大力递推，就是从三维的邻项推过来（但是可以非常牛地压到只有两维数组）。（？？？妈呀。可能就是，你感觉东西非常多，不容易直接算，而且可复用，所以想要递推。）</p><p>但是我们三次方数组被卡真是太厉害了。感觉是，有序枚举，要会。这不是我们，CSP-S 2022 T1？怎么我现在不会这种题。</p><p>C 可能小于 B，呃呃。</p><h3 id="D-d-ARC118E-Avoid-Permutations"><a href="#D-d-ARC118E-Avoid-Permutations" class="headerlink" title="D d / ARC118E Avoid Permutations"></a>D d / ARC118E Avoid Permutations</h3><p>对于严格的“一个都没有”限制，考虑容斥。大小为 $n$ 的子集系数为 $(-1)^{n}$，在 DP 中做这个转移。</p><p>我们容斥。</p><p>写了题解。</p><h2 id="29"><a href="#29" class="headerlink" title="29"></a>29</h2><p>Cplus 省选难度，打的很顺利。</p><p>AGC 068，一道题都不会。</p><h3 id="A-铲雪"><a href="#A-铲雪" class="headerlink" title="A 铲雪"></a>A 铲雪</h3><p>我们 $998244353$ 能做 NTT 模数，性质太好了。费马小定理，然后直接线段树和树状数组维护。</p><h3 id="B-抽卡"><a href="#B-抽卡" class="headerlink" title="B 抽卡"></a>B 抽卡</h3><p>DP，关于状态的互推：迭代 60 次即可。不过精准高效的做法是按值域分段，然后解方程。</p><h3 id="C-樟-Aizu-2993-Invariant-Tree"><a href="#C-樟-Aizu-2993-Invariant-Tree" class="headerlink" title="C 樟 / Aizu 2993 Invariant Tree"></a>C 樟 / Aizu 2993 Invariant Tree</h3><p>非常好 prufer 序列数数。</p><p>写了题解。</p><h2 id="30"><a href="#30" class="headerlink" title="30"></a>30</h2><p>Cplus 联测，打得不太好。</p><h3 id="A-人机识别（iamhuman）"><a href="#A-人机识别（iamhuman）" class="headerlink" title="A 人机识别（iamhuman）"></a>A 人机识别（iamhuman）</h3><p>简单构造，由 $\log$ 函数的凸性即可。还没想更深入的思考，关于出现循环的字符串。</p><h3 id="B-字符画（picture）"><a href="#B-字符画（picture）" class="headerlink" title="*B 字符画（picture）"></a>*B 字符画（picture）</h3><p>灵感大王图形构造。对于 $n=300$ 要特殊的图形。</p><h3 id="C-能量（energy）"><a href="#C-能量（energy）" class="headerlink" title="*C 能量（energy）"></a>*C 能量（energy）</h3><p>还未仔细研究，大体是维护 DP，寻找凸性。</p><h3 id="D-最小生成树（mst）"><a href="#D-最小生成树（mst）" class="headerlink" title="*D 最小生成树（mst）"></a>*D 最小生成树（mst）</h3><p>从最小生成树到 Kruskal 重构树，在其上动态 DP 即可。这个东西可以被认为是树的“等效链”。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces 1310D Tourism</title>
    <link href="/sol-CF1310D/"/>
    <url>/sol-CF1310D/</url>
    
    <content type="html"><![CDATA[<p>如果像我一样没有注意到二分图，也完全不会随机化，那该怎么办？</p><h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>给一图，求经过点 $1$、点数为 $k$、不含奇环、可以重复经过点和边的边权和最小环路。$n\le 80$，$k\le 10$ 且 $k$ 为偶数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们首先考虑 meet in the middle，枚举除了点 $1$ 以外的前 $k/2-1$ 个点和后 $k/2-1$ 个点，进行搜索。最后再枚举中间三个点来合并。然后你发现会直接 TLE，如果像我一样实现常数巨大。</p><p>对两个部分分别优化：</p><ul><li>对于搜索中的 TLE，发现很多边是不优的，所以选择前若干小出边 DFS，本人使用 $37$，只是因为它刚好通过了。</li><li>对于合并中的 TLE，发现端点处存储的答案太多了，所以对每个端点只保留前若干小方案，本人使用 $3$。</li></ul><p>然后你发现 WA on test 129。打开发现它形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">0 100 100 100 100...<br>100 0 100...<br></code></pre></td></tr></table></figure><p>也就是说有很多同类点，导致前几小的策略容易被迷惑。</p><p>所以考虑删去同质点。对于一个点 $p$，如果存在另外至少 $2$ 个点 $q_1,q_2$，使得不考虑 $p,q$ 之间的连边，$p,q$ 向外的连边完全相同，那么把 $p$ 删去。（之所以要保留两个，是因为可以来回走，可能是优的。）</p><p>然后就通过了……\qiao。</p><p>可能是可以 hack 的，但是感觉 hack 也太累了吧。</p><p>代码实现上，感觉把这道题抬到了一个不属于它的高度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">85</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> LIM = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> CH = <span class="hljs-number">37</span>;<br><span class="hljs-type">int</span> N, K, val[MXN][MXN], <span class="hljs-built_in">ans</span>(<span class="hljs-number">2e9</span>);<br><span class="hljs-type">bool</span> disabled[MXN];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; choice1[MXN], choice2[MXN];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; mp1[MXN], mp2[MXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> p, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == K / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) &#123;<br>    mp1[p].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(len, path));<br>    <span class="hljs-keyword">if</span> (mp1[p].<span class="hljs-built_in">size</span>() &gt; LIM) mp1[p].<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">max_element</span>(mp1[p].<span class="hljs-built_in">begin</span>(), mp1[p].<span class="hljs-built_in">end</span>()));<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != <span class="hljs-built_in">min</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(choice1[p].<span class="hljs-built_in">size</span>()), CH); ++i) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">q</span><span class="hljs-params">(choice1[p][i].second)</span></span>;<br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">3</span> &amp;&amp; q == path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>]) <span class="hljs-keyword">continue</span>;<br>    path.<span class="hljs-built_in">push_back</span>(q);<br>    <span class="hljs-built_in">dfs1</span>(q, path, len + val[p][q]);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == K / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) &#123;<br>    mp2[p].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(len, path));<br>    <span class="hljs-keyword">if</span> (mp2[p].<span class="hljs-built_in">size</span>() &gt; LIM) mp2[p].<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">max_element</span>(mp2[p].<span class="hljs-built_in">begin</span>(), mp2[p].<span class="hljs-built_in">end</span>()));<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != <span class="hljs-built_in">min</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(choice2[p].<span class="hljs-built_in">size</span>()), CH); ++i) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">q</span><span class="hljs-params">(choice2[p][i].second)</span></span>;<br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">3</span> &amp;&amp; q == path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>]) <span class="hljs-keyword">continue</span>;<br>    path.<span class="hljs-built_in">push_back</span>(q);<br>    <span class="hljs-built_in">dfs2</span>(q, path, len + val[q][p]);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">illegal</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; path)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt; path.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != path.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>      <span class="hljs-keyword">if</span> (path[(j + i) % path.<span class="hljs-built_in">size</span>()] == path[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N &gt;&gt; K;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != N; ++j) cin &gt;&gt; val[i][j];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != N; ++i) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">1</span>); j != i; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (disabled[j]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">0</span>); k != N; ++k)<br>        <span class="hljs-keyword">if</span> (k != i &amp;&amp; k != j &amp;&amp; (val[k][i] != val[k][j] || val[i][k] != val[j][k]))<br>          same = <span class="hljs-literal">false</span>;<br>      cnt += same;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt &gt;= <span class="hljs-number">2</span>) disabled[i] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (disabled[i]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != N; ++j)<br>      <span class="hljs-keyword">if</span> (j != i &amp;&amp; !disabled[j])<br>        choice1[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(val[i][j], j)),<br>        choice2[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(val[j][i], j));<br>    <span class="hljs-built_in">sort</span>(choice1[i].<span class="hljs-built_in">begin</span>(), choice1[i].<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(choice2[i].<span class="hljs-built_in">begin</span>(), choice2[i].<span class="hljs-built_in">end</span>());<br>  &#125;<br>  vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>  <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">0</span>, tmp, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">0</span>, tmp, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != N; ++j) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>); a != mp1[i].<span class="hljs-built_in">size</span>(); ++a) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">b</span>(<span class="hljs-number">0</span>); b != mp2[j].<span class="hljs-built_in">size</span>(); ++b) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">0</span>); k != N; ++k) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">path</span><span class="hljs-params">(mp1[i][a].second)</span></span>;<br>            path.<span class="hljs-built_in">push_back</span>(k);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">d</span>(K / <span class="hljs-number">2</span> - <span class="hljs-number">2</span>); ~d; --d) path.<span class="hljs-built_in">push_back</span>(mp2[j][b].second[d]);<br>            path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">illegal</span>(path)) &#123;<br>              ans = <span class="hljs-built_in">min</span>(ans, mp1[i][a].first + val[i][k] + val[k][j] + mp2[j][b].first);<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索</tag>
      
      <tag>折半搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces 1468A LaIS</title>
    <link href="/sol-CF1468A/"/>
    <url>/sol-CF1468A/</url>
    
    <content type="html"><![CDATA[<p>另一个好想好写的做法，看题解区还没有就来一发。</p><h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>给定数列 $a<em>1,\ldots,a_n$，要求找到最长的子序列 $b_1,\ldots,b_m(m\ge 2)$ 满足 $\forall 1\le k\le m-2,\min(b_k,b</em>{k+1})\le \min(b<em>{k+1},b</em>{k+2})$。$1\le a_i\le n$，$\sum n\le 5\times 10^5$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>经典思路是考虑动态规划，令 $f_i$ 为以第 $i$ 位为结尾的最大合法子序列长度。</p><p>假设 $i$ 的前驱是 $j$：</p><ul><li>$a_j\le a_i$ 则总是满足条件，直接用 $f_j+1$ 向 $f_i$ 贡献，从左往右扫的时候实时维护前缀 $\max$。</li><li>$a_j &gt; a_i$：令 $j$ 的前驱为 $k$，则 $\min(a_k, a_j)\le \min(a_j, a_i)$，即 $a_k\le a_i$。那就让 $j$ 越靠右越优。用单调栈找到每个 $i$ 对应的最靠右的 $j$ 满足 $a_j&gt;a_i$，在 $j$ 处查询前缀 $\max$ 即可。</li></ul><p>这里的前缀 $\max$ 就是：维护 $g_i$ 为以 $i$ 的值为结尾的最大 $f$ 值，这里的转移就是 $g$ 数组的前缀求 $\max$。不减地单点修改，求前缀 $\max$，可以用树状数组实现。时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>实现时重复计入了 $a_j=a_i$ 的贡献，显然没关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">500005</span>;<br><span class="hljs-type">int</span> T, N, arr[MXN], stk[MXN], top, val1[MXN], mxv[MXN], ans;<br>vector&lt;<span class="hljs-type">int</span>&gt; task[MXN];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">while</span> (p) v = <span class="hljs-built_in">max</span>(v, mxv[p]), p -= p &amp; -p;<br>  <span class="hljs-keyword">return</span> v;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setv</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (p &lt;= N) mxv[p] = <span class="hljs-built_in">max</span>(mxv[p], v), p += p &amp; -p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  cin &gt;&gt; T;<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    cin &gt;&gt; N;<br>    top = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>      cin &gt;&gt; arr[i];<br>      task[i].<span class="hljs-built_in">clear</span>();<br>      val1[i] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (~top &amp;&amp; arr[stk[top]] &lt; arr[i]) --top;<br>      <span class="hljs-keyword">if</span> (~top) task[stk[top]].<span class="hljs-built_in">push_back</span>(i);<br>      stk[++top] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) mxv[i] = <span class="hljs-number">0</span>;<br>    ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>      ans = <span class="hljs-built_in">max</span>(ans, val1[i] = <span class="hljs-built_in">max</span>(val1[i], <span class="hljs-built_in">query</span>(arr[i]) + <span class="hljs-number">1</span>));<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : task[i]) &#123;<br>        val1[j] = <span class="hljs-built_in">max</span>(val1[j], <span class="hljs-built_in">query</span>(arr[j]) + <span class="hljs-number">2</span>);<br>      &#125;<br>      <span class="hljs-built_in">setv</span>(arr[i], val1[i]);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Luogu P8256 [NOI Online 2022 入门组] 字符串</title>
    <link href="/sol-LGP8256/"/>
    <url>/sol-LGP8256/</url>
    
    <content type="html"><![CDATA[<p>NOI 数据太水。</p><h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>给定操作序列 $S$ 和字符串 $T$。考虑这样的过程：维护一个初始为空的字符串 $R$，依次执行 $S$ 中的操作：若为 <code>0</code> 或 <code>1</code> 则在 $R$ 末尾加入此字符，否则为 <code>-</code> 就删去 $R$ 开头或末尾字符。求有多少种不同的方案，使得最终 $R$ 与 $T$ 相同。两方案不同当且仅当一次删除操作的方向不同。$|S|,|T|\le 400$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>正向考虑这一过程，会首先想到维护字符串本身，再想办法刻画它与 $T$ 匹配的情形。感觉不简单，所以考虑反向操作。整个过程就变成：要对 $T$ 进行操作，让它最后为空。</p><p>于是发现删除操作会变成在头或尾加入一个任意字符，令它为 <code>X</code>。原先的 <code>0</code> 操作会变成删除末尾的 <code>X</code> 或 <code>0</code>，<code>1</code> 操作会变成删除末尾的 <code>X</code> 或 <code>1</code>。由于现在的删除只在末尾操作，发现不为 <code>X</code> 的部分必然为 $T$ 的一个前缀（可以为空）。所以当前字符串的状态就更易于刻画。</p><p>考虑动态规划计数。令 $f_{i,j,k}$ 表示做完了（正向）第 $i$ 次及其往后的操作，当前字符串开头有 $j$ 个 <code>X</code>，紧接着是 $T$ 的长度为 $k$ 的前缀。总长度可以预处理为 $l_i$，故末尾的 <code>X</code> 数量为 $l_i-j-k$。</p><p>初始状态：$f_{n,0,m}=1$。</p><p>对于 <code>-</code> 操作，前后各转移一次：</p><script type="math/tex; mode=display">f_{i-1,j,k}:=f_{i-1,j,k}+f_{i,j,k}</script><script type="math/tex; mode=display">f_{i-1,j+1,k}:=f_{i-1,j+1,k}+f_{i,j,k}</script><p>对于 <code>0</code>/<code>1</code> 操作：</p><p>当 $j+k\neq l_i$ 时，删除末尾的 <code>X</code>：</p><script type="math/tex; mode=display">f_{i-1,j,k}:=f_{i-1,j,k}+f_{i,j,k}</script><p>否则在末字符匹配得上的条件下：</p><script type="math/tex; mode=display">f_{i-1,j,k-1}:=f_{i-1,j,k-1}+f_{i,j,k}</script><p>一个在状态设计上的细节：对于 $k=0$ 的时候最好只转移一个 $j$，避免出现尴尬情况。以下钦定 $k=0$ 时 $j=0$。答案就是 $f_{0,0,0}$。</p><p>时间复杂度 $O(tn^2m)$，空间上可以使用滚动数组做到 $O(nm)$，这样做也极大优化了时间常数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">405</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DVS = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> T, N, M, len[MXN], cnt[<span class="hljs-number">2</span>][MXN][MXN];<br><span class="hljs-type">char</span> ops[MXN], pat[MXN];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> ((x += y) &gt;= DVS) x -= DVS;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  cin &gt;&gt; T;<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    cin &gt;&gt; N &gt;&gt; M &gt;&gt; ops &gt;&gt; pat;<br>    len[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i)<br>      len[i + <span class="hljs-number">1</span>] = len[i] + (ops[i] == <span class="hljs-string">&#x27;-&#x27;</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (len[N] != M) &#123;<br>      cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(cnt[N &amp; <span class="hljs-number">1</span>], <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> cnt[N &amp; <span class="hljs-number">1</span>]);<br>    cnt[N &amp; <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][M] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(N); i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>      <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ii</span><span class="hljs-params">(i &amp; <span class="hljs-number">1</span>)</span></span>;<br>      <span class="hljs-built_in">memset</span>(cnt[!ii], <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> cnt[!ii]);<br>      <span class="hljs-keyword">if</span> (ops[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j &lt; len[i]; ++j) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">1</span>); j + k &lt;= len[i]; ++k) &#123;<br>            <span class="hljs-built_in">add</span>(cnt[!ii][j + <span class="hljs-number">1</span>][k], cnt[ii][j][k]);<br>            <span class="hljs-built_in">add</span>(cnt[!ii][j][k], cnt[ii][j][k]);<br>          &#125;<br>        &#125;<br>        <span class="hljs-built_in">add</span>(cnt[!ii][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], cnt[ii][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">add</span>(cnt[!ii][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], cnt[ii][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j &lt; len[i]; ++j) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">1</span>); j + k &lt; len[i]; ++k) &#123;<br>            <span class="hljs-built_in">add</span>(cnt[!ii][j][k], cnt[ii][j][k]);<br>          &#125;<br>          <span class="hljs-keyword">if</span> (pat[len[i] - j - <span class="hljs-number">1</span>] == ops[i - <span class="hljs-number">1</span>])<br>            <span class="hljs-built_in">add</span>(cnt[!ii][len[i] - j - <span class="hljs-number">1</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : j][len[i] - j - <span class="hljs-number">1</span>],<br>                cnt[ii][j][len[i] - j]);<br>        &#125;<br>        <span class="hljs-built_in">add</span>(cnt[!ii][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], cnt[ii][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; cnt[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鲜花 - 空调</title>
    <link href="/flower-air-conditioner/"/>
    <url>/flower-air-conditioner/</url>
    
    <content type="html"><![CDATA[<p>这是写于八年级为了给作文集凑数的一篇，想来很有鲜花性质，也很有我这种烦于琐事、且有隐晦的暗喻的风格，觉得可以一发。</p><hr><p>我戴帽子睡觉。</p><p>卧室的空调太冷了，即使开了最高的 30 度风依然很冷。夜晚躺在床上，空调吹出的邪风便在狭窄的床铺上耀武扬威，潜游进我的薄薄的被窝里，还要从墙壁上反弹，冲向我的天灵盖。我尽量克制自己的发抖，不断告诉自己被窝是暖和的，被窝是暖和的，被窝是暖和的。但更烦人的是，风不依不饶地向我的头顶直接袭来，仿佛就渗透进我的大脑，让我头痛欲裂。然而卧室不止我一个人，不能轻易就关掉空调。我多想让我的头顶也反弹风啊！我把头往上一拱，哎哟，撞到墙了，只好作罢。</p><p>起初我并不是很敏感。但是有连续几天，我醒来之后都感觉头像结了霜一样，粘粘乎乎的，以为自己在家里呆发霉了，还能感冒发烧，或是枕头不干净之类的原因。后来渐渐意识到空调风的卑鄙，在一个晚上终于忍无可忍，一拍床垫，揽起自己的枕头和一条小被子，就去客厅。这觉，哼，谁爱睡谁睡！</p><p>广州还是很热的，但是我晚上睡觉是不怕热的。许久没有在客厅沙发上睡觉过，还有点兴奋，稍晚才入睡。第二天也的确可以按时清醒。动动身子，一看手上、腿上，都是蚊子叮的包，还三两成群呢。其实也不会真的痒，就是自己看见，心痒痒。按理说晚上也有喷空气清新剂一类的，想大概蚊子是难驱的，好像也有点懒得费心，便又作罢。</p><p>最终的解决方案就是：戴帽子睡。其实头依然有一点不舒服，风还是会渗进来一点，但总比原来强的多。至少风要冲，对着的是帽子，不是我。</p>]]></content>
    
    
    <categories>
      
      <category>鲜花</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鲜花 - 跑圈</title>
    <link href="/flower-run/"/>
    <url>/flower-run/</url>
    
    <content type="html"><![CDATA[<p>我去跑了圈。</p><p>为什么要跑圈？</p><p>因为我已经很多天没有做体育锻炼了，身体感觉不太舒服。</p><p>为什么要跑圈？</p><p>因为我今天挂了 70 分，由于写错变量名的缘故。所以我要跑个 700 米，让自己记住一下这个事情。</p><p>为什么要跑圈？</p><p>因为我听说跑步可以缓解一些问题，而今天刚知道这里的操场，所以想去尝个新。</p><p>是我想去跑圈吗？</p><p>也许是吧，你看跑圈能辅助我的 OI 训练。</p><p>我想去跑圈吗？</p><p>好久没跑了，再跑 700 米还跑得过这里的大学生呢，只是不久便累下来了，满身大汗。回头看他始终跑着呢，不知道已几圈了。</p><p>我想去跑圈吗？</p><p>我的时间因此耗费了一些呢。不过也没什么别人会受影响，这大概是一种自由，是一种便利。</p><p>我还会跑圈吗？</p><p>跑圈过后感觉神清气爽了，睡觉也睡得很香，增强了对东西的触感，眼睛也看得清楚了些。</p><p>我还会跑圈吗？</p><p>跑圈也许还有点累呢，也许不能带来什么呢，还很孤单呢。场地也不近，不是因为帽子落下了也不会偶然去的吧。</p><p>我还会跑圈吗？</p><p>不知道，我想要跑圈的时候就会跑，不想的时候可能不会吧。</p><hr><p>写于 2024.7.20.</p><p>可认为是 EVA 观后感之一。</p>]]></content>
    
    
    <categories>
      
      <category>鲜花</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - 初中</title>
    <link href="/rec-junior-high-school/"/>
    <url>/rec-junior-high-school/</url>
    
    <content type="html"><![CDATA[<p>这似乎还是向<a href="https://www.luogu.com.cn/user/288716">学长</a><a href="https://www.luogu.com/article/65qwen88">致敬</a>的一作，似乎也受<a href="https://www.luogu.com/article/cgfn8i0u">一位同辈的文章</a>的鼓舞。不过如果是三年 OI 一场空，我大概要在初二暑假写下这篇。</p><p>从这篇文章的性质来看，我似乎只要把自己的记忆流水下来即可了；从这篇文章的目的来看，我似乎是由于模拟考发现自己的作文素材极少，故发觉作这篇之重要性，故在中考前的最后一个和平的周末作下此篇。写时还害怕难覆盖全面，回看发现却是虚度三年，似乎没有很值得骄傲的大进步，不过是琐记。</p><p>开始吧。</p><h2 id="Year-1"><a href="#Year-1" class="headerlink" title="Year -1"></a>Year -1</h2><p><em>2020-2021.</em></p><p>这一段日子是开始之前的开始，命运的麻绳从这里开始缠绕。</p><p>我已经不知道究竟是从 lzoi.cn 和 oiclass.com 的哪个开始。并且以低预期首先排除了 gdgzez。oiclass 还会开一些线下课。从语法基础到 DP 训练营，从卢老师到陈老师再到林老师，从越秀到番禺。这个 DP 训练营似乎很值得写一写，四个专题我几乎都没听懂，每天只能做六道题中的前两三道。然而在模拟赛中，我却以每一题得分均在 $(0,100)$ 的战绩拿下除了出题人以外的 rk 1，我似乎从这里开始相信自己是有一些适合学习 OI 的特质的，转念想想很强的人都去了 gdgzez 或其他，可能也不算什么（这样的情景后来也不时发生）。即使这样也被卢老师痛批，没有一个人 AC 还好意思说笑。这个老师也挺有意思的，很努力的讲课；此外好像他在这里唱了歌，然而却可惜地没听见；撕餐票时他还煞有介事地使用了“二分法”——现在想起来大概是倍增法更贴切一点。</p><p>饭除了感觉容易使人发胖，还是非常好的，尤其喜欢一块含汁的肉扒，可能是牛扒吧。从那里开始，最初的伙伴是 wzj 和 ckj。其他的人都不太记得了，从现在来看都是一时散去的云烟罢了。好像最开始就想未来大概非常既定，就是上 oiclass，然后前往亚运城搞竞赛。多好啊。</p><p>lzoi.cn 的线，大概是一开始给我妈发了短信；大部分情况下都没有出很难的题，然而有一次布置的比赛，涉及了八皇后问题，比较困难，家里还停电，限着 deadline。我的父亲给我买了紫书，讲那个回溯法，完全看不懂。最后提交了 wzj 的代码才勉强按时通过那一次。</p><p>这段时间自学了最大流算法、KMP、manacher、A*、IDA*，这实在是我极其自豪的自学能力。</p><p>在最后要做定选择的时候，我妈妈给我比我高一级的去了 lz 的小学学长打了电话请教。他们的游说是选择初中要考虑综合实力。总之最后我还是没有选择天依中学。我和 wzj 都去往了 lz，ckj 独自在 oiclass。有时想，如果我当时作出原来的选择，会怎么样？有得有失吧，似乎可以得一些更长久的东西。</p><p>关于我的其他小学同学，寒假的时候就抓紧时间多加玩乐。大部分选择地段升初中或摇号，并且对我们的信息学道路表示不了解。</p><h2 id="Year-0"><a href="#Year-0" class="headerlink" title="Year 0"></a>Year 0</h2><p><em>2021-2022.</em></p><p>应该都知道我的编号从 $0$ 开始，故 Year 0 代表初一吧。</p><h3 id="机房"><a href="#机房" class="headerlink" title="机房"></a>机房</h3><p>首次踏入中山楼六楼机房，认识教练，新认识的同学是 lzx、lyq、lhn、gyx、闪击了一下就润去 oiclass 的 szq，并渐渐知道了 cyr、gf、wc、cbs、zqb、cy（没有 r）、fzh（高中没能留在 lz）、tjx（后来因不太好的原因退役）等（当时的）初三大佬。暑假就是加训 DP，很多的 DP 专题，并且这段时间在 lzoi 进行了唯一一次讲课，是 OOP 主题的。</p><p>开学后，本年级就涌进来一波新鲜血液（后来得知这里的选拔测试我是低于分数线的，本是无法进入 OI 训练的，twisted fate）。然后就是赛事，<a href="https://sunsetglow95.github.io/rec-2021csp/">CSP-J 没有满分、S 勉强二等</a>、<a href="https://sunsetglow95.github.io/rec-2021noip/">NOIP 压线一等</a>、CCPC 拖 cyr 和 gf 后腿、ICPC 个人赛没有显著表现、<a href="https://sunsetglow95.github.io/rec-2022noio/">NOI Online 走狗屎运</a>、<a href="https://sunsetglow95.github.io/rec-2022gdoi-j/">参与不知名野鸡比赛</a>、<a href="https://sunsetglow95.github.io/rec-2022apio/">APIO 铁牌</a>、THU 不记得哪个营拖着渣机拿了铁牌。在 NOIP 一等后，进入校集训，渐渐认识 dxw、cda、zzy（总以为当时初二就他们仨在搞 OI），以及知道当时的高一 ldq、hm、xhx、qkr、lzc、yjs 等，高二的好像就不咋知道。反正到达就是要先认人，狠狠认人。在校集训中学到了莫队、cdq 分治、凸包，私以为很有效率，也很有用。</p><p>很有意思的是，在机房才发现自己的码风是多么格格不入，当时我仍然大量使用空格和 STL，几乎不用数组，纯用 vector 代替。现在回忆，实在想不起啥时候开始使用数组的，可能是初一吧。</p><p>寒假的时候自学了重链剖分、FFT、跳表。在引导下继续学习很多省选知识点。每天中午的训练就是看着 lzqy 板刷 2800，然后烦他，然后受题目的虐。总之就是在训练中缓慢掌握了提高组实力吧。</p><h3 id="机房以外"><a href="#机房以外" class="headerlink" title="机房以外"></a>机房以外</h3><p>OI 队的基本都分散在各班，我所熟悉的只有和 lzx 同在 15 班，wzj 在 13，lyq 在 14，lhn、gyx 在 16。事实上上面我咨询的那个学长也在 16，于是一开始觉得不应该在 15。后来也认识到这一论断的无理性。</p><p>我竞选了班长，并且成功了，大概是因为只有我一个男士。</p><p>一个点是，两次的期末考试我都考的比较垃圾，低于 wzj：我始终把他作为竞争对手。然而我完全不知道原因。上学期期中 top 3 进行表彰，我荣获 rk 4；下学期的期中是 top 5，我似乎是 rk 6。好吧。</p><p>我写到这里，突然发现没有一个音乐主题去描绘每个时期。</p><p>好像是七年级下学期末期开始了解 beatbox。</p><h2 id="Year-1-1"><a href="#Year-1-1" class="headerlink" title="Year 1"></a>Year 1</h2><p><em>2022-2023.</em></p><p>消失的一年。</p><h3 id="whk"><a href="#whk" class="headerlink" title="whk"></a>whk</h3><p>这一年我想机房以外的更为一主线吧。</p><p>有意思的是，本学期和上学期各讲了一下信息技术课，上学期是和我们班的所有 OI 选手：我、zwx、lzx、zbn、pqa 一起讲搜索算法，那个是项目展示；这次是“小鬼当家”，讲爬虫，但是不记得有没有跟谁一起讲了。</p><p>上学期网课以来，我的 whk 越学越爽，估计名次还不低呢。并且道法开始开窍了，同时开始确立语文和物理两个弱势学科。进行续火，说了很多。</p><p>这个在潮州的春节是我印象中最浪漫的，共看烟花，走西湖山，逛龙湖巷。</p><p>下学期我便想证明一下自己，上半学期多搞 whk，逼迫自己断网，结果陷入一种很压抑的境地，并且吵了架。某个周六，和 lzqy 出去看《铃芽之旅》，回来独坐在空荡荡的教室里，漆黑的环境，下着淅淅沥沥的雨，为周末作业挣扎着。这里感受到自己的冲动经常是短期性的，而不是长期坚持的。打了小云雀杯后顺便游了一下东山口——故地重游，孤身一人。最后就是之前发挥还不错的期中考也挂飞了，荣获作文 26/50 分。</p><p>很有意思的是，期中考后突然炸出来若干对 CP。</p><p>下半学期在班里组了一个宽松但是比较活跃的小组，然后在表彰 top 5 的期末考试上再次荣获 rk 6，可以嘚瑟的一点是五个人的小组三个人获得飞跃进步奖……忘了说了，OI 女队在此前一直在 whk 制霸，在七下期末考中获得 500（多扣了 6 分）/510 的分数，本次以 1 分高于我的分数和我的一个好兄弟并列 rk 4。OK。并且本次开始，我们班开启了另一位男士以 583/600 开始统治的时期，改朝换代了，后来这位老哥被称为“真神”。</p><p>好像现在想起来，whk 实在不太重要，我每天做的作业的确不会在我脑袋里留下一点划痕。</p><p>进行了一次公交车从头坐到尾：190 路。从海珠到越秀再到白云。</p><p>好像是七月一号还是啥时候，和班里同学去了一趟惠州，徒步，受晒，浸水里。</p><p>那干脆把暑假末的军训也放到这里吧。这样一看，这个下半学期应该是喜爱旅游的。</p><h3 id="OI"><a href="#OI" class="headerlink" title="OI"></a>OI</h3><p>我这一年几乎啥都没做。疫情导致海珠、天河、花都三区无法参加 CSP，而广州 OI 强校名列其中的只有我所在的 lzoi（假使它可以被称作这个），更不必提 NOIP。上学期几乎没有什么训练。组织个补测，<a href="https://sunsetglow95.github.io/rec-2022csp2-r/">200+ 的分数跑出来个 40 分</a>，还告诉我是我的问题，几个意思？当时也火候未到，<a href="https://sunsetglow95.github.io/rec-2023gdoi/">省选 Day 2 挂飞</a>，从后来看大概这种赛制的都会挂飞一天。更不必提 APIO、TP 营，压根报不上名。<a href="https://sunsetglow95.github.io/rec-2023gdcpc/">GDCPC</a> 纯粹体验 sztu 美丽校园去了。不过大概这个时候，xjd、lsy 等新鲜血液开始雄起了。</p><p>既然是初中游记，那就不提高中。</p><p>暑期去了 ZhengruiOI，颇有收获，补齐了杜教筛、类欧等很多科技。也大概是这次开始，加入 OI 圈子的活动，见到了 ix35、flowerletter 等众多大佬，感受现今全国的 OI 环境。和 zzy、zc 一起度过了一段很快乐的岁月，晚上熬到 12 点，打 Codeforces，催 zzy 清体力，吃疯狂星期四，夜谈感情问题……老爽了……</p><h2 id="Year-2"><a href="#Year-2" class="headerlink" title="Year 2"></a>Year 2</h2><p><em>2023-2024.</em></p><p>感觉上，和初二差不多？</p><h3 id="停课"><a href="#停课" class="headerlink" title="停课"></a>停课</h3><p>去正睿住爽了，于是办了住宿，同时另一个原因大概是最亲近的几个兄弟都是住宿的吧。</p><p>字面意思。在 <a href="https://sunsetglow95.github.io/rec-2023csp/">CSP</a> 和 <a href="https://sunsetglow95.github.io/rec-2023noip/">NOIP</a> 前各进行了 2 周的停课。一开始完全没预料到，也不知道谁开始的，就开始了。加强了 generals.io，学习了雀魂麻将，学习了 xmind 的用法，并看到一些有趣的 tricks，如猫树分治（可惜的是我还没有写过这玩意）。也认识到一些高一级新鲜血液。这段时间机房颓风比较重。但自己每天早上吃饭走向小机房、上午一场模拟赛、提前吃午饭看别人体育课、中午一把雀魂跟教练斗智斗勇、在支撑不稳的躺椅上睡半个小时、下午补题或者继续模拟赛、然后跑个步、提前吃个晚餐、晚上再 generals 一会……这样的滋润生活实在是再不能有了。</p><p>逃过了作业的同时，几次大考名次也大概在班 rk 10 内，还行。（不过最后知道期末考掉到 rk 11，第二、三次月考前可都是有停课的，充分说明停课的重要性。）</p><h3 id="放飞自我"><a href="#放飞自我" class="headerlink" title="放飞自我"></a>放飞自我</h3><p>THUPC 初赛……算了，输输输输输。</p><p><a href="https://sunsetglow95.github.io/rec-2024gdkoi-s/">GDKOI</a> 打出了我记忆中最好的战绩，好像是 rk 17，不挂分似乎可以 rk 1，不过由于 rk 1 是挂分的，所以这也没什么可提的，就如初二下期末考试一样。gyx 可爱捏。</p><p>寒假度过了这三年最自由的十几天。走重庆，吃辣食。PKUWC 由于菜打得比较烂；NOI WC 听了很多有意思的课，比赛一般，听了很有意思的文艺晚会，接触了各地的大佬。</p><p>然后再回潮州，逛开元寺。</p><h3 id="再一搏"><a href="#再一搏" class="headerlink" title="再一搏"></a>再一搏</h3><p>在本学校刚好练习时长两年半的时候，和本校高中断约。</p><p>去高中训省选。<a href="https://sunsetglow95.github.io/rec-2024gdoi/">打得有点烂</a>，这是菜的必然后果。感觉自己一直没有很花力气训。再回东莞松山湖，从高名次到展现真实弱势。膜拜天依 OI，同时吃吃瓜。</p><p>前往杭州进行一个 <a href="https://sunsetglow95.github.io/rec-2024pkusc/">PKUSC</a> 的打，获得 $71+215$ 的抽象发挥。手生了导致的。不过也算一次很有意思的旅途。</p><p>本次 <a href="https://sunsetglow95.github.io/rec-2024gdcpc/">GDCPC</a> 尚可，个人赛和团队赛都打得还不错。wzj 发力了。</p><p>这段时间 AtCoder 和 Codeforces 的名字颜色都打上了黄色。</p><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>主要的时间都花在中考，whk 复习。预期大概 750 就满足了。</p><p>体育三级蛙跳超差发挥。英语听说，怀疑重说的错误 preparation 读音会扣分。化学实验，最后来不及把烧杯放回框里，估计扣分。物理实验，没啥东西。</p><p>月考班 rk 3，一模炸，二模班 rk 1。？想必下一个就是中考炸了吧。反正我考的好的时候是不表彰的场景，大考就全炸吧。</p><p>最后的小组本说定上面八下 rk 4 的老哥一起，最后还是跑路了，和女队、lzx、其他的好友组了。除了我和一个同样住宿的兄弟，另外四个总是能聊八卦聊得特别欢，而我耳背。谈起来初中以来染上眼瞎、耳背、记忆力衰退等，想除了有时候还算精神矍铄，身上没什么可以被称为健康的地方了。</p><h3 id="毕业季"><a href="#毕业季" class="headerlink" title="毕业季"></a>毕业季</h3><p>中考刷刷刷就过去了。当愚蠢的数学 24(3) 考场上临门一脚踢不进，失败就已经注定了。</p><p>在毕业典礼上和一位哥们合作唱了 Justin Bieber 的 Baby，负责了比较难的一段 Rap，感觉尚可。</p><p>在奔波时想到了很多想说的话，对老师、对同学、对浪漫，此时坐在电脑前却完全没有煽情的冲动，只是还是感叹一些同学真的好心思！这是不是说明，我的人情从来都不是我自己的情感，而是别人的情感在我身上的残留？</p><p>和最后的小组成员玩密室，溜冰，逛正佳，最后道了别。回想起这里，则有一种忧伤、迷惘、失落之感，毕竟我们组、或者说我们班绝大部分人，包含我的绝大部分好友，都留了下来，而一年以前抛出的回旋镖今日飞回击中我的命途。</p><p>但是只要加训就不会失落了！是啊，不如加训。和人聊天，是越聊越没得聊；做题，却是越做越爽。停滞带来焦虑，狂奔获得愉悦。</p><p>自主招生考的不错。96.3。</p><p>中考的结局：</p><div class="table-container"><table><thead><tr><th style="text-align:center">语文</th><th style="text-align:center">数学</th><th style="text-align:center">英语</th><th style="text-align:center">道德与法治</th><th style="text-align:center">历史</th><th style="text-align:center">物理</th><th style="text-align:center">化学</th><th style="text-align:center">体育与健康</th><th style="text-align:center">总分</th></tr></thead><tbody><tr><td style="text-align:center">107</td><td style="text-align:center">112</td><td style="text-align:center">117(28.6)</td><td style="text-align:center">80</td><td style="text-align:center">84</td><td style="text-align:center">99(10)</td><td style="text-align:center">91(10)</td><td style="text-align:center">69</td><td style="text-align:center">759</td></tr></tbody></table></div><p>最引以为傲的数学和英语发挥并不亮眼，最喜欢的历史和化学低于人均分，时不时可以打出相当好名次的语文和道法也不是非常大的优势，习惯了挂分的物理这次挺好的，但和体育一样，都是遗憾，距离那个超越预期的分界线还差一步。</p><p>所以这次中考也没什么可值得骄傲或高兴的。就这样吧，遗憾已经过去了，无法挽回，也不必挽回了。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>（Updated on 2024.10.29：这个位置本来有一个 People 环节，但想想感觉太尴尬了，还是算了吧。并且把其它一些没必要的情节也删改了。）</p><p>所以当我回想我的初中，我应该想起什么？</p><p>想起在中山楼六楼和七楼度过的岁月。</p><p>想起胜败中的喜悲悸动直到镇定。</p><p>想起旅途上自然的万般风味与市井的多样人情。</p><p>那么这样，我把初中的记忆统统倾倒出来，过去便已过去。未知的未来，凭借冲动向前奔去吧。</p><p>你说的对，但是，未来可能更是随机的，不太懂。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - QOJ 8757 图</title>
    <link href="/sol-QOJ8757/"/>
    <url>/sol-QOJ8757/</url>
    
    <content type="html"><![CDATA[<p>绝好题。</p><h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>给一个 $n$ 点 $m$ 边无向图，可能存在重边，不存在自环。令 $k=\lceil \frac{m}{n-1} \rceil$，找出点 $u,v(u\neq v)$，输出 $u\to v$ 的 $k$ 条边不交路径。无解输出 <code>-1</code>。</p><p>多测。$\sum n\le 10^5$，$\sum m\le 2\times 10^5$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看见 $n-1$ 想到树是当然的，但是如何进一步拓展是困难的。</p><p>观察样例，猜想是必然存在，而且 $k$ 正好是上界。考虑 $u\to v$ 的路径有至少 $k$ 条。且由题，$\frac{m}{n-1}\le k&lt;\frac{m+n-1}{n-1}$，如果纠结在取等的不等号，则有点使人疑惑。</p><p>另一个有关于树的结论是：一棵树上，任意两点间有唯一路径。</p><p>那么，能否构造若干个森林，使得在每个森林里，$u,v$ 都联通，然后在每个森林都找出 $u\to v$ 的路径？</p><p>那么一种自然的想法是，让每对 $(u,v)$ 都在一段前缀森林中联通。这样，对每个边我们从前往后逐个尝试加入并查集中即可。事实上，这个过程可以二分优化。</p><p>下面，我们要证明这个结论的正确性。</p><p>如果可能找不到，那么最后一个森林中一条边也没有。而前面的 $k-1$ 个森林中，至多有 $(k-1)(n-1)$ 条边，根据 $k(n-1)&lt;m+n-1$，$(k-1)(n-1)&lt;m$，即必有富余的边会考虑加入第 $k$ 个森林。所以最后一个森林中必有边。这启示我们，面对取整符号，两端都要留意。</p><p>时间复杂度 $O(n\log m\alpha (n))$，实现不精细，两只 $\log$ 也可以了。空间复杂度 $O(m)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fa, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ~fa[x] ? fa[x] = <span class="hljs-built_in">find</span>(fa, fa[x]) : x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  cin &gt;&gt; T;<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">M</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(ceil(M * <span class="hljs-number">1.0</span> / (N - <span class="hljs-number">1</span>)))</span></span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dsets</span>(cnt, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N, <span class="hljs-number">-1</span>));<br>    vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">tos</span>(cnt, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(N));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); M--;) &#123;<br>      cin &gt;&gt; x &gt;&gt; y;<br>      --x, --y;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1</span>)</span>, <span class="hljs-title">r</span><span class="hljs-params">(cnt - <span class="hljs-number">1</span>)</span></span>;<br>      <span class="hljs-keyword">while</span> (r - l &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">m</span><span class="hljs-params">((l + r) &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(dsets[m], x) != <span class="hljs-built_in">find</span>(dsets[m], y))<br>          r = m;<br>        <span class="hljs-keyword">else</span><br>          l = m;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">a</span><span class="hljs-params">(find(dsets[r], x))</span>, <span class="hljs-title">b</span><span class="hljs-params">(find(dsets[r], y))</span></span>;<br>      <span class="hljs-keyword">if</span> (a != b) &#123;<br>        tos[r][x].<span class="hljs-built_in">push_back</span>(y);<br>        tos[r][y].<span class="hljs-built_in">push_back</span>(x);<br>        dsets[r][a] = b;<br>      &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (; u != N &amp;&amp; dsets[cnt - <span class="hljs-number">1</span>][u] == <span class="hljs-number">-1</span>; ++u);<br>    <span class="hljs-built_in">assert</span>(u != N);<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">v</span><span class="hljs-params">(dsets[cnt - <span class="hljs-number">1</span>][u])</span></span>;<br>    cout &lt;&lt; u + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; v + <span class="hljs-number">1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>); id != cnt; ++id) &#123;<br>      <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(N, <span class="hljs-number">-1</span>)</span></span>;<br>      deque&lt;<span class="hljs-type">int</span>&gt; que;<br>      que.<span class="hljs-built_in">push_back</span>(v);<br>      <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(que.front())</span></span>;<br>        que.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : tos[id][c]) &#123;<br>          <span class="hljs-keyword">if</span> (pre[p] == <span class="hljs-number">-1</span> &amp;&amp; p != v)<br>            pre[p] = c, que.<span class="hljs-built_in">push_back</span>(p);<br>        &#125;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(u); ~i; i = pre[i]) ++len;<br>      cout &lt;&lt; len;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(u); ~i; i = pre[i]) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i + <span class="hljs-number">1</span>;<br>      cout &lt;&lt; endl;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - GDCPC 2024</title>
    <link href="/rec-2024gdcpc/"/>
    <url>/rec-2024gdcpc/</url>
    
    <content type="html"><![CDATA[<h2 id="Day"><a href="#Day" class="headerlink" title="Day -?"></a>Day -?</h2><p>和<a href="https://www.luogu.com.cn/user/343251">尊贵的 luogu 管理</a>以及 <a href="https://www.luogu.com.cn/user/366581">zhafde fans club 群友</a>组队，原因是想起来去年七月命名的 Alchemy 队名似乎还没用上（当时是用来申请 ucup，只是懒惰的我一次也没有打）。</p><p>然后群里转发了一个个人赛的链接，说每个队要派一个去打，然后我就稀里糊涂地报了名。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p><em>2024.5.25.</em></p><p>发现个人赛可以不报名。OK。</p><p>讨论了板子问题，最后由 zhafde 整出高达 31 页的板子整理。恐怖如斯。我提出建议，筛法可以不带。</p><p>上午翘开幕式，然后简单试机，并且膜拜 wzj33300。午饭在真功夫等了半天，然后睡觉。13:57 醒来，父母都以为 14:30 开个人赛，而我看着选手牌上的 14:00，一路狂奔。结果到了才发现，怎么真的延误成了 14:30……</p><h3 id="个人赛题意简述"><a href="#个人赛题意简述" class="headerlink" title="个人赛题意简述"></a>个人赛题意简述</h3><p>A：给一个序列，多次询问如果去除下标在 $[l_i,r_i]$ 的元素，剩下来的任选三个数组成三角形，最大的周长是多少。无解输出 <code>-1</code>。$n\le 5\times 10^5$，$q\le 10^6$。</p><p>B：给一棵有根树。定义一个点集是好的，当且仅当其中任意两点的 LCA 为同一个点，且这个点在集合中。定义一个点集的集合是好的，当且仅当每个点集是好的，并且全部点在且恰好在一个点集中。忘了怎么算点集的集合的权值，反正要求全部好的点集集合的权值的加和或乘积。$n\le 200$。</p><p>C：给一个正整数序列 $a$ 表示 $n$ 个人的初始分数。两个人打一场比赛的结果，是都加 $1$ 分或者某一个人加 $3$ 分。若每个人都打了 $k$ 场比赛，求分数严格高于第一个人的分数的人数的最小值。$2\le n\le 10^5$，$1\le k\le 10$。</p><p>D：多次询问，构造方案，在 $n\times m$ 的棋盘上放 $k$ 个马，使得它们两两不能攻击，规则用中国象棋的。$t\le 10^4$，$n,m\le 10^3$。</p><p>E：构造无限长的 01 字符串 $S$，$S_i$ 为 $i$ 在二进制下 popcount 的奇偶性，$i$ 从 $0$ 开始。每次给一个含 <code>0/1/?</code> 的字符串，对每个前缀问每种给 <code>?</code> 填 01 的方式中，前缀的在 $S$ 中的子串个数的和。范围忘了，似乎是 $10^5$ 级别。</p><p>F：简而言之是一道二合一，是入门题加背包和体积很大、价值比较小的多重背包。大到 $10^{12}$。</p><p>G：有 $n$ 块钱，要数有多少组正整数 $(a,b,c)$，满足 $40a+39b+\frac{1}{2}c=n$。$n\le 10^{16}$。</p><p>H：定义一个 $n$ 个点的简单图是好的，当且仅当任意两点间的路径数目在 $[k,k+1]$ 之间，给定 $k$，数好的图的个数。数据范围忘了。</p><h3 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h3><p>先看了会 A，没有秒。发了会呆，打算跟榜开题。然后开了 G，然后过了。</p><p>然后想明白了 A，有对数长度的性质。简而言之，就是最大的三个数 $a,b,c$ 不能满足，那么 $2c\le a$，依此类推，所以最多暴力试 $\log V$ 次。然后写了个主席树，两只 $\log$，被卡了。</p><p>然后再跟榜，看 C，发现好像有点麻烦。然后口胡了这样一个办法：$a\le a_1$ 和 $a&gt;a_1+3k$ 的直接无视，可以让它们都赢来让中间的部分输。然后二分中间的部分有几个可以不超过 $a_1+3k$，其余的直接全赢即可，这部分全赢的就挑较大的那些。这个地方的判定感觉有点模糊，直接写：记录每个点还给输的总次数和给平局的总次数，一胜二负可换三次平局，不行就 break。然后就过了，没有卡我，估计是数据造水了，感觉不是很严谨。</p><p>然后发现 A 不需要主席树，直接维护前/后缀的前 37 大就可以了。这个时候开始了智熄操作：两发罚时没删调试语句，两发罚时罚 iostream。从结果上看，这个失误直接导致了我掉出前 20。</p><p>切完三道签到，已经过了 100 min，感觉有点久了。榜上有别人做的就是 D，然后就想到矩形和等腰直角三角形是满足条件的。更广泛一点，一个八边形，其中只有横边、纵边、45 度边的，都是可以的。然后就想能不能枚举四个角，时间太久，没想到优化。</p><p>看了眼其他题，B 似乎最优做法是 $n^4$，目测不好写也比较久。E、H 不可做。F，已经把题意拆成上面所述的了，然后发现不会这种大体积背包，然后放弃。</p><p>结束前 6 min，突然觉得 D 可以只枚举左上和右下的三角形，然后就慌了，以为会了。</p><h3 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h3><p>讲了讲 D 做法，突然发现假了，那还是活该。</p><p>手动滚榜，一万个名字被读错，分辨率有点低下。</p><p>广州市铁一中学初二学子战绩斐然！祈福英语实验小学荣获 rk6！长沙市雅礼中学包揽 rk1,2！而且双双切下 B 题！</p><p>以为有讲题。</p><p>回来看题解，发现 B 正解就是 $O(n^4)$，而 F 可以反转价值和体积，属于是智熄了一下。</p><p>没事，不过是热身。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p><em>2024.5.26.</em></p><p>到处都是小情侣和女装大佬。</p><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>A：给一些线段，数有多少个田字格，大概这样，不记得了。</p><p>B：给若干个字符串，求两两 LCPS 的长度总和，$\operatorname{LCPS}(A,B)$ 为最长的 $s$，满足 $s$ 为 $A$ 后缀、也为 $B$ 前缀。$\sum |S|\le 3\times 10^6$。</p><p>C：忘了，因为我没做，但好像很简单。</p><p>D：超长题面，懒得读。</p><p>E：对 $n$ 个点的竞赛图，有任选 $m$ 个点，必有一个点指向其他所有点、必有一个点被其他所有点指向。求点的出度集合的最小大小。$n,m$ 比较大，多测。</p><p>F：给一个无向图，找到一对 $(u,v)$ 和 $\lceil\frac{m}{n-1}\rceil$ 个 $u\to v$ 的边不交的路径。$n,m\le 3\times 10^5$。</p><p>G：$10$ 次询问，每次给定 $[l,r]$，求 $\max_{l\le x&lt;y\le r} \gcd(x,y)$。$1\le l&lt;r\le 10^{12}$。</p><p>H：有 $m$ 个盒子，$n$ 个球。每个盒子有容量。编号为 $i$ 的球操作时会从序列 $a_i$ 中找到最先的没满的盒子，然后投进去，如果没有就不投进去。给这些球排序，让它们依次操作，使得投进盒子的球数最大。输出最大球数及一种方案。$t\le 500$，$n\le 500$，$m\le 500$，$\sum nm\le 2.5\times 10^5$。</p><p>I：有长为 $n$ 的正整数序列 $a$，和 $m$ 个限制，形如 $a<em>{x_i}\ge a</em>{y<em>i}+a</em>{z_i}$，求最小的 $\sum a$，满足 $\sum a\le 10^9$，无解输出 <code>-1</code>。忘了范围了。</p><p>J：考虑编号为 $2\sim n$ 的无向图，$u,v$ 有边当且仅当 $u|v\lor v|u$。求所有联通点对的编号乘积之和。$n\le 10^{11}$。</p><h3 id="令人无语的赛程"><a href="#令人无语的赛程" class="headerlink" title="令人无语的赛程"></a>令人无语的赛程</h3><p>有意思的是，被堵门一段时间才进场，没有人检查身份证，而且发现电脑仍未重置。</p><p>先跟会榜。突然发现智障地卡了 G 题，卡了一卡，感觉没很水的做法，还是写整除分块。反正过了 G、I、C，其中 heaksicn 在 I 题贡献了 2 发罚时，zhafde 通过了 C。</p><p>猜 J，heaksicn 提出是一大坨联通图再加比较大的一些质数的样子，觉得非常有道理。然后发现要求质数前缀和和质数平方前缀和。尝试场推 min_25 筛，式子推对了，时间全假了。加了记忆化，还是跑不动。一点不会实现，开摆。</p><p>队友写 E，暴力写挂，我实在急了，我说你要不猜吧，然后发现他猜的贼有道理，就是首项和末项猜一下，然后中间是一大串 $n$，然后公差为 $2$ 下降。然后就 TLE 了，原来是 <code>iostream</code> 导致的。过了。至此，heaksicn 贡献了 4 发罚时，可见其贡献之大。</p><p>会了 B，知道是 AC 自动机，每个点直接 fail 子树 sum 乘上 trie 子树 sum，然后可能还要容斥。然后突然又不会了，想不清楚怎么计算“longest”。吃了点东西，又会了，发现可以让每一个都有贡献，算最长 border 就行。然后过了。这个东西呢，是两片面包夹着紫薯、蛋、番茄、鸡肉、生菜的矩形三明治，感觉味道很奇怪。</p><p>然后队友继续 H，这可是他们最喜欢的费用流。我猜 F，猜不到一点，只往找 dfs 树（后来看看这一部分本来应该对对脑电波的）、找点双、以及最大化最小割想，显然越想越偏。</p><p>还剩一个小时，一个 H 调不出来，急了。然后把输出排列的部分写拓扑排序（这玩意能写 40 min 有点绷不住），然后就 TLE 了，最后认为是费用流导致的。</p><p>什么？你问 A 和 D？加训 ds 的 zhafde 早就看了，并且表示不可做，从最终的榜上看，的确没人做。</p><p>虽然上了金线，也高于校另一队两名，但还是感觉遗憾。<a href="https://www.luogu.com.cn/user/324666">seanlsy</a> 场推 min_25 筛，除了膜拜还有什么！广东实验中学初二如此强悍，还能说什么！</p><h3 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h3><p>打星没有任何 award。和同校的吃了个 KFC，然后跑路。</p><p>正如 zhafde fans club 群友所说，但凡带一个 min_25 板子（我愚笨的脑子还是实在想不起那个优秀的实现方法和时间的证明），但凡他把 F 题想到树的灵感拿出来讨论一下（其实好像也讨论不到那么妙的做法，虽然我隐约对过脑电波），（H 实在不知道咋回事，有人 zkw 费用流可过，让我们队很懵），其实很多缺憾都弥补了。</p><p>经验问题。实力问题。</p><p>然后在 Q 群和知乎吃瓜。</p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>贴一下个人赛的题解。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### A 水仙三角形</span><br><br>先考虑$O(n)$是可以回答每个询问的：枚举最大的木棒，那么剩下两个木棒的长度之和就需要最大，那么必然是小于当前长度的最小的两个。<br><br>因此对有序的数组，只需要检验相邻的三个即可。<br><br>考虑最大值如果不用，那么第二大和第三大的和小于等于它，那么第三大必然不超过最大值的一半<br><br>依次类推，如果第三大也不能是答案，那么第五大必然不超过第三大的一半<br><br>依次类推，经过$2logV$次之后，数值就会到达1，因此如果有解，最大值必然在前$40$大的值中。<br><br>维护前缀和后缀的前$40$大值，使用插入排序。<br><br>对于每个询问，把断开出的前缀和后缀合并成一个有序数组，求解，这里使用归并排序。<br><br><span class="hljs-section">### B 分割树</span><br><br>一个点集 $V&#x27;$ 是好的，当且仅当其包含一个节点与它的某些儿子节点子树中的至多一个节点。也就是说，对于 $V&#x27;$ 中的点建立虚树，一定是一个菊花，且是根向下有若干条边。<br><br>一个点集的集合的权值是从其每个点集中选出一个位置，乘积之和。<br><br>考虑 $dp<span class="hljs-emphasis">_&#123;i,j,k&#125;$ 表示 $i$ 子树内，有 $j+k$ 个剩余的不在某个点集的节点，其中 $j$ 个给乘积的贡献为 $1$，$k$ 个为 $a_</span>x$ 的所有情况下，目前权值的和。<br><br>考虑转移，有以下两种情况：<br><br>\* 目前点 $i$ 是某个子集的“根”节点；<br>\* 目前点 $i$ 是某个子集的“叶子”节点。<br><br>对于第一种情况，设辅助数组 $f<span class="hljs-emphasis">_&#123;j,k,0/1&#125;$，最后一维的含义是该子集是否钦定一个点给乘积的贡献为 $a_</span>x$。有以下转移：<br><br>\* $f<span class="hljs-emphasis">_&#123;j_</span>1,k<span class="hljs-emphasis">_1,0&#125;\times dp_</span>&#123;v,j<span class="hljs-emphasis">_2,k_</span>2&#125;\to f&#x27;<span class="hljs-emphasis">_&#123;j_</span>1+j<span class="hljs-emphasis">_2,k_</span>1+k<span class="hljs-emphasis">_2,0&#125;$；</span><br><span class="hljs-emphasis">\* $f_</span>&#123;j<span class="hljs-emphasis">_1,k_</span>1,1&#125;\times dp<span class="hljs-emphasis">_&#123;v,j_</span>2,k<span class="hljs-emphasis">_2&#125;\to f&#x27;_</span>&#123;j<span class="hljs-emphasis">_1+j_</span>2,k<span class="hljs-emphasis">_1+k_</span>2,1&#125;$；<br>\* $f<span class="hljs-emphasis">_&#123;j_</span>1,k<span class="hljs-emphasis">_1,0&#125;\times dp_</span>&#123;v,j<span class="hljs-emphasis">_2,k_</span>2&#125;\to f&#x27;<span class="hljs-emphasis">_&#123;j_</span>1+j<span class="hljs-emphasis">_2-1,k_</span>1+k<span class="hljs-emphasis">_2,0&#125;$；</span><br><span class="hljs-emphasis">\* $f_</span>&#123;j<span class="hljs-emphasis">_1,k_</span>1,1&#125;\times dp<span class="hljs-emphasis">_&#123;v,j_</span>2,k<span class="hljs-emphasis">_2&#125;\to f&#x27;_</span>&#123;j<span class="hljs-emphasis">_1+j_</span>2-1,k<span class="hljs-emphasis">_1+k_</span>2,1&#125;$；<br>\* $f<span class="hljs-emphasis">_&#123;j_</span>1,k<span class="hljs-emphasis">_1,0&#125;\times dp_</span>&#123;v,j<span class="hljs-emphasis">_2,k_</span>2&#125;\to f&#x27;<span class="hljs-emphasis">_&#123;j_</span>1+j<span class="hljs-emphasis">_2,k_</span>1+k<span class="hljs-emphasis">_2-1,1&#125;$。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">最后 $f_</span>&#123;j,k,1&#125;\to dp<span class="hljs-emphasis">_&#123;i,j,k&#125;$。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">对于第二种情况，设辅助数组 $g_</span>&#123;j,k&#125;$。有以下转移：<br><br>\* $g<span class="hljs-emphasis">_&#123;j_</span>1,k<span class="hljs-emphasis">_1&#125;\times dp_</span>&#123;v,j<span class="hljs-emphasis">_2,k_</span>2&#125;\to g&#x27;<span class="hljs-emphasis">_&#123;j_</span>1+j<span class="hljs-emphasis">_2,k_</span>1+k<span class="hljs-emphasis">_2&#125;$。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">最后有：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">\* $g_</span>&#123;j,k&#125;\to dp<span class="hljs-emphasis">_&#123;i,j+1,k&#125;$；</span><br><span class="hljs-emphasis">\* $g_</span>&#123;j,k&#125;\times a<span class="hljs-emphasis">_i\to dp_</span>&#123;i,j,k+1&#125;$。<br><br>根据树上依赖背包的分析，总复杂度为 $O(n^4)$。<br><br><span class="hljs-section">### C 乐乐买书</span><br><br>构造通解$z=2<span class="hljs-emphasis">*k,x=77*</span>k-38<span class="hljs-emphasis">*n,y=39*</span>n-79<span class="hljs-emphasis">*k$,算出$k$的范围，为解的数量。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">### D 马</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">考虑想几种构造方法然后拼起来。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">不妨设 $n\ge m$。首先，对于 $k\le (n-2)m$ 的情况，我们可以先放一个满的矩形然后空两行再放一个前缀。然后由于现在无法处理的 $k$ 接近 $nm$，我们考虑从填满的棋盘里去掉一些点。这件事有多种实现方法，比如去除三个角上的等腰直角三角形（任意正整数均可以被不超过三个三角形数的和表示，而且这里三角形的边长由于是 $\sqrt&#123;m&#125;$ 量级因此在 $n,m$ 较大时不会重叠，$n,m$ 较小时此方法也能得出合法方案），或者去除连续的三条斜线再删掉角上的 $0\sim 2$  个点等。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">总之这个题应该有多种构造方法，如果你的方法比较烂可能有一些边界情况。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">### E 字符串</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">记 $P_0$ 为题中给出的 $P$ 字符串，$P_1$ 为 $P_0$ 取反的结果。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">记 $S_&#123;l\sim r&#125;$ 在 $l\le r$ 时表示 $S_lS_&#123;l+1&#125;\dots S_&#123;r&#125;$，在 $l&gt;r$ 时，表示 $S_lS_&#123;l-1&#125;\dots S_&#123;r&#125;$。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">首先可以发现 $P_&#123;0,i&#125;=\operatorname&#123;popcount(i)&#125;\mod 2$。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">其次考虑找到 $P_0$ 子串的性质。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">&gt; Lemma.1：若 $S$ 为 $P_0$ 的子串且 $|S|&gt;1$，则存在拆分点 $i\in [1,|S|)$，使得 $T_&#123;i-1\sim 0&#125;=P_&#123;0/1,0\sim i-1&#125; \land T_&#123;i\sim |S|-1&#125;=P_&#123;0/1,0\sim |S|-i-1&#125;$。</span><br><span class="hljs-emphasis">&gt;</span><br><span class="hljs-emphasis">&gt; 简单地说，就是可以把 $S$ 拆分成两个串 $T_1,T_2$，使得 $T_2$ 是 $P_&#123;0/1&#125;$ 的前缀，$\operatorname&#123;rev&#125;(T_1)$ 是 $P_&#123;0/1&#125;$ 的前缀（$\operatorname&#123;rev&#125;$ 是字符串翻转）。</span><br><span class="hljs-emphasis">&gt;</span><br><span class="hljs-emphasis">&gt; 证明的话，设 $S$ 为 $P_&#123;0,l\sim r&#125;$，那么找到 $(l,r]$ 中 $\operatorname&#123;ctz&#125;$ 最大的 $i$，那么 $i-1$ 就是一个合法的拆分点。简单地说，就是找到进位最大的一次，后面的是 $P_&#123;P_&#123;0,i&#125;&#125;$ 的前缀，前面的翻转是 $P_&#123;P_&#123;0,i-1&#125;&#125;$ 的前缀。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">然后同时可以发现，Lemma.1 的逆命题也是真命题，即存在拆分点的串一定是 $P_0$ 的子串，证明考虑构造即可。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">&gt; Lemma.2：若 $S$ 是 $P_0$ 的子串且 $|S|&gt;1$，同时取出 $S$ 的两个拆分点 $i,j$，那么 $|i-j|=2^k(k\ge 0)$。</span><br><span class="hljs-emphasis">&gt;</span><br><span class="hljs-emphasis">&gt; 这个很好理解，$i,j$ 中间这一段正反都要是 $P_&#123;0/1&#125;$ 的前缀，长度只能是 $2^k$。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">注意到 Lemma.2 同时也说明了一个串的拆分点个数 $\le 3$，当个数 $&gt;3$ 的时候必然会有一对点不满足距离是 $2^k$ 的限制。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">但是其实拆分点个数有更加紧的上界 $2$，如下：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">&gt; Lemma.3：若 $S$ 是 $P_0$ 的子串且 $|S|&gt;1$，那么 $S$ 的拆分点至多只有两个。</span><br><span class="hljs-emphasis">&gt;</span><br><span class="hljs-emphasis">&gt; 证明并不难，考虑反证法：若有三个拆分点 $a,b,c(b-a=c-b=2^k)$，那么 $S_&#123;b\sim c-1&#125;$ 和 $S_&#123;a\sim b-1&#125;$ 正好互补，同时要求了 $S_&#123;c&#125;=1-S_&#123;b&#125;=1-S_&#123;a&#125;$，推出矛盾。</span><br><span class="hljs-emphasis">&gt;</span><br><span class="hljs-emphasis">&gt; 当然，你也可以尝试把长度 $\le n$ 的串都找一遍拆分点并输出，发现这个性质。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">到这里，我们先考虑如何计算 $g(S)$，发现只需要计算所有串拆分点的个数减去拆分点有 $2$ 个的串的个数。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">计算有拆分点的串个数：枚举拆分点位置，计算左右最多能匹配 $P_&#123;0/1&#125;$ 多远，乘起来贡献到答案。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">计算拆分点有 $2$ 个的串的个数：枚举拆分点距离 $2^k$，枚举两个拆分点 $i,j$，向左向右匹配至多 $2^k$，相乘贡献到答案。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">至于区间匹配 $P_&#123;0/1&#125;$ 的问题，可以使用倍增轻松解决。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">接下来，考虑计算 $k=|S|$ 时的答案。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">发现当拆分点在 $i$ 处时，向左匹配到 $j$，则贡献就是：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">$$</span><br><span class="hljs-emphasis">(i-j)\times 2^&#123;pre_j&#125;+\sum_&#123;x=j+1&#125;^&#123;i&#125;[<span class="hljs-string">S_x = \texttt&#123;?&#125;</span>](<span class="hljs-link">i-x</span>)\times 2^&#123;pre_&#123;x-1&#125;&#125;</span><br><span class="hljs-emphasis">$$</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">其中，$pre_x=\sum\limits_&#123;i\le x&#125;[S_i=\texttt&#123;?&#125;]$。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">预处理一下 $\sum\limits_&#123;x\le i&#125;[S_x=\texttt&#123;?&#125;]\times 2^&#123;pre_&#123;x-1&#125;&#125;$ 和 $\sum\limits_&#123;x\le i&#125;[S_x=\texttt&#123;?&#125;]\times x\times 2^&#123;pre_&#123;x-1&#125;&#125;$ 即可。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">向右匹配同理，计算完两边答案乘起来就行。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">拆分点个数为 $2$ 的同理计算，这里不赘述。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">一些小细节：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">- 多测注意清空；</span><br><span class="hljs-emphasis">- 子串长度为 $1$ 的情况特殊处理；</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">最后，对于 $k&lt;|S|$ 的答案，发现每一次贡献答案时对于 $k$ 都是一段区间加，所以差分一下即可，具体细节参见代码。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">时间复杂度：$\mathcal&#123;O&#125;(n\log n)$，空间复杂度：$\mathcal&#123;O&#125;(n+\frac&#123;n\log n&#125;&#123;\omega&#125;)$。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">题外话：本来是想出成区间询问的，奈何写出来的程序效率极差，常数非常大，所以降低了难度，出成前缀询问的。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">### F 出题</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">首先考虑第一个部分的性质。我们分两部分分析区间的个数：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">- 一端点是原区间端点的：这样的区间个数每个加入的区间至多会产生 $2q$ 个。</span><br><span class="hljs-emphasis">- 两端点都是被截断出来的：可以证明，这样的区间个数至多为 $2q$ 个。</span><br><span class="hljs-emphasis">  </span><br><span class="hljs-emphasis">  我们只需要证明这样的区间两两不交或包含即可。反证，假设两个区间相交，左边区间为 $[l_1,r_1]$，右边区间为 $[l_2,r_2]$，并且 $l_1<span class="language-xml">&lt;l_2&lt;r_1&lt;r_2$，则 $[l_1,r_1]$ 加入时间早于断点 $r_1$ 加入时间，并且晚于断点 $l_2$ 加入时间，$[l_2,r_2]$ 加入时间早于断点 $l_2$ 加入时间，晚于断点 $r_1$ 加入时间，矛盾。因此区间两两不交或包含，那么总区间个数只有二倍断点个数个。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">因此原问题可以被转化成价值总和比较小的多重背包问题。考虑将物品二进制拆分。设 $f_&#123;i,j&#125;$ 表示处理完所有个数 $\geq 2^i$ 的物品，价值总和为 $j$ 的最小体积，转移只需要枚举每个个数为 $2^&#123;i-1&#125;$ 的物品然后转移即可。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">但是这样时间复杂度爆炸，因为 $j$ 的范围并没有保证。考虑个数小于 $2^&#123;i&#125;$ 的物品的价值之和，显然不会超过 $2^&#123;i+2&#125;\sum q$，因此，我们只需要找到最大的 $j$ 满足 $f_&#123;i,j&#125;\leq T$，然后保留 $[j-2^&#123;i+2&#125;\sum q,j]$ 范围内的状态进行下一层 DP 即可，这样 DP 的复杂度是 $O(n\sum q\log T)$ 的。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">前半部分直接暴力 $O(\sum q^2)$ 即可通过。$O(\sum q^2\log q)$ 可能会被卡常。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">Bonus：DP 的复杂度实际上可以做到 $O(n\sum q\log (\max q\sum q))$。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">### G 比赛</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">对于非平局的情况（首先局数一定$\ge2k$，因为一号选手肯定是赢$k$把），不难发现只要赢的局数大于等于输的局数就一定存在合法匹配。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">对于非平局的情况，直接设到状态里面，具体的，设$f_&#123;i,j&#125;$表示前$i$个人，剩下$j$个平局待匹配。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">显然$j\le k$，每次枚举匹配多少个平局，剩下的贪心分配。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">把人按照分从小到大排序，显然舍弃的会是一个后缀，所以直接$dp$即可，时间复杂度$O(nk^3)$。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">### H 橙汁计划</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">首先题意是将一个森林补全为树或者基环树的方案数。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">考虑先求一下将所有连通块拼成一棵树的方案数，不难发现就是下面这个东西：</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">$$</span></span><br><span class="language-xml"><span class="hljs-emphasis">n^&#123;|S| - 2&#125; \times \prod_&#123;x \in S&#125; siz_x</span></span><br><span class="language-xml"><span class="hljs-emphasis">$$</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">这是因为考虑在长度为 $|S|-2$ 的 prufer 序列中填写 $1$ 到 $n$ 的项表示每条边被删除的时候连向的点，乘上每个连通块删除时最后连边的方案数。</span></span><br><span class="language-xml"><span class="hljs-emphasis"></span></span><br><span class="language-xml"><span class="hljs-emphasis">现在考虑枚举连通块集合 $T$ 形成了一个环，那么对于 $|T| &gt;</span> 2$ 的情况，方案数应该是这么个东西：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">$$</span><br><span class="hljs-emphasis">n^&#123;|S| - 2&#125; \times \prod_&#123;x \in S&#125; siz_x \times n^&#123;1 - |T|&#125; \times \prod_&#123;x \in T&#125; siz_x \times \sum_&#123;x \in T&#125; siz_x \times \frac&#123;(|T| - 1)!&#125;&#123;2&#125;</span><br><span class="hljs-emphasis">$$</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">大概意思就是把树的方案数中扣掉环的连通块，然后对环的每个连通块取两个点连到别的连通块。$(|T| - 1)!$ 算的是有向环的数量，因此要除以 $2$。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">考虑对每个 $|T|$ 算出对应的系数。显然麻烦的部分只有 $\prod_&#123;x \in T&#125; siz_x \times \sum_&#123;x \in T&#125; siz_x$，等价于 $\prod_&#123;x \in T&#125; siz_x \times \sum_&#123;x \in S&#125; siz_x - \prod_&#123;x \in T&#125; siz_x \times \sum_&#123;x \not\in T&#125; siz_x$，显然后半部分的式子可以将求和拆开从而改写成 $\prod_&#123;x \in T&#125; siz_x$ 乘上一些容易计算的项的形式，所以我们的任务变为求多项式 $\sum_T x^&#123;|T|&#125;\prod_&#123;y\in T&#125;siz_y=\prod_&#123;y\in S&#125;(siz_yx+1)$。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">这可以用分治 NTT 做到 $O(n\log^2 n)$。考虑如何优化。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">注意到因为 $\sum siz_x=n$，所以我们可以将完全相同的项用二项式定理直接乘起来，然后按照 $siz_x$ 从大到小暴力 NTT 合并所有多项式，合并所有项的复杂度为 $\sum_&#123;i=1&#125;^n [<span class="hljs-string">c_i</span>](<span class="hljs-link">c_i+\sum_&#123;j&gt;i&#125; c_j</span>)=O(\sum_i c_i\cdot i)=O(n)$，其中 $c_i=\sum_&#123;x\in S&#125;[siz_x=i]$。算上 NTT 的复杂度，总复杂度为 $O(n\log n)$。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - PKUSC 2024</title>
    <link href="/rec-2024pkusc/"/>
    <url>/rec-2024pkusc/</url>
    
    <content type="html"><![CDATA[<p>相比冬季，没啥意思，估计是心里放着 whk 吧。前情提要是，一模白挂 30+ 分，传统弱势政治和历史反而相对高名次。</p><p>飞过来才发现明明在学军文渊的比赛，机场却在宁波栎社，好像是搞成余姚中学导致的，所以辗转，晚上到 1:00 才睡。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p><em>2024.5.13.</em></p><p>睡了一场开幕式，然后试机，发现四个月前不会的 PKUWC D2T2 现在还是不会，搜了个题解，挺有意思的，但是还挺难写的，就去吃饭了。饭盒体量有点小了。</p><blockquote><p>T1：给两行长为 $n$ 的字符串，任意始终，每步向右或向下，要走出最长的回文串，求其长度。$n\le 10^5$。</p><p>T2：给格点 $n$ 边形的每个顶点坐标，求有多少种选大小为四的格点集合的办法，使得四个点均在多边形内或上，且形成一个正方形。$3\le n\le 8$，$0\le x_i,y_i\le 2000$。</p><p>T3：给一棵树，求给每个点赋权值 $[1,m]$ 的 $m^n$ 种方案，最大独立集的总和。$0\le n\le 2000$，$0\le m\le 10^8$。</p></blockquote><p>一开始断定 T1 是可做题，然后尝试 KMP、Manacher、字符串哈希等，做了两小时发现读错题了（读成结束在点 $(2,n)$），没有快速地挽回，打 50 pts 跑路。</p><p>断定 T3 是不可做题，打了最低档暴力 11 pts 跑路。</p><p>T2 非常有想法，觉得是 $O(2000^2)$ 枚举第一条边的向量，然后按这样形成正方形四个点的方位，把原 $n$ 边形复制平移 4 份，求交的格点数。那就只要把横坐标离散化，然后上……上什么呢？</p><p>怎么是上类欧啊？？？怎么是半平面交啊？？？</p><p>然后就开始推一万年没推过的类欧和尝试简化半平面交了。先冲了一会长方形 10 pts ，嫌 $O(500^3)$ 档分有点繁琐（其实好写的要命）就接着推三角形。等到还剩十几分钟才推上正路，刚要把修正后的类欧交上去，就撞上结束页。</p><p>丢人场。首先没有把签到题搞出来，然后没有把有思路题的部分分打够，状态完全不在，跟一模感觉差不多。</p><p>出场发现 T1 纯纯签到，T2 原来可以用 Pick 定理，小丑竟是我自己？</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p><em>2024.5.14.</em></p><p>由吉老师上课，讲“自动 AC 机”：其实是让电脑写算法的领域。既基础又有意思，挺好的。但是没有抢到回答问题的机会，没能拿到 pku 校徽，呜呜。</p><blockquote><p>T1：给一个由点 $1\sim n+1$ 组成的 DAG，点 $1\sim n$ 每个都有两条出边指向 $f<em>{i,0/1}$，且 $i&lt;f</em>{i,0/1}\le n+1$。对点 $1\sim n$ 每个维护 0/1 变量 $b<em>i$。假设有一个货物，初始在点 $1$，在每个点就走向 $f</em>{i,b_i}$，然后 $b_i$ 取反，直到货物到达点 $n+1$ 就终止。输入 $f,b$，输出最小的 $t$，满足 $t$ 个货物经过后，$b$ 变回原样。</p><p>T2：给一个长为 $n$ 的二元组序列 $(l<em>i,r_i)$，$q$ 次询问，每次询问给出 $(L_i,R_i)$，求 $f</em>{R<em>i}(f</em>{R<em>i-1}(\ldots f</em>{L<em>i+1}(f</em>{L_i}(0))))$，其中 $f_i(x)=x+[x\in [l_i,r_i]]$。$0\le l_i,r_i\le n$，$1\le L_i,R_i\le n$，$n\le 10^6$。</p><p>T3：给 $n,m,q$ 和一个随机数生成种子，用 <code>std::mt19937</code> 均匀随机生成 $n$ 点 $m$ 边的有向图，并 $q$ 次询问，每次问 $s_i$ 到 $t_i$ 的最短路。$n\le 2\times 10^5$，$m\le 3\times 10^6$，$q\le 10^4$。</p></blockquote><p>我不知道为什么就瞪出来 T1，可以用 $c_i$ 表示货物经过点 $i$ 向两个支路各走了 $c_i$ 次，然后可以用 $c_1$ 表示所有 $c_i$，令所有 $c_i$ 为整即可，答案就是最大的 $c_i$ 的分母 $\times 2$。为什么就瞪出来了？为什么写个 <code>std::deque&lt;bool&gt;</code> 一遍就过了？啊？此时过了 1h。</p><p>T2，一开始觉得是线段树，想不通又觉得是分块，又想不通信息的合并，又觉得是平衡树，又感觉很难维护。然后突然想起来可以算每个点的贡献，然后调了 1h 主席树，然后发现自己小丑，然后把可持久化删了，然后就过了？啊？此时过了约 2.5h。</p><p>T3 断定不可做，先把白送的 5 pts 拿了，然后写了这样的骗分：随机若干个点 $p$，跑它为源的最短路和反图最短路，用 $d’_s+d_t$ 更新每个答案，然后就莫名其妙过了一个 10 pts 的 subtask，是 $m\le n$。莫名其妙。在冲 $n\le 3000$ 的 15 pts Subtask，很诱人，胡了一个随机选中转点跑 Floyd 的东西，卡不过去，有点坐牢。</p><p>达成成就：第二天的分数高于第一天的三倍。</p><p>但凡第一天来点感觉，整个的分数就很稳了。哎。</p><p>听说 T3 可双向 Dijkstra，考场上居然没想到，不太行。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Luogu P10309 「Cfz Round 2」Max of Distance</title>
    <link href="/sol-LGP10309/"/>
    <url>/sol-LGP10309/</url>
    
    <content type="html"><![CDATA[<h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>给定一棵包含 $n$ 个结点的树和一个整数 $E$。构造树中每条边的整数边权 $w<em>i(1\le w_i\le 10^9)$，满足均匀随机选择一个结点 $u$，$\max\limits</em>{v=1}^n\operatorname{dis}(u,v)$ 的期望对 $998244353$ 取模的值等于 $E$；或报告无解。$2\le n\le 10^5$，$1 \le u_i,v_i \le n$，$0\le E &lt; 998244353$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们发现题目中的关键点既有 $\max$，又有期望，还有取模。就可以猜这个 $\max$ 是这其中关键要着手的。</p><p>一般地，树上的 $\max\limits_{v=1}^n\operatorname{dis}(u,v)$ 取到的 $v$ 是一个直径的端点，是一个叶子；那么，我们就直接钦定一个 $v$，让其他点都是到 $v$ 最远，而 $v$ 走直径就可以了。</p><p>具体的办法就是，随便选一个叶子 $v$，把与 $v$ 相连的唯一一条边设定一个 $\ge n$ 的权值，而其他的边权都设为 $1$。接下来只需要求出这个权值 $w$。</p><p>由题意，我们有 $w+\frac{1}{n}(\max<em>{u\neq v} d_u + \sum</em>{u\neq v} d_u)\equiv E\pmod {998244353}$，其中 $d_u$ 表示以 $v$ 为根，$u$ 点的深度 $-1$。</p><p>$d$ 可以直接通过 dfs 求出来，那么 $w$ 也就容易得到了。</p><p>最后为了确认满足这条边必走，如果 $w&lt;n$，就让 $w$ 加上 $998244353$，这样也不会超出 $10^9$。</p><p>由以上的构造，可以发现恒有解。</p><p>时间复杂度 $O(n+\log V)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">100005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DVS = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> N, deg[MXN], eid[MXN], E, spid, mxd, diff;<br>vector&lt;<span class="hljs-type">int</span>&gt; to[MXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> f, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>  mxd = <span class="hljs-built_in">max</span>(mxd, d);<br>  <span class="hljs-keyword">if</span> (f != <span class="hljs-number">-1</span>) diff = (diff + d - <span class="hljs-number">1</span>) % DVS;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q : to[p]) &#123;<br>    <span class="hljs-keyword">if</span> (q == f) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">dfs</span>(q, p, d + <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">p</span><span class="hljs-params">(DVS - <span class="hljs-number">2</span>)</span>, <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">while</span> (p) &#123;<br>    <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>) a = a * <span class="hljs-number">1LL</span> * x % DVS;<br>    x = x * <span class="hljs-number">1LL</span> * x % DVS;<br>    p &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    --x, --y;<br>    ++deg[x], ++deg[y];<br>    eid[x] = eid[y] = i;<br>    to[x].<span class="hljs-built_in">push_back</span>(y);<br>    to[y].<span class="hljs-built_in">push_back</span>(x);<br>  &#125;<br>  cin &gt;&gt; E;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (deg[i] != <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>    spid = eid[i];<br>    <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    diff = (diff + mxd - <span class="hljs-number">1</span>) % DVS;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  diff = diff * <span class="hljs-number">1LL</span> * <span class="hljs-built_in">inv</span>(N) % DVS;<br>  E = (E - diff + DVS) % DVS;<br>  <span class="hljs-keyword">if</span> (E &lt; N) E += DVS;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != N; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i == spid) cout &lt;&lt; E &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&#x27;1&#x27;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - GDOI 2024</title>
    <link href="/rec-2024gdoi/"/>
    <url>/rec-2024gdoi/</url>
    
    <content type="html"><![CDATA[<p>回到美丽的东莞中学松山湖学校。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p><em>2024.3.1.</em></p><p>试机，写了一下小白逛公园，确认自己还记得 vim 怎么用，然后跑路。（其实这题我至今没提交过）</p><p>开箱，精美的笔和笔记本，附一根笔芯。太精美了！这个礼盒。</p><p>NOIP 2023 T4 终于调出来，怨念解除。</p><p>你说的对，但是酒店 100m 就有商业街，「丰俭由人」。吃了西北菜。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p><em>2024.3.2.</em></p><p>三道题看起来都蛮吓人的。然后就打算按顺序开。</p><p>T1 端详了一下，然后发现 $\sum x’+y’$ 对每一个 $m\bmod n$ 而言都是分段一次函数，然后就做完了。不过总共调了 1.5h。</p><p>T2 冲了冲性质分，然后有想法，但是不太干净。最后还是觉得要二分，然后想了一个 01 Trie 上 DP 的做法，调了一场冲不过去。期间打了个 T3 Brute Force 和一点性质，15 min，然后回来调，还是冲不过去。$O(n^2k)$ 过不去第二个样例，T 飞。</p><p>期望得分随机。我打算对每个人说我 D1 301pts，以震慑。结果把自己尴尬到了，以后再也不这么干了。</p><p>离场拿了个牛角包，流心，是好的。</p><p>gf 似乎调出 T2，%%%。预测 gf 可以成为今年 lzoi 队爷。</p><p>和宅女 gyx 度过一个下午。怎么我以外的人都卷疯啦！</p><p>晚上吃了捞面。然后一起打三人麻将，输输。期间被抽到真心话，然而大家都没被套出什么有趣故事。</p><p>不打麻将的 wzj AK 了 ABC，并获得 rk68，可喜可贺，rp 暴增。</p><p>和 gyx 夜聊，把隔壁班除了三个女生以外的人全都说了出来，小赢。</p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p><em>2024.3.3.</em></p><p>前一天晚上有点晚睡，第二天早一点起来。收完东西，打算 10min 解决早餐。到达的时候教练才说 2min 后发车？？并且说前一天上下车都跟车里的人说了？I’m sorry？？？寒碜的 Q 群我是半句话没见到，QQ 都被嫌弃成这样了？</p><p>T1 本来猜跟昨天是不是相近难度，结果推了有点久，到 2.5h 的时候算法才基本定型，但是样例 2 直接错完了。</p><p>然后气得直接启动 T2，看了一眼打算搞 20pts，又想了想，似乎可以做 $k=0$，就 30pts 跑路。</p><p>T3，不可做。</p><p>然后调 T1，调小对，但是死活过不去最后一组样例。真不明白。随机拿分。</p><p>得知各位同学都切了今日 T1、T2，狠狠自卑了。不过大概尽力了吧，我还年轻呢。</p><p>其实反思一下，好像是有点苛求正解了，因为想完性质分就觉得正解已经涵盖了，所以没有格外去做保底。此外很快形成清晰思路的能力也不太够，于是代码调试的速度就过慢了，加以没耐心，所以无了。而且发现很容易在细节处纠结、可能还写错。唉。真不行。</p><h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p><em>2024.3.8.</em></p><p>$100+12+24+30+30+0=196$。</p><p>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈。</p><p>不会 D2T1。</p><p>就这样吧。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Luogu P8986 [北大集训 2021] 基因编辑</title>
    <link href="/sol-LGP8986/"/>
    <url>/sol-LGP8986/</url>
    
    <content type="html"><![CDATA[<h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>给定 $n,l,r(1&lt;l\le r&lt;n)$ 和长度为 $n$ 的正整数数列 $a(1\le a_i\le 10^6)$。一个数对 $(i,j)$ 合法，当且仅当：</p><ul><li>$1\le i&lt;l\le r&lt; j\le n$。</li><li>不存在 $i’,j’$ 使得 $a<em>i=a</em>{i’}$，$a<em>j=a</em>{j’}$ 且 $i\neq i’\lor j\neq j’$。</li><li>$a_i\neq a_j$。</li></ul><p>找出可能的最小 $j-i+1$。$1\le n\le 10^6$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于上面的第二个条件，我们这么转化：（可证明正确性）</p><ul><li>不存在 $i’&lt;j$，$i’\neq i$，$a<em>i=a</em>{i’}$。</li><li>不存在 $j’&gt;i$，$j’\neq j$，$a<em>j=a</em>{j’}$。</li></ul><p>它意味着：</p><ul><li>$j$ 在 $a_i$ 的头两次出现之间。</li><li>$i$ 在 $a_j$ 的末两次出现之间。</li><li>$i$ 是 $a_i$ 的第一次出现。</li><li>$j$ 是 $a_j$ 的最后一次出现。</li></ul><p>感性地理解，也就是这样的一对 $(a_i,a_j)=(x,y)$，分布形如 ${y,\ldots,y,x,y,x,\ldots,x}$。其中唯一的一组 $(x,y)$ 就是 $(i,j)$ 位了。</p><p>那么，我们枚举 $i<l$，只看所有末两次出现在 $i$ 两侧的 $a_j(j>r)$，然后检测这个条件下最小的 $j$ 是否在 $a_i$ 的头两次出现之间。而这里的 $j$ 可以逐个预处理，然后枚举的时候做一个前缀 $\min$。</p><p>时间、空间复杂度均为 $O(n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">1000005</span>;<br><span class="hljs-type">int</span> N, L, R, arr[MXN];<br><span class="hljs-type">int</span> fir[MXN], fir2[MXN], lst[MXN], lst2[MXN], mnr[MXN], cmr, ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N &gt;&gt; L &gt;&gt; R;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != MXN; ++i) fir[i] = fir2[i] = N + <span class="hljs-number">1</span>;<br>  mnr[<span class="hljs-number">0</span>] = N + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) &#123;<br>    cin &gt;&gt; arr[i];<br>    lst2[arr[i]] = lst[arr[i]];<br>    lst[arr[i]] = i;<br>    <span class="hljs-keyword">if</span> (fir[arr[i]] == N + <span class="hljs-number">1</span>) fir[arr[i]] = i;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fir2[arr[i]] == N + <span class="hljs-number">1</span>) fir2[arr[i]] = i;<br>    mnr[i] = N + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(R + <span class="hljs-number">1</span>); i &lt;= N; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i == lst[arr[i]]) mnr[lst2[arr[i]]] = <span class="hljs-built_in">min</span>(mnr[lst2[arr[i]]], i);<br>  &#125;<br>  cmr = mnr[<span class="hljs-number">0</span>];<br>  ans = N + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt; L; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i == fir[arr[i]] &amp;&amp; cmr &lt; fir2[arr[i]]) ans = <span class="hljs-built_in">min</span>(ans, cmr - i + <span class="hljs-number">1</span>);<br>    cmr = <span class="hljs-built_in">min</span>(cmr, mnr[i]);<br>  &#125;<br>  cout &lt;&lt; (ans == N + <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : ans) &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - QOJ 7766 栞</title>
    <link href="/sol-QOJ7766/"/>
    <url>/sol-QOJ7766/</url>
    
    <content type="html"><![CDATA[<h2 id="简述题意"><a href="#简述题意" class="headerlink" title="简述题意"></a>简述题意</h2><p>对于 $1\sim n$ 的排列 $p$，定义 $f(p)$ 为把 $p$ 划分为 $k$ 连续段后每段分别排序、其中所有划分方法中所可能达成的字典序最小的排列。给定 $f(p),k$，数 $p$ 的个数。$1\le k\le n\le 500$。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>令 $f(p)=q$。</p><h3 id="刻画-f-函数的过程"><a href="#刻画-f-函数的过程" class="headerlink" title="刻画 $f$ 函数的过程"></a>刻画 $f$ 函数的过程</h3><p>既然求字典序最小的排列，首先要 $q<em>1$ 最小。$q_1=\min</em>{1\le i\le n-k+1}p_i$。（这个上界是因为剩余的 $k-1$ 段非空）</p><p>接着要 $q_2$ 最小，就是把 $q_1$ 屏蔽掉后的最小值。</p><p>逐位考虑 $q_i$。以第 $i$ 个数为止分段的条件是：$q_1\sim q_i$ 恰好落在 $p$ 的 $1\sim i$ 位。</p><p>在前面能分段就分段，后面部分段数变少，字典序不增。而且既然已经分段，说明 $a<em>{i+1}\sim a</em>{n-k+1}$ 都大于 $a_1\sim a_i$，所以也不会变劣。综上可说明此刻画正确性。</p><h3 id="部分分：-q-i-i"><a href="#部分分：-q-i-i" class="headerlink" title="部分分：$q_i=i$"></a>部分分：$q_i=i$</h3><p>则 $p$ 可被划分为至少 $k$ 段，其中每段 $p_l\sim p_r$ 排序后恰好为 $l\sim r$。（即题意）</p><p>考虑记 $f_{i,j}$ 为满足这样条件的 $i$ 阶排列个数：它最多刚好可以被划分成 $j$ 段，使每段 $p_l\sim p_r$ 排序后恰好为 $l\sim r$。</p><p>对于 $f<em>{i,1}$ 的计算，方法多样，其中一种是考虑任意 $i-1$ 阶排列的第一个 $x$ 满足 $p_1\sim p_x$ 排序后恰好为 $1\sim x$。要在值域中插入一个数使得 $j=1$，则必有 $p’_i&lt;p’_x$。所以有 $f</em>{i,1}=\sum<em>{1\le x\le i-1}f</em>{x,1}x(i-x-1)!$。</p><p>对于其他 $f<em>{i,j}$，直接 $f</em>{i,j}=\sum<em>{1\le x\le j}f</em>{x,1}f_{i-x,j-1}$ 即可。（也就是生成函数卷积）</p><p>答案则为 $\sum<em>{k\le i\le n}f</em>{n,i}$。</p><h3 id="一般的-q"><a href="#一般的-q" class="headerlink" title="一般的 $q$"></a>一般的 $q$</h3><p>由上文对 $f$ 函数过程的刻画，可知一旦选中一个 $p<em>{n-k+1}$，这一段以后每一段长度只能为 $1$。只要没有选中，由于 $p_1\sim p</em>{n-k}$ 总是在 $\min$ 备选范围里面，所以假设选中的是 $t=n-k$，则有 $\forall 2\le i&lt;t,p<em>{i-1}&lt;p_i$。然而选完 $t$ 之后，出于同样的原因，仍有 $\forall i\ge t,p_i&lt;p</em>{i+1}$，并且 $p<em>{t-1}&lt;p</em>{t+1}$（在对应元素存在的前提下）。然而不保证 $p_{t-1}&lt;p_t$。</p><p>所以第一个出现 $p<em>{i-1}&lt;p_i$ 的 $i$ 只能是 $t$（如果存在）。于是我们找到 $t’$（如果存在），它是 $t$ 之后的第一个满足 $p</em>{t’-1}&gt;p_t$ 的位置，这个位置开始每一段长度只能为 $1$。换言之，$[t,t’)$ 是最后一段长度可能不为 $1$ 的分段，而且这必须是一段。</p><p>整理一下，整个序列应该形如这样：$[1,t)$ 是一个递增序列，被分成若干段；$[t,t’)$ 是一个递增序列，若它长度不为 $1$ 则必有 $p<em>{t-1}&lt;p</em>{t+1}$，并且这一区间独立成段；$[t’,n]$ 是若干长度为 $1$ 的段。</p><p>所以我们找到 $t$（在非部分分情况下必然存在）后，枚举每个 $t’$，对应的贡献就是 $f_{t,k-(n-t’)}(t’-t-1)!$（$[t,t’)$ 可以任意排列，$[1,t)$ 如部分分所示），求和即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码中下标从 $0$ 开始，并且有若干命名和操作与公式等效而不同名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">505</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DVS = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> N, K, arr[MXN], cnt[MXN][MXN], Pt, ans;<br><span class="hljs-type">bool</span> type;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N &gt;&gt; K;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) cin &gt;&gt; arr[i], --arr[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != N; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i - <span class="hljs-number">1</span>]) &#123;<br>      Pt = i + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (Pt != N &amp;&amp; arr[Pt] &gt; <span class="hljs-built_in">max</span>(arr[Pt - <span class="hljs-number">2</span>], arr[Pt - <span class="hljs-number">1</span>])) ++Pt;<br>      type = <span class="hljs-number">1</span>;<br>      K -= N - Pt + <span class="hljs-number">1</span>;<br>      N = i;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (K &lt;= <span class="hljs-number">0</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  cnt[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">2</span>); i &lt;= N; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(i - <span class="hljs-number">1</span>), <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>); j &gt;= <span class="hljs-number">1</span>; f = f * <span class="hljs-number">1LL</span> * (i - j--) % DVS) &#123;<br>      cnt[i][<span class="hljs-number">1</span>] = (cnt[i][<span class="hljs-number">1</span>] + cnt[j][<span class="hljs-number">1</span>] * <span class="hljs-number">1LL</span> * f % DVS * j) % DVS;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">2</span>); j &lt;= i; ++j) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">1</span>); j - <span class="hljs-number">1</span> &lt;= i - k; ++k) &#123;<br>        cnt[i][j] = (cnt[i][j] + cnt[i - k][j - <span class="hljs-number">1</span>] * <span class="hljs-number">1LL</span> * cnt[k][<span class="hljs-number">1</span>]) % DVS;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (type) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != Pt - N; ++i) &#123;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">t</span><span class="hljs-params">(cnt[N][K - i])</span></span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">1</span>); j &lt;= Pt - <span class="hljs-number">1</span> - N - i; ++j) t = t * <span class="hljs-number">1LL</span> * j % DVS;<br>      ans = (ans + t) % DVS;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(K); i &lt;= N; ++i) ans = (ans + cnt[N][i]) % DVS;<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - PKUWC 2024 &amp; WC 2024</title>
    <link href="/rec-2024pkuwc-2024wc/"/>
    <url>/rec-2024pkuwc-2024wc/</url>
    
    <content type="html"><![CDATA[<p>大概是初中阶段最自由、最刺激的一个寒假。</p><h2 id="Day-0-20240125"><a href="#Day-0-20240125" class="headerlink" title="Day 0: 20240125"></a>Day 0: 20240125</h2><p>出发前，应 lzqy 拉我一把，<strong>加了一个约饭群</strong>。划重点，要考的。</p><p>飞机，同行的人有教练，还有 <a href="https://www.luogu.com.cn/user/288716">lzqy_</a>、<a href="https://www.luogu.com.cn/user/428908">wzj33300</a>、<a href="https://www.luogu.com.cn/user/554574">gyyyyx</a>。在机场和 <a href="https://www.luogu.com.cn/user/279646">mod998244353</a> 汇合。</p><p>到达重庆，机场快线的一路上首先是一段山路，让人想起跨市高速，在广州城内想是断然不会的。走了一段，忽而来了一座高山，然后路途便分成若干条立交桥，触手一般四散开去。然后就是重庆的城了。真乃立体城市！马路时有上下坡，且九曲十八弯。未曾见过有哪个城市立交桥如此多而繁复的。当车行到河上时，桥之高与滩之低形成多么壮观的落差！下了大巴要走去酒店，沿着导航却走到不存在的途径，最终不得不绕一个大圈。后来想来，导航毕竟是二维的，重庆乃是三维的。途中看见一所重度医科大学附属医院……啊，那不是度，是庆的繁体慶。</p><p><img src="https://s2.loli.net/2025/08/31/Jy6fZreH1gTsIlL.png" alt="rec-2024pkuwc-2024wc-1.png"></p><p>吃碗“微辣”的豌杂面，就要跟着大家去巴蜀中学校（除了我以外都报了 THUWC），期待与群友面基。对着群里一张 Phigros 暂停的照片，居然看到有两个本校学生玩双人 Phigros，乃是 Igallta AT。另一位旁观者一直劝阻。我向旁观者询问是不是其人，<a href="https://www.luogu.com.cn/user/556042">旁观者</a>似乎不知情，并且称其中一位玩家为 lulu。后来才知道，这是小 l。</p><p>在板凳逐渐聚拢起一群人，我想是不是群友，经过推断八成是了，但是过于社恐，不敢打招呼。过了会跟着 lzqy 和他们一块从后山走到开封菜。面到了：</p><p><img src="https://s2.loli.net/2025/08/31/WImH1gYD4cielQk.png" alt="rec-2024pkuwc-2024wc-2.png"></p><p>回到酒店，浴室门和厕所门半透明，且外面不再有任何遮挡，值得辱骂。</p><p>一起沿滨江路散步，看景，聊八卦。并走了个旁边的、爬山一样的路途，lzqy 买了些文创品，并且都买了瓶汽水。</p><p><img src="https://s2.loli.net/2025/08/31/uzEHyxAKGOQ1rhp.png" alt="rec-2024pkuwc-2024wc-3.png"></p><h2 id="Day-1-20240126"><a href="#Day-1-20240126" class="headerlink" title="Day 1: 20240126"></a>Day 1: 20240126</h2><p>不知道是哪个营完全没有纪念品。也不知道是谁是全校唯一一个去这个营的人。</p><p>上午查询育才中学校和陶行知的关系，然后睡觉，然后合照，然后试机，然后吃饭，然后睡觉。</p><p>试机时的一个特判，要原封不动地输出，结果先输出再输入，我真唐吧。</p><p>下午发现上午试机后没关机，<code>.vimrc</code> 不用重写，试机代码还在，好吧。</p><p>简述题意：</p><blockquote><p>A: 给一个只有 <code>L</code> 和 <code>R</code> 的字符串。Alice 和 Bob 博弈，拿到空串者输，否则选择一个字符，如果是 <code>L</code> 就保留其左边的前缀（不包括），否则保留其右边的后缀（不包括）。求最优策略下胜者。$1\le |S|\le 10^6$。</p><p>B: 对于长为 $n-1$ 的非负整数数组 $a$，定义长为 $n$ 的数组 $f$ 满足 $f<em>i=\sum</em>{1\le j\le i-1}\min<em>{k\in[j,i-1]} a_k+\sum</em>{i\le j\le n-1}\min_{k\in[i,j]} a_k$。给定 $f$，构造一个 $a$ 或报告无解。$2\le n\le 80$，$0\le f_i\le 10^8$。</p><p>C: 给一个下标在 $[1,2^h-1]$ 的、数是两两不同的正整数的完全二叉堆 $a$，给出删除一个堆中一个节点删除（表现为值置为 $0$）并下沉的形式化描述。并且维护两个点集 $s_1, s_2$。$q$ 次操作，每次操作是往某个点集里加入某个数或从中删除某个数（保持 $s_1\cap s_2 = \varnothing$），或查询有多少个点集 $s$，满足 $s_1\subseteq s\subseteq s_1\cup s_2$，并且在使得 $\forall p\in s,a_p\not = 0$ 且 $\sum a$ 最小的结果中（<strong>题目强调这样的结果堆是唯一的</strong>）$a_x=z$（单次询问中给定 $x,z$）。$2\le h\le 18$，$1\le q\le 5\times 10^5$，$1\le a_i\le 10^6$。</p></blockquote><p>看了一下，没有明显可做题。先写 A 暴力，然后手造几组样例，然后猜结论是如果 $S$ 是一个把 <code>R</code> 作为左括号、<code>L</code> 作为右括号的合法括号序列，就是 Bob 赢，否则 Alice 赢。然后就过了。</p><p>B 感觉太难做了，多拿一点部分分都难。一开始以为可以 $n!$ 枚举大小顺序然后高消，结果不会处理无限组解的 case。所以打了 11 pts 纯暴力就跑路了。</p><p>想磕 C。觉得策略大概是，从上往下 pop，如果本次 pop 会破坏性质，就不再 pop，然后递归到儿子。我好像感受到某种结构，但是没有抓住它。最后打了 20 pts 暴力枚举每种 $s$ 预处理。</p><p>以上过程基本就是颓一会然后写一会，所以非常久，足花了 3h，反正最后 1h 也啥都做不了，只是再证了一下 T1 说法的正确性，然后接着颓。</p><p>由于一开始网炸了，考试延迟结束 5 min。快结束时突然发现 C 还有 20 pts 是每次询问可以单次模拟，且 $s_2$ 总为空集，大意了，差点白丢分了。然后就是继续颓，直到考试结束。颓的方法是趴在桌子上，往草稿纸上写我能想起来的一切信息片，名字就力图写好看，或者是某些汉字、或英文字母、曲名等。</p><p>晚上吃家常菜，大家怎么都不吃水煮牛肉啊，大家怎么都不吃糖拌番茄啊，怎么不吃糖拌番茄然后觉得辣啊。</p><p>在酒店 22 楼出去，结果发现这个天台正连接重庆医科大学附属医院的楼……并且，讲真，22 楼的景色和 1 楼一样。</p><p>然后就是，给尺子姐姐送女装（lzqy 斥巨资采购）……嘿嘿……图像就不放出来了……</p><p>结果发现错过鸽游直播，真不行。去看了看榜，对于一些高名次……感觉真不行。</p><p>晚上完成德育作业，被评为唐。又熬夜了。</p><h2 id="Day-2-20240127"><a href="#Day-2-20240127" class="headerlink" title="Day 2: 20240127"></a>Day 2: 20240127</h2><p>上午演讲，讲一些计算机语言的东西。其中推荐了 SICP 和《七周七语言》，然而这之后我就昏昏然睡了……</p><p>午餐有一个橙子、五个草莓，还有一瓶草莓味奶，这是 jao 的。</p><p>简述题意：</p><blockquote><p>A: 给定 $n$ 个一位小数满足 $0&lt;a_i&lt;10$，每次可以将其中两个数相加后放回去、或者把一个数四舍五入后放回去，直到最后只剩一个数，以这个数四舍五入的结果为结果，求结果的最大值。多组数据，$\sum n\le 10^6$。</p><p>B: 给定 $n,m$ 和一个递减正整数序列 $d$，满足 $d_1\le 10,d_m=1$。求以 $d$ 为步长序列，$1\sim n$ 的排列进行希尔排序的交换次数的最大值，以及取到最大值的排列个数。$1\le n\le 30$。</p><p>C: 要维护 $n$ 个初始为空的栈，进行 $m$ 个操作。有三种操作：一是区间 push $x$ 个 $y$，二是区间 pop $x$ 次（若空则不操作），三是单栈询问第 $p,q$ 位的和（不存在视为 $0$）。$1\le n,m\le 10^5$，$1\le x,y\le 10^5$，$1\le p,q\le 10^{10}$。</p></blockquote><p>没有明显可做题。先推推 A，发现只考虑小数位，并且只考虑初始是 1 到 4 的位，并且已经不小于 5 的会直接去四舍五入。一开始嗯算，反应了一下才发现可以由多个相加然后四舍五入。然后分讨，拍，假，然后严谨化算法，发现可以小范围 dp。考虑到这一步，我已经拿下 $n\le 12$ 和 $a_i=0.2k,k\in \mathbb{Z}$ 的 56 pts，剩下的不知道为什么错。继续卡，卡到 3.5h，不甘心，但是真的快没时间了。</p><p>B 感觉不可做，18 pts 暴力跑路。C 看出了 55 分部分分，是暴力+扫描线+吉司机线段树。于是嘲讽自己花那么多时间却 A 不了 A。最后只调完了最低档的暴力 18 pts，不再有时间了。应该没人比我低分了。</p><p>晚上嗦酸辣粉，相当不错！然后和 mod998244353 和 gyyyyx 联机 MC，第一次屠龙速通，mod998244353 带飞，\%\%\%。然后在寻找末地城的途中 wzj33300 加入，用床把全部人炸出末地了，就不玩了。</p><h2 id="Day-3-20240128"><a href="#Day-3-20240128" class="headerlink" title="Day 3: 20240128"></a>Day 3: 20240128</h2><p>短暂的休息。</p><p>和 lzqy、gyyyyx 一起去了北仓转，看文创品，那里非常安静。我们在那里转圈。吃完饭就开始出北仓，在附近乱转，所谓 citywalk。直到说累了，就回酒店，跟 gyyyyx 最后玩一玩，他要走了。</p><p>晚上跟随 lzqy 去晚餐，面到 xht、尺子、shinzanmono、CYJian。期间没有反应到 xht 是 PKUWC 监考，脸盲真不可取。红衣帅气大学生，怎么可以记不起呢。然后就是 xht 请茶颜悦色，味道很好。回来路上买了 6 个竹子上爬熊猫的玩偶（但是这不应该是在成都买的吗？），打算分给我的舍友。</p><p><img src="https://s2.loli.net/2025/08/31/cxjewiSLD4ErbtC.png" alt="rec-2024pkuwc-2024wc-4.png"></p><p><img src="https://s2.loli.net/2025/08/31/o8YBFTchA3lpdxn.png" alt="rec-2024pkuwc-2024wc-5.png"></p><p>晚上聊天，把 lzqy 聊尴尬了，嘿嘿嘿。最后想补点题，但是怎么也没想清楚。并且又熬夜了。</p><h2 id="Day-4-20240129"><a href="#Day-4-20240129" class="headerlink" title="Day 4: 20240129"></a>Day 4: 20240129</h2><p><img src="https://s2.loli.net/2025/08/31/3x9DX7yZkf4CaFg.png" alt="rec-2024pkuwc-2024wc-6.png"></p><p>发的有外套，小背包，还有一大本讲义，真牛吧。</p><p>在宿舍打音游。然后去操场溜了一圈，发现三个引体向上都做不了了，真不行。</p><p>第一次留意到育才有国际象棋棋盘，那种立体的、大的。cfz 就在旁边，穿着黑丝、裙子，被大家簇拥着。自己就在外面一圈找一个地坐了打音游，Destruction 3,2,1 AT acc 达到 99.54%，rks 达到 15.94，很好。</p><p>育才美食。</p><p>开幕式太多乐子了，“尊敬的子德主席”“冬奥会”还有一两处非常精神的语气……加上群友的复读，全程绷不住，从歌舞笑到讲话再笑到最后。</p><p>去了教室走一转，看到猫猫。</p><p><img src="https://s2.loli.net/2025/08/31/eYLgKTahmHRDJIE.png" alt="rec-2024pkuwc-2024wc-7.png"></p><p>然后再回去棋盘边上打了会音游。本来以为有音趴。下面也的确还有人打，一个打 4k 的，一个玩蛇的，旁边一个写代码的。期间有个女的看了看，骂了句脏话然后走了。难评。</p><h2 id="Day-5-20240130"><a href="#Day-5-20240130" class="headerlink" title="Day 5: 20240130"></a>Day 5: 20240130</h2><p>上午 lxl 讲持久化数据结构，非常可爱！我所了解到新的东西有：肥节点（虽然很难写），节点分裂（虽然很没用），斜二叉堆（虽然还没会完而且也有点没有）。另外，两棵一样的 AVL 树合并，为什么是 $O(1)$ 的？</p><p>下午 xtq 讲 OI 在 TCS 中的运用，目的是为了告诉我们持久化数据结构也没那么难。不过看出来 xtq 非常有学术精神，\%\%\%。</p><p>下午跟 ztx 去跑圈。我一开始也慢跑，后来沉不住气，越跑越快，很快已经很累，不能负担得起原来的体能消耗了。于是怀疑自己是不是平时也是由于心浮气躁，且体能不足，所以好多东西太难持之以恒下去。去饭堂路上偶遇一位大佬弹钢琴，非常熟练，\%\%\%。</p><p>晚上营员交流，怎么人均会 Top Tree 啊。除了 ducati 听起来用处有点局限的新 technique、fzw 有实用性的数据结构合并时间复杂度分析，其他的全都没听懂，听一半跑路了。</p><h2 id="Day-6-20240131"><a href="#Day-6-20240131" class="headerlink" title="Day 6: 20240131"></a>Day 6: 20240131</h2><p>上午 qlr 讲题，难度亲民，讲的也非常透彻！</p><p>但是线上的同学反映没有声音，麻烦解决一下我没有说话的问题。</p><p>但是电脑突然无法开机。</p><p>打了打乒乓球。</p><p>下午讲量子计算相关，完全没心情，但是还不能直接离校，翘了四处走了走消磨时间。</p><p>感觉育才的水龙头有点蠢了，手全是水，抹完香皂，怎么拧不带把的水龙头？</p><p>晚上试机，是 NOIP2021，写完了 T1、T2 就跑路了。归程看见 qlr 和 xtq 大战国际象棋，qlr 胜。</p><h2 id="Day-7-20240201"><a href="#Day-7-20240201" class="headerlink" title="Day 7: 20240201"></a>Day 7: 20240201</h2><p>前一天晚上梦见在夜晚，一个离冼村一站的 18 号线地铁站，徘徊到底是进去还是在外面搭乘其他交通工具回去（我似乎很喜欢交通的场景）。最后好像没有进去，但是走了一段路就发现决策错了，但不再回头。</p><p>打到一辆车，司机是个壮士，但他提醒我绝对不要回头。那里大概是城中村一类，所以很有理由。然而出于好奇心，我还是回头了一下，看到一辆车在尾随，回头的一刹它突然撞来。我便把头埋下来，似乎是惊恐。这时车停了，司机下来同他大声对抗。他说回头看的都把手举起来，我并没有，于是后面那人忿然走了。</p><p>梦的后半段就不太明确了，只记得我似乎在翘文化课。想是有点关联。</p><blockquote><p>A：给 $n$ 个正整数对 $(a_i,b_i)$。对于其的一个子集 $S$，先按原顺序列出 $S$ 中元素，再按原顺序列出 $S$ 外元素，形成的数组中最长的满足 $\sum a\le T$ 的前缀中 $\sum b$ 就是对应的价值。求所有集合对应的价值的总和。$n\le 200,T\le 3\times 10^5$。</p><p>B：给一个长度为 $n$ 的正整数数列 $h$，求出长度不小于二且存在正实数 $l$ 使得可以把若干 $h_i$ 变为 $l-h_i$，使区间内 $h$ 值递增，这样的区间数目。$h_i\le 10^{12},n\le 3\times 10^5$。</p><p>C：给一棵特定形态的线段树，维护的序列长为 $n$；还有 $m$ 个区间。要求数有多少个节点集合，满足确定了这些节点的值后这 $m$ 个区间的和也被确定。$n,m\le 2\times 10^5$.</p></blockquote><p>A 卡了一会，一开始感觉要算贡献，但没有马上怎么推。其他路没走通后推一推贡献就做完了。此时8:47，样例过完。</p><p>B 可见的双指针，但是判定却想得很繁琐，要维护最后一个点两种策略分别的 $l$ 的取值范围。一开始猜连续，推了一推发现假了。不想写 STL，最后写了单次判断 $\frac{n^2}{w}$，双指针也没意义了，总共 $O(\frac{n^3}{w})$。</p><p>C 花了很久，认真推了一个树形 DP，然后把 1、2、3、4、8 组样例过了。打开第 5 组样例，绝望的发现树形 DP 没有前途，因为我永远不知道我到底要目标区间作为谁的子集。只是这种策略则特殊性质下倒是符合的。</p><p>但是我是蔡队的粉丝！！！</p><p>下午出分，$100+44+20$，$O(\frac{n^3}{w})$ 冲过 $n=4000$，神圣 0.907s 之力，赢。</p><p>对 lzqy 来说，这则是超低发挥了。</p><p>听完题，知道了 B $O(n)$ 做法，突然就很懊悔。我想过双指针，但是没想起来 Baka’s trick。我想过在峰点和谷点拎出来讨论，却没有乘胜追击把条件简化。就差一步。差一步。</p><p>晚上是文艺汇演，一开始是育才中学的歌舞，怎么都是女的啊，音响有点吵了。</p><p>留下最深印象的是五哥的串词，节目效果拉满了！笑不停。谁是卧底节目效果也好满，我到最后都没有猜到卧底，原来他早已看破：“LCP=1.”后来一首原神温迪歌曲真的很喜欢！音准、节拍都非常在线，除了高音气息不太稳（哎，我何尝不是这个问题）。以及 Kubic 演唱的《人是_》属实全场最佳了（除了开头的失误），副歌音色太好了。感觉最期待的 dottle《我的又一个机器人朋友》演讲冲击力不如 coffee_zzz《我的一群机器人朋友》演讲。然后就是难忘今宵之《蜂鸟》。别的都没有很深的印象。</p><p>钦佩组织者 skc 领导！</p><h2 id="Day-8-20240202"><a href="#Day-8-20240202" class="headerlink" title="Day 8: 20240202"></a>Day 8: 20240202</h2><p>前一天晚上的梦，背景大概是某个废旧车库之类的，梦见很多同学，印象上很 happy。梦见 gyyyyx。梦见一个小学女同学，梦里好像她中考成绩就是我的目标成绩来着（我甚至还记得我的期末考成绩），尤其是那个物理成绩（她似乎弱项在理科来着）。我在乎导致的。</p><p>上午 EI 的课，非常听不懂，但是非常认同 EI 的数学审美。</p><p>下午跟着教练出去修电脑。店员说把显示屏的线重接了一下。本来想假戏真做（我们请的是看耳朵的病假），结果去了重医附一院，挂个号，出来 16:45~17:00，果断离场，只是可惜白费的 ¥15 了。回来接着听 He_Ren 讲题，一回来就是一道重磅 FFT，各种天花乱坠的性质。往后面还是很难，魄力，唉，魄力。还是觉得 He_Ren 很擅长讲，节奏把控挺不错的。</p><p>晚上不听困难的集训队交流，写完美的队列，写了很久才过，很多细节都要厘清楚，最后发现 bug 是 <code>rk[k]</code> 写成 <code>k</code>，真小丑。一道思路这么清晰的题目写了 2h，唐完了。此外，电脑修好了，耳机一边的套却不见了，这就是我想要的吗。</p><p>还看到若干 PKUWC 游记，有人 Day2 $56+55+55$ 翻盘，我的偶像！</p><h2 id="Day-9-20240203"><a href="#Day-9-20240203" class="headerlink" title="Day 9: 20240203"></a>Day 9: 20240203</h2><p>前一天晚上梦见一个 whk 同学，另还有化学老师给我讲题来着。</p><p>上午 csy 讲随机化和近似算法，相当困难，IOI 两题讲的有点急，最难到低密度 01 背包、卡字符串滚动哈希，但是也有有趣的随机化题目。很符合我对理工男的想象。</p><p>中午更新 Phigros，性了 G.V.N.，Crush Beta 不太想打。</p><p>下午“计算机与教育漫谈”，意料之中的大量爆梗，但的确是有真知灼见、有眼界。我想，像我经常思考老师的问题，也许以后我也会选到和讲者相似的研究方向呢。佩服讲者的最高语速。顺便把 G.V.N. 收了，我是咸盐的忠实粉丝，嘿嘿。</p><p>晚上先打了个上下界流板子。启动 ABC，卡 F 了。一开始以为 FFT，发现单次点乘太慢，但是没往模数想，觉得模数应该很容易被卡。然后又以为根据相乘长度相加，有一些均摊，失败了。结果是随机模数，20-哈希。……</p><h2 id="Day-10-20240204"><a href="#Day-10-20240204" class="headerlink" title="Day 10: 20240204"></a>Day 10: 20240204</h2><p>上午国家队答辩，zak 略显紧张，Kubic 稳得不得了，花花被 dzd 锐评英语不好，Rainbow_qwq 获得首个 dzd“我没有问题”，skc 一直强调自己的组织能力（我后来感觉这一点会不会有点扣分），cxy 是第二个 dzd“我没有问题”。</p><p>最后的国家队队员是 zak、Kubic、花花、Rainbow_qwq，祝贺！但是 skc\ll。</p><p>下午闭幕式，哦，原来银牌线 169，我 164 啊。好的。\%\%\% lovely_ckj，\%\%\% wtc。\bx。</p><p>晚上瞪 WC T2，的确没有瞪出来，罪有应得了。ARC，T2 一开始有个细节漏了，瞪了一会才瞪出来；T3 卡了比较久，想怎么构造双射，然后设一下 $f_{i,0/1}$，好像可以做，然后就做完了。T4 没时间了，赛后一下子补完了。</p><p>此外，不记梦是因为好像没做梦。</p><h2 id="Day-11-20240205"><a href="#Day-11-20240205" class="headerlink" title="Day 11: 20240205"></a>Day 11: 20240205</h2><p>前一天晚上比较晚睡着。宿管怎么 7:00 就叫人起床？还说最后一班校车是 8:20？</p><p>lzqy 介绍扑克牌接龙游戏，很好玩，并且他赢麻了。跑路。lzqy_ 顺便口头 AK 校内 ACM 赛。</p><p>真不如预计起飞 14:30，实际起飞 16:05。</p><h2 id="Day-12-20240206"><a href="#Day-12-20240206" class="headerlink" title="Day 12: 20240206"></a>Day 12: 20240206</h2><p>之所以要在活动结束后多写一天，是因为我发现听完题解瞪出来的 WC T2 其实是对的，并且调对了。赛场上讨论 00,01,10,11 的转移的思路也是对的，唯一不对的就是考场上我以为它有很多段区间，实际上除了 <code>xyyz</code> 以外的情况它就是连续的双端开区间，那么这种情况甚至不用处理。漏的是讨论峰/谷点处，当时想到却没有明确化，也没有想起 Baka’s trick，我真是差一步拿 220 的（再差一步就 225）。不过调的时候 Baka’s trick 写挂了，还是不太行。% zlt，看他的<a href="https://www.luogu.com.cn/blog/275273/solution-p10144">题解</a>完全懂了。</p><p>加训，再战。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Luogu P10085 [GDKOI2024 提高组] 染色</title>
    <link href="/sol-LGP10085/"/>
    <url>/sol-LGP10085/</url>
    
    <content type="html"><![CDATA[<h2 id="简要题意"><a href="#简要题意" class="headerlink" title="简要题意"></a>简要题意</h2><p>给定一个边长为 $2^n$ 的 01 循环矩阵，要求构造一组方案选出若干点，使得把每个点及其四个方向的邻点均翻转后，矩阵变为全 0。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>容易发现，一个点操作与不操作，可以只由它的上下左右四个点决定。</p><p>假设翻转与否由矩阵 $v$ 表示，且原矩阵 $w$ 有这样的子矩阵：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">..h..<br>.icg.<br>jdabf<br>.kem.<br>..l..<br></code></pre></td></tr></table></figure><p>就是，当前点是 $a$，周围一圈是 $b\sim e$，再往外一圈是 $f\sim m$。</p><p>则有</p><script type="math/tex; mode=display">\begin{aligned}v_a &= w_a\oplus v_b\oplus v_c\oplus v_d\oplus v_e \\&= w_a \\&\oplus (w_b\oplus v_f\oplus v_g\oplus v_a\oplus v_m) \\&\oplus (w_c\oplus v_g\oplus v_h\oplus v_i\oplus v_a) \\&\oplus (w_d\oplus v_a\oplus v_i\oplus v_j\oplus v_k) \\&\oplus (w_e\oplus v_m\oplus v_a\oplus v_k\oplus v_l) \\&= w_a\oplus w_b\oplus w_c\oplus w_d\oplus w_e\oplus v_f\oplus v_h\oplus v_j\oplus v_l\end{aligned}</script><p>令 $w’_a=w_a\oplus w_b\oplus w_c\oplus w_d\oplus w_e$，那么只需要处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">..h..<br>.....<br>j.a.f<br>.....<br>..l..<br></code></pre></td></tr></table></figure><p>的子问题即可。</p><p>因此，我们想到这样子的分治：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">!.!.!.!.<br>.#.#.#.#<br>!.!.!.!.<br>.#.#.#.#<br>!.!.!.!.<br>.#.#.#.#<br>!.!.!.!.<br>.#.#.#.#<br></code></pre></td></tr></table></figure><p>把整个矩阵像这样子染色，先转化 <code>!</code> 和 <code>#</code> 的 $w$ 值，然后分别解决 <code>!</code> 和 <code>#</code> 标识的两个子问题，然后再还原 <code>.</code> 处的 $v$ 值。</p><p>关于分治的边界：当 $n=0$ 时，每个点自己解决自己，则 $v_a=w_a$。</p><p>令 $p=2^n$，则时间复杂度为 $T(p)=O(p^2)+2T(\frac{p}{2})=O(p^2)=O(2^{2n})$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DIRs = <span class="hljs-number">4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Xs[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Ys[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> N, cnt;<br><span class="hljs-type">bool</span> mat[MXN][MXN];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">mv</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> s)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(i + p * (<span class="hljs-number">1</span> &lt;&lt; s))</span></span>;<br>  <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += (<span class="hljs-number">1</span> &lt;&lt; N);<br>  <span class="hljs-keyword">if</span> (x &gt;= (<span class="hljs-number">1</span> &lt;&lt; N)) x -= (<span class="hljs-number">1</span> &lt;&lt; N);<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> s)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (s == N) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != (<span class="hljs-number">1</span> &lt;&lt; (N - s)); ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != (<span class="hljs-number">1</span> &lt;&lt; (N - s)); ++j)<br>      <span class="hljs-keyword">if</span> (!((i + j) &amp; <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">d</span>(<span class="hljs-number">0</span>); d != DIRs; ++d)<br>          mat[<span class="hljs-built_in">mv</span>(x, i, s)][<span class="hljs-built_in">mv</span>(y, j, s)] ^= mat[<span class="hljs-built_in">mv</span>(x, i + Xs[d], s)][<span class="hljs-built_in">mv</span>(y, j + Ys[d], s)];<br>      &#125;<br>  <span class="hljs-built_in">solve</span>(x, y, s + <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">solve</span>(x + (<span class="hljs-number">1</span> &lt;&lt; s), y + (<span class="hljs-number">1</span> &lt;&lt; s), s + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != (<span class="hljs-number">1</span> &lt;&lt; (N - s)); ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != (<span class="hljs-number">1</span> &lt;&lt; (N - s)); ++j)<br>      <span class="hljs-keyword">if</span> ((i + j) &amp; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">d</span>(<span class="hljs-number">0</span>); d != DIRs; ++d)<br>          mat[<span class="hljs-built_in">mv</span>(x, i, s)][<span class="hljs-built_in">mv</span>(y, j, s)] ^= mat[<span class="hljs-built_in">mv</span>(x, i + Xs[d], s)][<span class="hljs-built_in">mv</span>(y, j + Ys[d], s)];<br>      &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>); i != (<span class="hljs-number">1</span> &lt;&lt; N); ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != (<span class="hljs-number">1</span> &lt;&lt; N); ++j)<br>      cin &gt;&gt; x, mat[i][j] = x;<br>  <span class="hljs-built_in">solve</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != (<span class="hljs-number">1</span> &lt;&lt; N); ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != (<span class="hljs-number">1</span> &lt;&lt; N); ++j) cnt += mat[i][j];<br>  cout &lt;&lt; cnt &lt;&lt; endl;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != (<span class="hljs-number">1</span> &lt;&lt; N); ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != (<span class="hljs-number">1</span> &lt;&lt; N); ++j)<br>      <span class="hljs-keyword">if</span> (mat[i][j]) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    cout &lt;&lt; flush;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - GDKOI 2024 提高组</title>
    <link href="/rec-2024gdkoi-s/"/>
    <url>/rec-2024gdkoi-s/</url>
    
    <content type="html"><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p><em>2024.1.5.</em></p><p>上完下午第一节语文课，就开始一个车上的音游的玩了。</p><p>晚上和 lzqy_ 交换了笔，他要粉色的，我拿了深蓝色的。</p><p>在酒店刷 B 站，提到一个人说很能静下心能阅读，于是有点自责是不是有点浮躁了？有没有办法让自己安静一下？</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p><em>2024.1.6.</em></p><p>车上想假认真，打打糖果公园，没打完，结果发现自己假了。</p><p>赛场上没有一题马上有头绪，但是刚开始就代码声噼里啪啦。</p><p>先看题一小时。</p><p>从 T3 暴力开始写起。</p><p>想想 T1 可不可以先随便找一个完美匹配，然后调整。这不就是找边权和意义上的奇环吗？不过还有条件：这环上每隔一条边就在当前匹配上。——那么就魔改匈牙利吧。</p><p>脑子里面歌单随机播放。</p><p>T2 查一查部分分，高达 60 分，OK。但是真的不能拿到更高的分吗？……</p><p>$100+60+10=170$，看起来大众分了。</p><p>走出赛场，发现真大众分。然而 T1 怎么还有高妙网络流做法的？</p><p>T2 神秘数据结构，T3 神秘数列性质题目，超出能力范围。其余的时间有点浪费时间，可惜没带平板。有些人在讲完题后就跑路了。</p><p>晚上看看去 GDKOI 而翘掉的本校集团考，看到一两道数学题还挺好的。听说历史考了很有意思的东西，可惜了。</p><p>晚上 ABC，不是很理想，简单题写慢了，罚三发罚时。差点以为会 G 了，但是时间不够，后来发现时间复杂度还真的不对。</p><p>看到了成绩和名次，没挂分，居然还挺高的，有点慌……</p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p><em>2024.1.7.</em></p><p>这不是 7:25 准时出发的车吗？这不是 7:40 多了吗？</p><p>第二次刚开始考就噼里啪啦。</p><p>先看题一小时。</p><p>看看 T3，诶，这不是星条旗形吗？这么清新构造。</p><p>看看 T2，诶，这不是 NTT 吗？等一等，NTT 怎么写？……写了 $O(m^2\log(R-L))$，跑路。NTT，谁爱写谁写。</p><p>突然就想起昨天看到的名次，突然幻想能不能拿金，害怕如果因为挂分与 Au 失之交臂……Stop。</p><p>对哦，今天怎么脑子没放歌？</p><p>看看 T1，诶，单调性……双指针？细节有点多，感觉要写挂了。</p><p>诶，怎么又倒序开题了……</p><p>下午开讲，T1、3 跟解法都差不多，T3 甚至更优一点。T2 65 部分分怎么就要 NTT？原来是 DP 部分没有优化空间。是神秘数学题，用单位根的性质。</p><p>出分：$100+60+10+20+45+100=335$。</p><p>T2 NTT 20 分算了。但凡我 T1 没挂？$415$ 什么成分也很容易知道……</p><p>后来一聊，没拍，好。</p><p>跟同学一讲，就发现 T1 结论假了。为什么我会在赛场上推出一个这么假的结论呢？下来随便改改就过了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于简单、有优美结构的题还是比较稳定的。但是数据结构真容易写挂……还要加训。</p><p>或许，也要坦然地认为，命运就是喜欢和我开玩笑。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - NOIP 2023</title>
    <link href="/rec-2023noip/"/>
    <url>/rec-2023noip/</url>
    
    <content type="html"><![CDATA[<h2 id="Day-12-1"><a href="#Day-12-1" class="headerlink" title="Day [-12,1]"></a>Day [-12,1]</h2><p>感觉这次停课开训，动力不如 CSP 的足，更颓一点。可能是雀势力在机房进一步发展导致的，也可能是时间更宽松导致的懒散吧。如果一天还是上午下午各一场那么紧凑，也许不会这么颓了？</p><h2 id="Day-0-during-contest"><a href="#Day-0-during-contest" class="headerlink" title="Day 0: during contest"></a>Day 0: during contest</h2><p>之前听说到有人上完厕所回来瞄了一眼就有思路，最后被判抄袭。考场也不用隔板，用防窥屏膜。于是比较紧张。</p><p>节奏还是放慢。</p><p>T1 花了一点时间，确认一下结论就打开 vim 写掉了。</p><p>T2 一开始比较懵，想了想模拟就会了，但感觉有点细节，想先放放。</p><p>看到 T3，$O(qnm)$ 的思路很快就出来了。然后发现一个性质是列之间只有包含关系，行之间同理。但我的思路转入从上往下扫，维护左右界，发现有点艰难。</p><p>T4 dp 有点细节。于是关闭 vim，先把 T2 写了，还发现一点细节问题，样例过了就撒手了，然后写 T4 56 pts，然后是 T3 35 pts。</p><p>然后想到了动态开点值域线段树做 T4。……最后放弃了。</p><p>最后想要卡 T3 的常，更改了一下 <code>swap</code> 数组和 <code>copy</code> 数组的操作，结果最大那组样例突然 WA 了。这个时候 12:57。</p><h2 id="Day-0-after-contest"><a href="#Day-0-after-contest" class="headerlink" title="Day 0: after contest"></a>Day 0: after contest</h2><p>今天额外遇到 fffngzzh 和 lxzy_。不得不说，fffngzzh 一直以来皮肤保养的真的很好。可能可惜没留下影像，都不知道啥时候还能再见一面了。</p><p>T4 的感觉像什么呢？我想化用一位学长在初三时候 NOIP 游记的一段话：</p><p>“但当我试图实现区间加等差数列、以及区间求 $\max$ 的时候，一切就结束了。不想再回忆了。满脑子都是一万遍平时或者模拟赛中主席树写了树套树、能离散化却写了动态开点之类的东西。”</p><p>关于 T3，后来发现是输出答案的时候，因为要把 <code>n,m</code> 交换回去，输出直接输出了 <code>f[n][m]</code> 而没有判断是否输出 <code>f[m][n]</code>。就是，调成 0 分了。</p><p>最后还是觉得，T2 和 T4 在细节上还是拧巴的比较久，T3 这次也没有打出 CSP-S T2 的那种灵感，我觉得还是思维能力的确不够强。诶。</p><p>是不是我在前面训练的时候多认真打打模拟赛，或者逼着自己下去用可能被刷机的 NOI Linux 去熟悉 vim，都没那么手忙脚乱呢？（我不太喜欢考场的 Dev-C++，因为它在 <code>.out</code> 文件更改的时候弹出的弹窗和程序运行的弹窗同时弹出后，会同时被覆盖，感觉更手忙脚乱一点。）是不是我在前一天晚上早睡一个小时，或者在考试前少聊两句天，或者平时少 beatbox 两个 bars，或者多上两次厕所（这样总共就达到三次厕所了）也不这么头脑发散了？是不是我平时少刷两个视频，多看两页书，心性会更平静呢？还是说我拿到 CSP-S 的分数，还真会有点骄傲？</p><p>我不喜欢随随便便画句号，但的确感觉，好像在掉速，有点没体能了。吧？。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>自我估分：$100+100+0+56=256$。</p><p>希冀估分：$100+100+35+100=335$。</p><p>实际得分：$100+100+25+56=281$。</p><ul><li>训练提升难度。留意快速厘清问题细节的能力，以及精巧的思维、常用的算法思想运用。</li><li>磨炼宁静的心性。比如平时加训不打 B、多看书少听歌、多写字少聊天之类的。</li><li>勤奋、专注一点。常想想多看看书，写写博客。——如果真的有空。</li></ul><p>如果真的什么时候突然有一种孤独感，我大概也只能想到这些方式来排解了。这可怎么办呀，也许我真的不需要一个实际的人陪我聊天……我希望我真的这么厉害。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - CSP 2023</title>
    <link href="/rec-2023csp/"/>
    <url>/rec-2023csp/</url>
    
    <content type="html"><![CDATA[<p>J 组和 S 组双料选手。</p><h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><p>J 94.5，S 82。基本没复习，只做了 0.76 套模拟题。被各同学薄纱。</p><h2 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h2><h3 id="Day-14-1"><a href="#Day-14-1" class="headerlink" title="Day [-14,-1]"></a>Day [-14,-1]</h3><p>开训。</p><p>开雀！</p><p>开某款 Gen 开头的游戏！</p><h3 id="Day-0-Morning-Junior"><a href="#Day-0-Morning-Junior" class="headerlink" title="Day 0 Morning: Junior"></a>Day 0 Morning: Junior</h3><p><em>2023.10.21.</em></p><p>看完题，本来打算先全部口胡完再写，结果愣卡在 T4。一开始就想到对每个点维护 $\bmod k$ 的每个余数的最短路，然后又觉得好像不好转移，卡在 $O((n+m)a)$ 的建图。觉得受不了，先把前三题写了。</p><p>前三题还是要动动脑子才能写：第一题发现每次减去三分之一向上取整是可以做的；第二题本来以为 DP，再想了想应该是从前往后简单贪心一下；第三题模拟，一开始没有发现要处理 <code>sqrt(1)</code>，还是有细节的。还有一些变量名写错这类细节问题……花了一点点时间。</p><p>快 10:00 了，突然开窍，发现最短路 $+k$ 总是合法，然后就做完了。写了 $O(mk\log mk)$，想了想，如果实现精细可能可以 $O(mk\log nk)$ 这种东西，但觉得不是很值，就不写了。然后上厕所，然后拍 T1。有点怕 T4 常数大，因为最短路算法好像不是普及组算法。</p><h3 id="Day-0-Afternoon-Senior"><a href="#Day-0-Afternoon-Senior" class="headerlink" title="Day 0 Afternoon: Senior"></a>Day 0 Afternoon: Senior</h3><p>看完 T1，蒙的，怎么比 Junior T1 还简单？反复确认几遍，好像暴力即可……</p><p>大概扫了一遍题，发现 T2 好像不是很浅显，T4 应该是树上问题，要动脑子，T3 不用。所以写完 T1 就搞 T3。</p><p>T3 写完大概已经赛了 2h 了。中间就是那个对齐的规则没有读对，修改了几回，上个厕所。看了眼 T4，好像是简单，把变化的函数写一下，感觉不难，就先放放，动动脑子想 T2。</p><p>想 T2，一开始只想到 $O(n^3)$，做类似括号序列的东西。然后手模了一种 $O(n^2)$，就是维护 $n$ 个栈，逐个看栈顶相同就删，不同就加。当时还没有细细证明过就觉得这是对的了，也不知道怎么想的。上个厕所，想怎么进一步优化，就想到每个右端点的答案是往左走删空的左端点数目，然后就像字符串结构一样维护 <code>fail</code> 指针之类的东西，再把它优化到单次查询 $O(1)$，记录每个字母的最靠右的左端点。时间就是 $O(n|\Sigma|)$。感觉很灵光一现，然后理理细节，写掉了。此时赛程还有 1h，可以计算在本题有 0.5h 想题，0.5h 写代码。</p><p>T4 觉得长得比较二分，然后就做完了。这是我第三回上厕所，水喝多了属于是。写完还有 15min，然后怕 <code>__int128_t</code> 过不了编，写了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __int128_t</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">__int128_t</span> lll;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> lll;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>结果丢到 Linux 一测，给我爆 <code>long long</code>。整个人恍惚的，根本来不及手敲 <code>__int128</code>，最后删掉 <code>_t</code> 然后结束考试。</p><p>感觉 400 分场，T4 打成这样也没话说了。给大家表演一个 400 变 300。</p><h3 id="Day-0-Evening"><a href="#Day-0-Evening" class="headerlink" title="Day 0 Evening"></a>Day 0 Evening</h3><p>听说 S T2 有原？还是我听课有听到的原？？虽然猜到，但真的一点没印象啊。</p><p>估分，Junior 小图灵和 Luogu 是 400，云斗上面 T4 测了 25，爆 Segmentation Fault，有点神秘。</p><p>Senior 前三题在 Luogu 和云斗都能过，T4 直接交，云斗上面 5，Luogu 上面 30。</p><p>然后当我把上面那一段改成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// #ifdef __int128_t</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">__int128_t</span> lll;<br><span class="hljs-comment">// #else</span><br><span class="hljs-comment">// typedef long long lll;</span><br><span class="hljs-comment">// #endif</span><br></code></pre></td></tr></table></figure><p>云斗上变 35，Luogu 上变 90。一搜，<code>#ifdef</code> 只检查宏定义，不检查某个东西是不是真的被定义了。所以它一定会使用 <code>long long</code>……</p><p>另外，把第四行的 <code>long long</code> 改成 <code>long double</code>，在 Luogu 也能拿到 90，<code>double</code> 是 85。</p><p>给大家表演一个不会 C++。</p><p>但还是觉得云斗有点神秘。</p><p>小图灵 S 更神秘了：$100+95+100+0$，T2 WA 一个点。</p><p>一段训练之后有一种感觉，感觉自己的思维逐渐模糊迷蒙，不那么具体和有理，不知道好不好。可能会把一些比较无理的想法也说了，表达也喜欢感性表达，写题也感性理解。以及，晚上思考感觉比较无理，上午还犯困。</p><p>好像还是缺少一点快速代码的能力。感觉这两场的难处主要在于代码能力，思维最难可能是 S 组 T2。</p><h3 id="Day-8-结论"><a href="#Day-8-结论" class="headerlink" title="Day 8 结论"></a>Day 8 结论</h3><p>J：$100+100+100+100=400$。</p><p>S：$100+90+100+25=315$。</p><p>J 还是稳，没留遗憾。所以云斗怎么把 T4 挂成 $25$？</p><p>然后给大家讲述如何从 $315$ 调成 $400$：</p><p>第一步，T2 $90$ 变 $100$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">if</span> (~fal[i]) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (i); <span class="hljs-comment">// correct: if (fal[i]);</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>纯粹变量打错，看一下都知道不合理啊，i 从 1 开始，<code>if (i)</code> 恒成立啊。</p><p>实际结果：19、20 两组数据的输出比答案小 2。</p><p>第二步，T4 $25$ 变 $85$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __int128</span><br><span class="hljs-keyword">typedef</span> __int128 lll;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> lll;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// correct: typedef __int128 lll;</span><br></code></pre></td></tr></table></figure><p>第三步，T4 $85$ 变 $100$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">u</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">v</span>(<span class="hljs-number">0</span>); i != N; ++i)<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v), <span class="hljs-built_in">addedge</span>(u, v), --u, --v;<br><span class="hljs-comment">// correct: scanf(&quot;%d%d&quot;, &amp;u, &amp;v), --u, --v, addedge(u, v);</span><br></code></pre></td></tr></table></figure><p>解释：大部分情况下，我习惯从 0 开始计下标，下文以 0 为根 dfs，数每个点儿子个数。如果这么写，每个点都和<br>0 不联通，因此每个点的儿子个数都是 0。原来这样写，三组数据输出比答案小 1。</p><p>总结好处坏处：</p><ol><li>严谨。这可以有效保证正确性。</li><li>思维活络。以尽可能解开难题。</li><li>粗心，写代码动脑子手脚不协调。也许可以做一些有意义的事情来避免，比如玩原神。</li><li>不知道 <code>#ifdef</code> 只检查宏，不是检查任何名称。不敢咬定 <code>__int128</code> 能过编。错一次就记住了。长期地，我开始学用 vim，在 Linux 环境下编程，图保险。</li><li>审题不够细致，尤其是本次的模拟题。这也会浪费时间。我认为这是性格，不过状态冷静理智的时候也可以避免。</li></ol><p>怎么说，总是要备战 NOIP 的。新科技会开，状态要调，不过不知道届时还是否停课……</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - ARC144C K Derangement</title>
    <link href="/sol-ARC144C/"/>
    <url>/sol-ARC144C/</url>
    
    <content type="html"><![CDATA[<p>背景：本人是打表也瞪不出规律，看题解区都是找规律大神，发一篇比较有确定性的解法。</p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>找到字典序最小的长度为 $n$ 的排列 $a$，满足 $\forall 1\le i\le n$，$|a_i-i|\ge k$。$n$、$k$ 给定，$2\le n\le 3\times 10^5$，$1\le k\le n$。无解输出 <code>-1</code>。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>无解是容易判的：$2k&gt;n$。考虑构造一组字典序不一定最小的可行解：${k+1,k+2,\ldots,n,1,2,\ldots,k}$。那么无解也就显然：第 $n-k$ 位的 $n$ 和第 $n-k+1$ 位的 $1$ 相邻的情景不存在，也就是 $n-k+1-1<k$，即 $2k>n$。</p><p>来，减小这个排列的字典序：${k+1,k+2,\ldots,n,1,2,\ldots,k}$。</p><p>我希望把 $1$ 提前。我们第一次在点 $k+1$ 处可以选 $1$，这以后的每一处都可以选 $1$。但是 $k+1$ 以后还能不能选 $2k+1$？</p><p>意思就是，在前面一大段的 $i$ 我们都选择 $a_i=k+i$。能不能把最后 ${1,2,\ldots,k}$ 的头 $1$ 先在前面输出，而在最后放上点 $2k+1$？</p><p>如果可以，我们就放，否则，就不放。</p><p>这点启发我们想到在逐位考虑 $a_i$ 时维护一个最小的值 $v$，它在 $j&lt;i$ 的 $a_j$ 中没有出现过。如果它可以在 $a_i$ 处出现并且 $i+k$ 可以延迟出现，也就是 $v\le i-k\land i+k\le n-k$，我们输出 $v$，延迟出现 $i+k$。否则我们继续延迟 $v$，输出 $i+k$。</p><p>最后把剩余未出现的数升序输出即可。</p><p>时间复杂度：$1\sim n$ 逐位考虑 $a_i$，$v$ 移动 $n$ 次，时间为 $O(n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">K</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  cin &gt;&gt; N &gt;&gt; K;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * K - <span class="hljs-number">1</span> &gt;= N) &#123;<br>    cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(N)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N - K; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i + K &lt;= N - <span class="hljs-number">1</span> - K &amp;&amp; id != N &amp;&amp; id &lt;= i - K) &#123;<br>      cout &lt;&lt; id + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>      vis[id] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">while</span> (id != N &amp;&amp; vis[id]) ++id;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cout &lt;&lt; i + K + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>      vis[i + K] = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (id != N) &#123;<br>      cout &lt;&lt; id + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>      vis[id] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">while</span> (id != N &amp;&amp; vis[id]) ++id;<br>  &#125;<br>  cout &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排列</tag>
      
      <tag>ad-hoc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces 1874C Jellyfish and EVA</title>
    <link href="/sol-CF1874C/"/>
    <url>/sol-CF1874C/</url>
    
    <content type="html"><![CDATA[<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>给定一个 $n$ 点 $m$ 边的 DAG，拓扑序为 $1\sim n$（无重边）。一个物体初始位置在点 $1$，目标是去到点 $n$。</p><p>每当这个物体不在终点而在点 $u$ 时，会分别选择 $u$ 的出边 $u\to v_1$ 和 $u\to v_2$。若 $v_1=v_2$ 则此物体移动到点 $v_1$，否则原地不动并毁去 $u\to v_1$ 和 $u\to v_2$ 两条边。其中 $v_1$ 总是随机选择，但是可以有策略地选择 $v_2$。</p><p>求这个物体成功到达点 $n$ 的最大概率。</p><p>$2\le n\le 5000$，$0\le m\le\min(\frac{n(n-1)}{2}, 2\times 10^5)$。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>不难想到令 $f_u$ 表示当前在点 $u$ 成功到达点 $n$ 的几率，然后做 DAG 上 dp。转移大概形如 $f_u=\sum a_vf_v$，其中 $a_v$ 表示某个系数。边界是 $f_n=1$。</p><p>这个系数似乎没有简单求法。但是对于每个出边数 $k$，都有一个唯一对应的系数序列 $a<em>k$。要最优化决策，实际上就是把最大的 $a</em>{k,i}$ 对应最大的 $f<em>v$，次大的对应次大的，依此类推。上面的递推式大概可以写成 $f_u=\sum</em>{i=0}^{k-1} a<em>{k,i}f</em>{v_i}$，其中将出点按 $f$ 值从大到小排序，$a_k$ 也按从大到小排序（下标从 $0$ 开始）。</p><p>我们想要求 $a_{i,j}(0\le j&lt;i)$。</p><p>边界，有 $a_{1,0}=1$。$i=0$ 时即没有出路，$a_0$ 和为 $0$。</p><p>对于 $i&gt;1$，第一次操作，有 $a_{i,0}=\frac{1}{i}$，即只要求随机选的出点恰好一致。</p><p>对于更大的 $j$，由于第一次操作失败才会考虑，这样的情况都化为 $i-2$ 的情景。转移的依据就是第一次操作中随机删的点在 $j$ 之前或之后。</p><p>有 $a<em>{i,j}=a</em>{i-2,j-2}\times\frac{j-1}{i} + a_{i-2,j-1}\times\frac{i-j-1}{i}$。（编写代码时注意边界）</p><p>时间复杂度：预处理 $a$ 的时间是 $O(n^2)$，每组数据对每个点都要做一次出边的排序，所以是 $O(n+m\log n)$。</p><p>启示：对于难求的系数，考虑 dp 预处理。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">5005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXM = <span class="hljs-number">200005</span>;<br><span class="hljs-type">double</span> prob[MXN][MXN], dp[MXN];<br><span class="hljs-type">int</span> T, N, M;<br><span class="hljs-type">int</span> to[MXM], nxt[MXM], head[MXN], egsz;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  prob[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">2</span>); i != MXN; ++i) &#123;<br>    prob[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span> / i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">1</span>); j != i; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &lt; i - <span class="hljs-number">2</span>) prob[i][j] += prob[i - <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>] * (i - j - <span class="hljs-number">1</span>) / i;<br>      <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">2</span>) prob[i][j] += prob[i - <span class="hljs-number">2</span>][j - <span class="hljs-number">2</span>] * (j - <span class="hljs-number">1</span>) / i;<br>    &#125;<br>  &#125;<br>  cin &gt;&gt; T;<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-built_in">fill</span>(head, head + N, <span class="hljs-number">-1</span>);<br>    egsz = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); M--;)<br>      cin &gt;&gt; x &gt;&gt; y, --x, --y, to[egsz] = y, nxt[egsz] = head[x],<br>                               head[x] = egsz++;<br>    dp[N - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(N - <span class="hljs-number">2</span>); ~i; --i) &#123;<br>      dp[i] = <span class="hljs-number">0</span>;<br>      vector&lt;<span class="hljs-type">double</span>&gt; vec;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(head[i]); ~j; j = nxt[j]) vec.<span class="hljs-built_in">emplace_back</span>(dp[to[j]]);<br>      <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">double</span>&gt;());<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != vec.<span class="hljs-built_in">size</span>(); ++j)<br>        dp[i] += vec[j] * prob[vec.<span class="hljs-built_in">size</span>()][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">10</span>) &lt;&lt; fixed &lt;&lt; dp[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
      <tag>概率与期望</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - ZR 2590 朝花夕拾 / 单次询问模质数意义下质数次高次剩余</title>
    <link href="/sol-ZR2590/"/>
    <url>/sol-ZR2590/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试." data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="889cf4b50005445ad5070bf729a8c30ce2d6afff70832a27d942df6afbff29d7">014d9f2d516394911a9337af4e8d85563690b87e6ff3c003c5cf9df12e06d182222989dfe958aea44f34df786e9ae99a4f48cf98cf06a7243cfd1351c7de3dcb429f2dea9021b16398ca19d038de9d858672cfd65af0d19f7211b3f1b2f4325f2d7a5ffefbf40e7e385e536e7457afa31bab060e46abb9f6f730950bd15d0ee9ae989ad5554135d1962cd0371379355a3a9a80e25e850f078f09b82118ed178a5681244e2af4cc388caf289d2967944fd5f7bd4bb4f11b7ed35d38399bde31a41085358c20cf825ceb74c5c15c0f1a286eee06bb7fbb6fece4f52fe331cb26513c7879339f3386bfd1a2c8d2f6b1df8f06db4a16ff4ee9e2f579b1c5fc98e808dfd86bdcd8aa3bf6ef82b099570a7b36789d4d9b080f08e6c72a3447915525716176612252b964181d502923df5b163f9fed26d677a0c8b413698e8f3f17513ad4d57a70a8d09e83f54f3ab88466501a1aa0af2b0c3cd9d24d7f910b61bfacd7af61803084173fecaa518313de7e382e23a00a8f7598574f990010e5add265641b42a84770cf10b753b8d57851096f54e3ad9314f106e2b6b067ea5b3bd2511f9e3f931a3c24674807712e5eded66374b3e95f7dfd3068459051d9a494953e2a0d3a4896fae984d1d4fd1ed949709a214f436d7481048cc93800ea05655869a4a2d6589872aad2edad83095a68ba2ac4967a4116a8a93f339012378d6b0e58d9f52df58406c584e38eea0f975458c88feaf9fea85faf8972d41807199213eb5506d221ac17c5937374b6296ae2187f51803a8c8ce6b5032f8d46c3ae2ad72838ec6e7960ed14fa00326735be42f7ed55048df4382d1457250abb8ab992192790590ecbc362c3dcbdc942766c700c7667f85c32a2aa4d4f802e914e0ef4cb49f7db221ba960acf1868a2afec7eb78370656d29cd71309a7f5af49ef12f707b49876c6f5c240d71d4b9a9ab298cac6cbbf045b72219863ee1b4391534c4eccb106d29fb0bf542924d844673304a37df9a7a142bbea6f45111abdfb5ba04161bfac69a2de99d74a1b6b02795a7a3827364cff35b45f5e90523b0234718fab47e413a0185dfa676a0a7a62ba650e44d805898cbf6dc44c363c7b53d66fa30b73e6e51d2245ce4108f6d402e911230f2de650e5559ed7cb6f7e41952781c711144253db6af5da395a11c5b212de75615ac175b2f2b1fa0bcb48315e6ea95c9fdfdce1728dcebc2ef149404b10e027f0635ed98aa380f964393e20553dfb6e635f4df9e62148fb29071ba95ff4d8f68919290ca435a3ad1c3c279d2266a59c0ac6eceb49477e6c6b1b825c763eea9d3751cc84a2df52093638cd7113417e3704d7d5cd02a4abbf481dfd0032e73d854d6aef3c55379532282ba23fa95b322e2525f2b9bfe40325fda9dbb9c494c05a546b95dd7eac055ce99724f4829cc21b6ec8eeeea40483f70e2e9028370f1db9b4038d14e8c324cfaba1666a11e75cbd18dd137be576c2d7adb7e84ef874b88154b3b4bd89338d0b344a6e8b7010a40c1966ed5585134d5d72089c7a71444b2d1409fb4e51bec6e3e425f884c43dced534444561d3fbeac75d621716231a2082530258b7d3ac417e44fbd4368034edac2249f9ec903039d0a5a16bea6a06117d89394a9e0c6be4f1897aa13509c3b1ec4cbb2d620561216922aead3b69fc0e21c24386c9cce56a42c1e9daa5d47c472e8942eab75213630bfaff0893267cbcbc8b23eec2366df2a1c190d7c8a1dd12652ca7a880349df6b5cc64a5c54484dbe90a37953780803355fd164fed85b82c84cb28d68376dc3936e3ef595c94acfa810f65c756507b554ca2c23ead459a058be8327ed42c774149870b45f576d537d12fd4f49dd394f5a0dd70b342b6985fb0bda4ffb9e32e81f452c3924d675e021fb6d1e1cfce3ee76d027f029c3e9f69a0d8c72c87313ff6cd794368f0658a98591c1b40c4e2c8fe1e8088ecadab6a91da38b416b206a57ec677972738d4f44338bab5ce3f1b8ad1e1ffebbc6a1ec57e3815394e67b99b963bf30ea01607d90fca4caec903e47726c274ca3604889f6665992a7713d97eab734ba08a670289340a82fc2cbc9f41e8f6d1e0e59ccf37612c8ed1b8ad696fb2fbe0b79a913621695e6b622327267b598ccd1c81c8a888e16af2eeca1c29a19587e2c1eee89174e2472262f1bba3ec00118837ebdafa3ab41eab24f9e5df49eb033deed53c667d8184442fdd5efe61227bbce7c5e9464de2c90f17b6b0ec4ae1dbf29968ea1a8dc1603f1f620c0a5dcde780c5a98f1fc294e83f3a2bd462a6e45a3b895276167876f1d5a58b219999c95e18fc80cea85ef57332e2763810e2696ac66b697cbf5b345fa2ad35ee37b4460df74e1a152cc78b5816f9347335d871438f0b5f5689aee53ac8e375b6a0884944390db223a895106fc972d7637ce1d90a34584f0c562f68e034fb0b844970cc96af607581f54acd3adc3e71c6bb0973e82447ba04164d2afc63f8d25b90d6c4c96b3ab7c5eb865d34e9d17200d9ad3cafb723fba5b6b3d83fe79b3b0634ac6274c8724cd90585b8f88c592338e6f8e34feb60e2ea2ea03e317a394378e3445c133a062e3733bccd97040646249869720868650b0a25d6eb26248e3487912ff9a896cf729e1f4f9e3d40a916415fb23e94e911790be7981b60fd2f8f85c9a15e0d6cee92028dd57272f009071fb77269d12a6dfdc7fd7eb655eea3c8a617ae8f3616ad6000a41fefcd5444152b6d208f5facecf4eab1d10aacfe735cc5166b5792477562e8e5ff82d841532fd5bf266092ade8673b0892c7409fe99ed64c49ff824a759080e1dcd30de4181f7c7dbfaa191ff6ec2e27b48f38d9ff74bf81a6fa99b6d8adf0487b65387fb08ee117d4e3882c9291f1ec4534570e007dfce21e121dca71ce418c9c19dd8b65ab5788374ba9b6c906ca377c173fc1120e9d398cb7cc96cd6abeded0813e20a9ee0b7e426352dffc215abaa7525d3333c05876984ef0e545aa57f457074bc20d1a6cee19bd3e9918fb866543cdb02e9306a74d079d0e918414e9dafdfd67d2f5ef342f0453284ddee5c1a81c7b59cbd9496d19ce68098540929624b62db437d4fe71fe1cafea93531e4b3240650152a319829ad8773d2879beb14fcaab4b7221e79709373ae282815a8d8e69b6e799ca8a99006780db8a59f6ddb17a34efdce6d22794ed38ac60f0e51a016b91b2fc55be7664a21bf007d87bff006de34078f05658f4b2bbc15341fad4ebe9305ca730782b359d4da6cafd5cd8ae931c6e98999c15258ed5f0cb8c83e973d2f1eaf95c0c55d418d46fc091996b7ed781cf6d46430b180fe61dbc8de6595c3be0858836aeca4a6898865cce5bd8e54c7c78f4a5a6d64a350a6baafeb521897d17dcb2439ceeb51ee849543e6ac3de9359cef246942a63a3b52d7df66abaccaf2e6ea3cf3cc7ad13bccfd22b175916faf3fa6dc15e8e29ef99ec72232ea731ea20f046a822ca541fc5928e58fb651f17546b060b332eb1fbf55f954f943558f5089fbfdb23801fe57b40d67f7a41aeda1136b0e22972c5ba886eb46e64dcb6e7f2f88f19a03a0f02280bd717dd832dcafb69d5a91cefd0987d704cfba19b74322b82baa4ad89502cde2a78fa3f3bef96ff838762c967c42f6cce15529bc23752c76889c8870dced413a32ed4fc12feb773fe374100c5e6347509710789383da54d8abaa2a4a91ac908f360421332904e255e288e75b62a9ddcdf7d12596117d436accf2b968cac6cd3b23ba4b1ecdb0ba11b87578755cb0f684251eb83ea197ea3635d54c7cd6098f963380fe3d02dfc27bc911bf5102b30bc29569c68a40fe5fda5636b588b078509be285a0bc6530ab11fe52d29e4e1688e7bf61b5be35049d5e5f50307dd90f39da2a76a4eac7379e0f4cd6de5037add69f0cb060629b8cc66436f9b30e0f4d721170dfa0fc433c53dff2fe118cb204ac341a22c1871b53aa4ad68a46b3e4cac3fada037c41cb3b9ece609e1a43f72581cfb2e72ada063029e2c439c8ba6ec8eee01dc25bc4db9f4a3745b93b1686e5926d8c36e6e6a3466cf85699f0ba746f62b3d929ad912450d57b59cd761c3f0b3df092cb502caa1f82dd7a90c5c908ff873ea7b3002c75f972b40a9d5c5c950919f3ba62237740c0eed8122b77c6955df3e02bd2df98063f2c26f9f1488bc179213600607c8dd80ff137f6916cf10c277d72aea4372adfdf3bc6d49544ef856238bc6565052cac7bd11a2495e03b2c2933e240f18db5043e8daa76e877cf05557dc9cf3a50b7e5c6fb335619e8f2707872dc5759d60958d759324bdf1472a339b7b10bc67a1e3a9307af719326c5e0d2b1555b90fdf293a36a4307aa8a96b2c6fba6b8aaa6d1d1aeb787e05b6bcaf3271d140617e3ae0e8497c2040d57e505e0a7e54d74a0486926b2b6ce1e6133da190e6913ed9b40184e917c8cb240710935c82394391da21559a54fdc8caf7cbdcbbbc209a39c1af131adf8935e34ed4b7915f4acf283ff9678fcf266bcdbdc90ffaecf166ffc2d1911315bfbf1fac2e28b197ca064e9b912abe3a11eb4f2805e4e1f8b169527c6211f3925c188292c32171ce45416a4aec8ff186dab656a16315c4da4871bd7abb9a6240cd1d81ca7734ce9eec2b03d13f17f5c15deb7460cfab39b69bec36c9b25d305500550fe9d5b512c20023ae6bcc266ca2d0ef75e6593c6a0008c4b4eca9a17a269241023b548c2183bb7ff07adb5183ded1431d81f113ef9c5be4376c26acaf78b307077e8a965c84e3a891ceb183dd9197b53ad377ff877b37d52dab4b0e9fb16ed51f9f3e242674e8a348dc5360ba2edb9ff81f00b50d44df12468ce4cbfd50bf6550a3972d5011849970f5bfb8592054696b38260752c744686b7dec63bab3a021912471f72b9fa15d63bf0d18260f82e07f546d856024672ac3985722de6fc7b6d12f6ccb86ddd886bc27b482676605ef241adaca3912d76752e15454c7a6d720ed6e021c52041c9d5cea129c0bd14a87815f9d1017acb9434cd56d3537ac84c8e0e52795bf5b9d5160b5c0be1a9a06d79e807f5da876eea6f14c5d51c0ee7b74d6cf68965457be93423576b05dcd88a846fdc157d67b81368f0884a72c1854d0fff6927c8e5843e9346f4bfefa9775b1ae0e9339aa855d83116e304f9f17db842fafed2ffe82f797e8d542cf7d7922d6e31c186f79d9ceaf79ec3dc70fa55ed2f34c55deb70e19ed400fd9dfdfbba7dee5bc3f23decdeec51eb5037401c99ff3cb0ee92040759bfb4b69c0f57c006e26e1b75c2fbf75065005eb3b88209ae49ed476870c7d061761bc1a91238e2e4222580692b1079b8f62ce0e9ea70821dc5fb9610daef03c31ce40126f17f5fe28d55a51b2012df5ff54e2128349c9c9c680b1b3921c06f2db2f0ff785fed8a410d3ea33ccc538301ec0d94b10733fd326d9b1c8914aad79e60af32f11889e2400d10a66df1ede3d80f97062bb9db48cab5b1ea4170c3073ff6c7229fe2762eb035f9da781a027e57d6dc00f4f1505e8667122a26c27dbc01ca51ae231779af81815263640e18ea0570b5a6572cce2cf1edd0b3dc5c77c9a6620ad35c5aac5d274b18579a8e637bd3dd35ae3ebac743e755fb36b5556c60f0f9bff326ccce7e54e96ba63bac17ae81bec2b461742d4000c8b60b1c9786f8259cf742277d70768e1bede6aea7ad78d0b4a4dd86e0f379d8946080e88cfc0c39dd4b7a432515cde10f29f6daf7f6086aeab7767d893d92d7821366f4279ff4be876971bb998ebd54f5f61782ca985b7737c52d3e42e5a4acbd980bd177764f73244fa8ad334173e9c626376823cd05d0338b5327fd7039d772ce6ab842c7bd966ec03565d7ab69f237bd07a0c1e9e5677448a1ddc218648c21002151a5cdbb1da212b93001b20bb18d977f3630a2dfdd8af034ef2d84ec0eb361c068f2f33b04f8bf4dff1a819e444d70016abe7e6ef88ee7eaf3eb49eb81d64c1da9162d1ea4ee9e65d71864baa52677c20aa5e543480da188c9dd6ebac5cb5ae73f7e05b502ef10b64724f205e5022a2bec434ba845215377fe880e3c9fea088ffc1065f385386b9d3c34368ebbdb05998febf099530846a964dd383f3367ebe0e524c73e1ca1e8599bc29d9d2af5204d2ff7ce0fec2b5c49fd4d67d801cf1852d91bff3f8946534ef8fd266720f026030fab9037e81fd37b7372051e7d7b0246083044975badfb418ce9e50d008561a9d123343465f75b93613587162677f96dd6bba33c226f2e4b2076b5a75f0572ebdef4857eb5fdad6ab17f0e074bd4ca527f8f036e85b4e7335920d5b775f19707aeeff4c327bdb5de0631b88e6de7996ea462afe74958c21472b9ef8fe17381682eb6e8cef120690686608c0bbf1ae3de007649ca2fd4359c388d0cd5a8bcf5ced938e717b8c4cae98b9056706d6ddcdb81c12a28c28f61be334553991e81c6463696ca407eaadddf8e44cee6def6f29e8a4224878a845c49b81a2ba00a226a837683137a89c9ec1f1546ccbbe3d9bd06d8ae6d9c22a957cc9d48085e6590c923eefc55ecf38a7c3ccf56835fa5c3f9c5d58c1719256dc7bca64c8fed639ea2c375197b07e284e4157affcc26f4077832c766118c9588437a38a589f62b4461b9435facc99c218327b3d2115844c5a2a8b74e24c58c25e26e249edd2fcccb80fc342e92ccb7769665120829a1aecbeea8ee6a495b64a7930565eceb5a054bcd47aba41fe28ff6697654babb167a0cd2aedece3eb234cdfc34bc837b6ca34a01dcaff6fb7706626b4c6e1ae2368f9e5538a9574bb9636d92d5150b7e7c6ee9497e131bd5942d20c39d3e2c8de7b872064d6641dca3bd2802d7828b8e1a430aa833b807e16edb0f279dd0ff573826163592c5516e596b19658594e35ac9f5f7f0d870b3313c3beebf23ed4122087f8caedac9b3ced310288b41660ef66c69491353776c35e46df6b16c37927331df47a4b7f2ce630327860227f76e5c803ec070d281fa234dee075bf8ceb0235a4f7fb25867547a92bd74292cbdca57df168f477802aef6f93d2a6241b74c5c06172f351f2c47b4114909ac1936a33d473c1713504ce59e5cd9998801566ed431c5542f54c0f2d1bd111fe5c86f77119a2ca8fc4156c9f4f83d821a890c9ae4cf7458b95476192ef89c753ef5b5365a4198caecb6daa48c0a4a685ba5bc51c8f2c9f12e96a174dd9fcafdb2aea560c183d9c44946855e569152e696cfb05cd15691724e9d77e64a0c1af22f47b25d11d2096fb67d74b9d177e6817ae399d85c08b119441798d0cb7bbe65da012adf77d4d663b3c290c7f569724787c96cd41fdf1b0d0a02db08089f8de345cf2ada085ae6798cb6d788718e3977454acf06ea711238260b875b2f7ec06187077d8574288bd133ccd0b9ffbfa51e2e42144805bc5a5b862e693184c85b50d7b4ca7fc40e6489fcba269668df5025faf5b19bea5347e6cca9569eca0d169eedd133fe633d588059ea5319790e44de906e5ead0d0c89191c86d1c0f9cc1fe9db4ff19b101eee5704e35675c4f090d80bb4093aafb153a2eeecdb432766e282b3539f9cf3c9e40cf402438d9be924ba18c9df7bf014f72699665a1c7097f1d408e74e58e0361cad903d1352d9454cbedac9a452854121ea2179676ae67af476f2d7acba4e7e8da93906fcf41e1aec4e50281f8b8dda108fa68b3599d23c2ac4edff7d46a0a829ea5c06b0e2eabe6368baf2466430a8b114f4843e54dfdf05d03d5aa55da42cffb24f6523f87a92ee99b32ad94b33507debcc00ce68214efa460c6f2341d9032ddb335ef2a80b3fba9389475a7b340582b502b435474147a3d1318504bed4eb36f21bced605a1310ad5fa5f4244a01d1cc4ff5af49a828158dd79c3a8d46a94c81030781d812b8c4ad2e4ea1a8baa0f420c1a0bf50937f225e760681233d93fb30c3de791944c8311f5ca0984e7a269b0618ff51aefed2f212eeaf3de19714e79b2fb55dd770108a4f2b84621b28c1f7ab32482f7f8270e34eafab0d50b4a72c7736d4fc9fe53b133eaa7ca68926dd1e26f2d9b04d6d5479e9c42a52083401238312e1bee05ebff84352678a2f47dc624b33398eb1ad5690e1ae3bbba3b1fc08b5c29783a64c1a6050f8533189a8c6a1ed5dabab3e528cb816dca8310b6522f327dff6c3f2d51de9e6bbaaf319c5b67268800f0ca71b1a799716e6fd77543b249c490c65aee1ff9eda58e37a23900d27e30e7b4237b89284cc8052e713e23bf52ac8cd229070fd8eeac18105f908a2e398e181a5b7b937bd56704f14ac18d6d47a87d1b57e04e1cec9b30ff084487a54ba66cb3297cd0caf01faa252e7cf064f794b87d3671d1f0c9f328ef2f6e76312d6f8b5ef959330831d0014cd1e184f7e7295d6e903009f7b1b5ace1e38c11ecce447f81d6a782c0bbb36e540d80deac42f15c8daa0270e217760d4e0b48e86487c4160be76986a208a5929e5a6c9284d26d2a553b3154f85c0b321c0e7099355bc28339c3a2aab2684b7ee2882182119ec32eaf3992bb64ebcc261b6f5c8c8d96dc818f37203e8b3a7025ed483a03b2feb8d600aaac9863150fe7e2d1af985bda128e025dc4d0ab6eb59bf9413aa720eb03223d4136345f613a6857c31a9ae711949b243a08110749e224645b4d1c95a54f8c59edd159c918d846288aedfdb526e53ebd818552805467170b8cbbc5a8746d4d729cebdd7ac367bbcd85b8e54e9058ad3b0992c7d7ddd5f065221c4893cf8c8e124770facb62185ea6c51554b8846ef3a0c6210b6b4bd08cb23302155c881f6331ebaa2ce94961e58acdf911bb80a93c216f36b9ebb4dd12741b709f2fb3d98211458011c163f68c97e4e267709b6a73fd46cdbcb678d8e0a8fb7534f8c8ebac9615e1ec487a9ff7e4a7c34ad879dc9545b946156b7ea4bf51c5f287f04647600df716dc2368e5adb351009a0cbabd0936124760b7eaede847684f0c2a803e14e86786f40b7c1b2de839003ee34524d2b9c4d22348a69ebd5047b6bb579e57d707212e6f078002f7fc30e8a7d52ec34d20fdfd3f947892fae1dfe241ae00aa5abcdf32a019729fc695f5530c032b42b2618bbeff75a0a767349e579fe257a9cd0d2be122c1cd41ed7e84e22829555b0ec0649da7d8024f29cb6bc9f80f427e6fa34c7e6650c0686acacf3948e3d1cd659168cf80e485fa4da24fba6ac42cc7d3b88d7d8becacea8f84aa9eaaf5d07ea0d8e88ca7eab64cda2a143bbce8a227d5ff8541b5b6a0f13cc71e28c1ec44e8a0b62512d249e18b33abc7ab78c9ca8fcbb40590ce80032ab4781df0b93983ca013868253a9276ee18ee504a094856a51646e608e039e3d07a56ee8bb35fc7e490abaad583b1fd069988cc8874b86006114decbede16f7ea7ebfe435e4b8f3e0bc74adf1f2da018496899ba0dd9cd7175c7691e01ca9550494b526b7c5d835d4dc71ccc8bac948c63dcda6d83a617e48d438cbe023f52199a46489cb69c8051608723061fddebcbaad43315485c45a0278b20cde151ba51fc8c848b2ed90bbd8d763e505b01d695670c3c598acabb7e1c22571d1866ef0b4632532352e8b7e2ae4fddff92c191dbef976b5cff6366373efcabf51d47d3742918d376136ebd94e16184b2971cab76457c64616e85ae2c375bec09f779116fc4de76f360d2563b77bc25e05968d83818e509a7fd014de55555cb6e515b8c8cfb8445acb6e92fcd402b66927270d8acdfbf67f143f3099d093def30e477edb8d8cb5d335853bb2d0180868677e38f351eabb513d4a248c46e3f1efe49dc9c87b9dddce70a820d1fd8ba7fc3f946629730116fd61a28946d527b73e418988ba7d6084c4186be7bcd7b765897d56239f22fd978a77f6b0573f5b55bb66a61c835f4f391904168390cfc0c1c8f4305c0c1a879118759bd35535dbf79ea60202436098bf9f51b079a6db9f0c4d51a979d6928af37aa1ce5f3315da5fbbb3673d6b8f34f769a3a96511a88b22b38d4718a689167f8833985e04f09ec7fe2a25c55622da75f0a2ce21f0fadcb00c3db846a0e73bbd856b1039c133e0c74067c5e2d156f3bcd786988ad0bbfaa259547593f4e7ec4a9f5aa3e44ad1add928d4980bdef82a93394c0eaf85b8d8fc7170a414dea661cb78e2e0a9123dc29120c969ad6482b6dfe22c18e11008335ded957dcd718749d6df5d4111110d7c083d0d974cd5aeb85da77f306ca9ed050e10e5059b81347519f27251d8f883ef2a8a57900d5623e72777c3c1607435ba5c110597496eaf250aa2cd6e602eba6290808775f3775f061cd0cfce41addefd1340510669c62c72f38bf01914d172b7f567a040b7f69c728073af9e967786256cb71dc0c2a6d6960df181ff4f2ddfaf297b03d2297a9b1cb6be48edffaed8f4c095a49f0a39b249717bbd88c7e1d2846246481ff7260e7581b7aa49b6becd2b9032923ffa703707b59899cbeebac08d600e48dbf6babb10452f239e3048bdd20e7e40db6d1700a4174207f558b46fc739164889fd525aa19c76af8afc204bcd26d2d0cd300455b8c5c3651e673184e303617f4be9c815085a7b4d802a8b2d7d7e3ac846ac47fff136ef8296cfd7234fc7a528dc06997cf4efd661902383e83b2a980070282e0b847f9adc2b58e4a33e8c1cee44fb9e5dfe819747738f6dd7ec2ab7102e36840809285c75234f75fe4ee3aa6b6c792e69412158ca504c7947c48550b4a025d9a81c6317977eb000e6d7cf9ba830357319994e74f286072281a69591b09a2d1f979840d11d97666bc0e906090b4fac82ae4abfe327beee3d4ec99c38c953f0e397a88c228585f1425895201d6cbac63e3efabce990c06cec6a97eafb09de1427d71be9df9d7f077fef6cf88a9d8ec9f751f392940c0a368f7bf3ca71958a6ce60c651591af08a84afaafeb441059adac835a59a9c2bf0aca2944ce889aeadb8f08b0ba0e77235e8120944b456475cb9c9cf80f07be98e62b5f153fbe182d12c6f45cd263cd78cba58afe21d18fe05f6d7af1bc4faad9770b8945181c63e61a86acc2fa15a34cd54a4e5ac17eae842e7b66753258fbd6df5edddb667ca7954974f802d03d2111019e5a7e4fe33e07e2a73003299e367261a8579de386b5bcccaa7fb44e80cff94465a0d466f4b4a4a1bbe54cbd3ed544272b908b414fe527de673736dbff9cb573f37fae79248598cc0340d5fe5fe41ffe7c34a2332489a966f514c27a7f4ff7844032b7381059f29b2f32c6571e1772941e52acf08f2e6bf0d9c1ed77fd806405a381843a48260cb223c8261386048ab582ea063d2ca4fe678a4a32206466038dfb2ac1a68ac606dd5d7246c76a213d01dbac95f52a0863ba0a915120409b0f87113d0e507575c1f39a59fb6c2c4f1cf44ee14e340b56127ab4fa0a1f45772fdeb8cc4626d73f141dc117d53ffc86d354f45613d6686fe0a63f3f95235441e44f13a560adace9907bb802f382ff846333cef1c58918b94c73a5d2e1b880756847123ca3388e4436a0f27ed1eaa50b0a1a3ef4770a51c846555472cec58bd25452454a10122ecd286a929d86867ca5d3490ce8bd9ed25f41a3f47457c9a4d74a1ef415929a96dd191b9296f4bd728a6f437e0bc7ec51ec3f802befa4e4dd950224275e60f8822d8665c4ce12eb7b7b936b3f0fc22ae1035b9151848a99a925d77d8880562b94a3c30a229e7535de8f828e4c7463113c7ea0fe6687f39cc30d500659d12f1f6b426b376fac900bb1b15c71d85a006ee503155ec0b4fbc1883680f76b56b6663dbed4a04c55ae26159674f630140e68d4b4e9d13adf7ed639d36512c3f7e851bcf8d5537c5e4276e137dadda1b8ecffe9fa4ced495451f392f1ba95fd01575b5ff8a82fcef0a998c8dc761ca3aa50083c0ed61d77ea8ce217d99cafab147dc3da82ce97c9a2e7da53409f6e53ba8d7e61cb54c457e3eaab2c389939276617009a41de6d4178af10bafafd887d3a5da6df2200301242bebc1aed6766e6648d0e425fd0c4738c0e90e86ac98178a2bbfdd87e197365306a2659a1955c326cc104fd93f63e08060b8ad5cd2618a00074363f3ac1349a73ede38c8de350bfd28543a8cbd74c0a32e77986194541c54fdc1f7108acc46e85524f19ac66b3ead9bcc541b70366f822c419896952cb6547b7d85a959b97043c1a56e7e9c64fc9324349178676b1eb0c25d85ef25d76fdfa0ef7e3113bbf6ad8967e548f72217e18e4dd01aa7d41b8a556f3699fc4d074a2ae398939399dff00f9b29ce134682e0392187a94939e941b50753b11de2a8c6d6551aa481877b351903770098d47e5c957063675d4a61b4bc99d333d565dc6f552f6b44a0fb67d4f4b74e90405f9f82dca30e96ce06d78acb9c00a69d6322b946f8f6668872e1e739390c7599e0ea888d399a430ae73b232ca94069199091fcc65a0dba8fc64b03da5dfb1b63efd122f388b598f7ce4d16cafe685f79db3263c81c81a41ab680063b2b75c784f0b0517c0bffca3bb40a96d81f89937207afdf851bbc5ab8a35fe8ebb5a497375b5b3770614f4e682e665fb677d037f86c92473178f058a0f650f1353a6cc1df987589919002dc806314f6fe01e6bbdea34dd66f381957169444a865f05ddafc20e58a3c9905b1fe1de612e76cb085771d39e57b64b24abd23b6172f4fe794c8c893fbd490f2f5693aff70320a4ba7619fec4cafb1d2bdd9c4746ecb929d66eeecd49338664a5c4058e80b7298868466134c328f6849ae3f1bbd4d42ee9f62cbcc1f6ee236e674520d21a7f8d479fdaf588e39c7f841aaec06bf8e2b3dc8a939d99bb371a2223613f5297655dd398d206c64a774281a04257564cfd8988e4aac18936875d050ec96d697e9852d5152f0aaf5bee0d536ef43534ab8d06a057c4f9548fcc2d8978b5f43232932140a856b3da3a33de45128f1adca8e238a37704e46403b856b1e37003ac36db40feacf39782e74a975c5a5bcbcac2ae2211c9d67ce38d2db6d98d0d286a3408a32cdcceb9f2f795156bdfd2616c1e2938116f15bffc8ff857f0f3e52fc9c2536687ed1fa5c00002d7c608e3d101e925aa7dbd45a9d58f4d86060c0ea99ca13e642f4ae8343fb1a526d509d36a4e49b2a8cbe798bd01ab4733f64cbae4fe4759b168eb12163051c075649c266d05225954edf4c2a4f39b2b3b1c90c8f9babfec61f4f3cf2910d8fcd572b1dde8b7657310d9edf57839578a1e96ffb8d8d128776503367e0552ca1f333869ffc66e46eb76d71d54487b839025ebadd77eb2b80503d3c6b4bbdd6524d1f97bea5d42488d324d664bb94b5b9cbc44e610f4332feeab37610f1f7274882e373bcca1bbae94bf75411c1da53e69c42cb739dfcaa579f968feae1b94694faed8212e7489cf2992f4833ae0e4bb3987903b675a5a4914e6391aafadf2f8e1e96638031e5c0152969e2dac88e37c3e64a76e2fc3d449ad00cf2db2b1b18ce11cb99dc636886e237f693b3dccb03e127be09225b1e5f618fef7d1dcaf3409228665bafd1f9894ffbaa3b657da2af9619e54c9848990ae12fe12033cf8777ba285f4216e99be0120f5445478c7673fbb9d0eaa20fe429f5f1395fe590e6e0b9b5fb9c7b8bca3fbe3815be0dd4f46b1b05757feda88f2e9e83c87ed1c5e4340acbd25cf5df52a802c3251e39eda6a3af904d929ee95f0338469a706b11bc5037a8ef5da9b23eae8e976a0c25164aaa1ee35fcb66b801c9d3b7ef86037bb08df936268421a0e4882a999e41a8d64b1a50df5d10dbe54786740b3f32692a92a6c739ab947ec01346f612e171b73ef915cd9b4844cc0ef6de262ceee0e56b09f8b8c9c048f56375daddfe6b8b0bc91e1c07ec30aa6b7c2ce7814a33733f01fffb1747771ad0bde4f6369771ef47d4cec4dacb3dee81937103fa54a1d28c4b396e0217475fe6d7771c194ab005605b26a3d6f0bbdff9b3ebbd22703a221993e7b57ea5cd6b101fbe0449f79dccad10c7c2e2bb385fe91a2529ca3e1945ea850c70d41f5a7e938c0819ffc67bc01d80b348e1c29cd49ff689d5d70da1d709640599374e8c8c9d1cd657cf796ff157d09a4d7fa539eac8dc3264869787596e6720b473c3003c400b06a6a64c4d750b4fc62e3699f04a55ef678d08e045337122be55666bd5767e342199a62f9aad342034b08439c61d0a39482d9bb4f7f6500b7a438682a3db68f2ca80dd25c443b18c5cc30992373627a27750b1b2a74559b5424e17bba3281989ecaaaa14914fc46883c4aaee065786ec1d7f73eac058a7fd0fbf14ef96ce5a3b0854e5f0e08fc339511bb8f65f439676e4a89bf0c9a876d0d22cc71ab54f228c044f9565d37a6d7cd8416c7620a52d91946fd61eb14e99cebd4736effe42669f656e2d4c17fef371fdbbda791bb7d3f86c56b71c59b24caa990d61620d6e9954d247b709281bc16de295514fc71b01ad924e263a118ed6d76f4e66d1de0d2366e9c40a189c304d82ba32ee269cde8021f775987bde88a4ec3844f3f441cfa944688c7e90d0721096750f0b9eb32f421f9c8eac6b95559947e884d14fce35700d8977e7416a059c9cedd68ef19593593d83580e23759e655ef9ff7ea317faf8dda4ca153b2318f8a6d651a0f7c599d6a82e03d4263728cbf5bf44634c1b789076c8bd849c3c57a84c7118cb19a7ca85085cb03e3ec555c16a4a2c68fecd24c8b442b0864e35cd9851d8046628d2236a0126397bee97b422f62af2ac2479ea772c6553dd81be265af61734e4d87d17d0a3728d94b1dd32cf679c49725c840665e4307b255a46dc6ab26be13c9270faa41d4dd1fc6bec748613029e884fe50d59e9d5452b2fdb7872f3681df7906dfcae5974d3aa4e59f16aa2141391b1c87a172b1eff41310f52ae0e4b7fa13bda73f17a7da57721105538977b73dc7faeb890959226d1f642f47e3be4d5ceb5b9bdef7cecd4a098490befa3fb093fda1c2233d97f81bae50d060c79f90f7aa47d34c355724e90d241954fbc5b1ef2bb3b9a9364fa4f01bee645998d2053b1ba9c2eeaf6893e3f04f75becc4c33f47c9f2748ae684a4655597030a9e3bb1ee0c05e40e1a45ac6b5e08e021d3a05151ed4c7ccc8f4f1479f5be2df4b54800ea0bb24221058847a676ea2f573e8667d6843da9ad854d49391de992d35e3d72909a4591e1308114fbeb86c240e907c4af70956fe561a65216d35067ca9c51ddb42bd38de5194044e97307ae12807612b42306fa94b7f861735ccd1645a09bc5373e6f7e38d1e718b4f6c9bc2f1d255575409a5c5fdf92378a49c3af42834d2e617c4cfaadc48c4f7672fc58e5262a132189429e8ee6e25cd80a91c5e3cb9f7bc64e47463a03e85bef9ab3780fa1cb70c7cddfe1b287c249e5109d20f3b214e04982e28f316daf4a9ecbe56ab6d96a1e237b93e3a7c70cfe6b1bc57b2b28933a8fbc3a3cf27751c9d42ddf3389d6fecf6e115d1e5f8612cbb5e7c87ed0df85bc6055ccb993f6db5c8c4c443e173a20e9879dfc66e55a3bcc1a303b1ef6b9a5cb45ae8c70ba2113f5016062d4d342d46232b24a337414266311323e38816d5113ad2792ea979be353ad4f3aa0f5fa8f0cb89b193d67b7a037603a131e30e46a468820a257d97cab725d49030a38c0a3e1e312468d9fad5ce0c90af183985ec0354a57b660a957889ab3319a1b2659aa6c4c0f8a38243236d4bd6d429d971ad8759123ae300e06ad0d2007588a9280a1b449dce164ef41e99fdc10e3dff53d7ad369a3ce2697ed52f4d653719c983d64ff2f072e7fc93b4d9bbd7f4cb1d65948fe47a4283cdecc72a3170e55e8327d5a23152b2ac6787d1c349930b1a408adb2b0ce370089fcb9845894bc7d775b5b8438ceeaa1e8b0364fc05a891041490abadc92a4b05fcbc3895d47425619f906b06348cebc7ae8a54646f762ae0cc80fd5eeedf059c4e4ea84a27c822f169fb2f9929f6707e42b17050e7bd54d54613b9b9f8679ec016dc11a7fa2822635631ed858eb005a1382b4bb030d9d48718105e09d3f58e16a65bd80e9c8e85219b977efebd6dee91850efe0a7d9670b6232616518b833cb6cfc93a4b11d96a1cdffecfcd35e5d70ed2e081811c56c71c45bae7a27d3160078ed6d491bfd798ead8e86cd6b4acfca4c6892542e664c3b0263980c9a2b0835f706a739292b183497a142c74c78738b65e61f50ad0b6f940ec4dbbfd9923b5268232d65104d7a9585e5d4eac9fdd854994765f54992369990f0e9c88ca315e83f5fe114dba64566d6ed94bc977bc045febbedb2a876bf4505006fa0f01f19f3c5c31ac774eaa21e20cab0ffc959c368e38a2234679796e9ee8fc47a4cc5f6834a7b94dc0c8d49642b87596594ed801a470cb1edb8a89f07f8c6751d1ef6f64a1ea8cfe275c8fde2f4a12cba44bd9ce55c27850226c3ae0929034bcd99a6ef262f2d49fcc31f97792e53db9686e31c6679514d7bc9e5f447035f79bda1e8c88e257389d6e35bb005886584725340f048d0a15968b7c13010a09c580a6632d1f42c99af6063fa0165d33bb2425ad80864dc926521932e9c29852472392e11ae1e728b1da1c42d9851152ba3be602732404c35c601d3eaa73b4fb2040b0639096564da86a1c9baa73f308341d9e58648cfb4d82ea9a49797124f47bf6e4770e42586343c6b3d883b37c63a336e7f0bed64734414ab228f8998127347c2ec8134b9dfcf80c8b4c55148b98134bdf80f0adbb476d68dbde961f59dee3db52cc8eac177a3de7bc8539f034bdfccfa18a2f7a3aa35a99b29c1dd383b92aeb81c5808a7d66a08fb2389e72e2318ab0d66e1d31ffc9d2a489fc8d87debf8b74232a7480139f31f87cc4597aba4c68eb69758293f07513df4a93152c0afb46badaaf55fd31693d85a67e500a2526de659e068bc331104661fc9eb3e28e3656d62a74f94b11fe33a5cda59c30b164343822886ed9cc3af60cd96c09ba4b3b7c3bbddc7f491fa450bbcb4b4332ec1288e925b2bffb26184e92a963bef7d822a9a50c3b549232af0575504fee8dd1d3a8bced38f9193741d384163568916a50b584dec4f4acf5afb528e07c7954ce26191f7fd96f8831a6aab97315bcf26df6c049765bb3159454134f3930d7399662049bb4844f3281e05dc6f866cfae44a4504a9a64cd12db3b6b0f4d6bd410d4863790d6400a9315e6772e59ef888b50762a1a93314ddd7b4a66cb5b6bafdda0740c311837f838dcc09b5fd1087344ec57097522d10c1cd111ccb936a6ae0858a574bee29a6af5fb04f177607bfafe056b3a05d9e929b96b503067bbe83ffcd42dfe3f22ea354dc5d965eaeb7b60c9135129b1c8ebf11574f28fe09b14b21fc98422f973a88df985a0422a6cc2ca2ebc0ee90cef982fe56abac7b424158c40146434044071bbf00c88441e4b808f266c4e16f8b12c8185cfc3df9b6104829fcac10b4686d09012b9f8027d06b41bd64b91e13057f4bf92dff371ad0aef89ecb2444859eb5e5a61a045f2b2d1ca8b7f327b1a554621a6ac1e3dc16b54d98cb8084e3f836c8b684f6a6c1ee8d8cd922fad59559f9ad86217dd22c6b7b22a1b07ee5884158ae4f9646916260fa82157818c138af36cf3748add8420d9a00c2dc3847deec2433f8923be0ab521b76b5fee26d593792c8d122d18154c35d0874134c22f47b4ce0e9c5437febf5aa781cb701f586eeb05d27cfa70f72f662e06cdeaed6e7dd9d4d68686cb40c4b1890640f6aac59942105b2e70606df518ef62d0132cf30ab8758732098c91a80dc627c2f16f8cf2e3dbc885fd71d5677513cdd60d56f1637df0c44cc0c0b3d80c6de393ecd9a3bbfc1a85cbee0d53d584b107699c40eaf275e3a9dc940b2dc2772f90ef39eb0e04f7c60ad3ba72897387795556e40a089d34ce0e7ccd92ebf05cb60c6c20dba67572b6d8d9e1cad8bb44d085043b4fb6e4c98a256628cafe0487234a43608664f59d7cda84e4743e9687b026215033e6e1b04b1b1fa9b6ffca481947991027cb7e1333a68477a1b65fa06248c4a95b43029746335784b3fc2ee2ae7835e215cf56d3bcb892591d688943eb8d578eeb0ab9af1d124d8b20c47e08067cfb565efda27cdfbb7e2e9703cd8336c1d68c75b9139d8caeb11369f6011100bbdedcf156e4493f999b13314d7d29ff052b87b2861094d5b843690afe43c9adc03011bc8d70af203bc32895a86edd2fc3e4531a44fca50e003574a464939b030c64ca7513ac59abe92b3626a41d1dd323e9771086148a9569ac36edfd5dbda5d78012bc192566c0e3dac510743c29a128a7b43c128a069fe6951d450ae7937407bb9bae32e51074efb0881c6b0a403e7b33b543da0caac4804a380b42042ce9958f6fcc41e79eb89f8b5a55baa6ddefd5e376845ba53597d043e8540b22df02e4693806616ee6d093e2eca1d25091e316cdd9e3eb22f408b548d1181b76fe62403c1f8e05cb7936a771f29410368a75be9ce56ee3d620fe6a71e454c9238c4c8b28164ae0400658f61aa7c6ca119bdc53f14f1dc21feb7d14e5a449c2f53acdb0ba08604ae52ec718fcd78bfde637a0550295fb0867215d9260680e3b52f5f340719f95b32c2134270e6858771e9cc0ea232c6197011ea17d6e62a6c28848818e035f537009053fa86f3648c65cb8481ae9acfcf0a160539304f0a8bbdd63b46e358bc19f1e84b547325bef16b2ca74acb0221281d4cd35dec9d1de911f54672ce287e74b6cf55794adb3e485ab7077482e363519339fe0ce3305956293faaa63da3f4c30a1c8c7f89f8ab8a828cca3108efd0869d39b5f7e9eee43f0e337324b58b6c9e2e16057ef8cb5ed40f6675d87022136b8d6ea23aa7afeb8ea8d340d4cb145405dad383bf3ac887f4e4aec513623c3c8961ed29e09043f07972b4bad1069738d954e058d0255f118db6c6e27b5ac22c7a0240e068c6bf4d98d0bc74ede3ccbaa6ba3dc751f84a714adf785846aa3e610cd76f6527f8c3fa71b01dd160a146f6c11d301e5f74ef65fd3ea036ad75a5dec8a68e1927be04ea82a5fc81475ab0441381670715d7fa41b4038701176e106d8602d6c9e44948c6d2b5d5354c438973e6a9c0e86f0554980cdbdca0354b6e136538695fe1f198cafc91b714cfb3104bcb4e7247fc05d5c3846d54fa5e771220f69139b593cb1eb8ec450e5537c45baf84bd1886a6c35df32dd958c5bc1f1f360090a79d50b4508d88e4dbec69e7df3a22a9b8450476f77d006106a2536735e1f5aaf0422eb0937aaed4ea9ab89f198d2d0b7c416852e25437c2fa939a5638ef18efca5c50a5e36db390e4eb361e90aa5ed020ccf7cac6d96590652c5c198006c00fd63c646a1f45d23912569d03690387dc699577cf53e072963e9aeb8d9393d876d967e38d6449521865746e83a42fb77ca32255ca22e0daa51d478a618a82b55475f1071935e29620198f5b7c6b8144e3b26b3b12f1954948ec15c48cb465eee3c14d4c84d0ebbb5bfdd673db94d3c1ca0776ed4ce4f7ea4d76bfc26213822ca2b1c971e56b3a2202b51ac0fef7c2f1ec76dc646a6821a984453c085b3507be4d6756b2d239f2f6996cb1050774cd9bfe5b8e64d5ef3e8505b518ae08c9bc4272c816489d9e8054ac19bcb6493741804de1f31aa07719e246c84c4e22a5ac18251397ce7456d803e6a5f00a19e99a670338a1d6fb6fe880747b4d348b726999e44a6aeeff42c539a321b618c13863f5268fd25af4e7a8d8644a7a9ae2660a5432eef6732aa1990ed1a7577ce81afd86a380cf238c19bb5f6c6c629362f1520721a0663fba29f594dfdc2ac81c74b4c577ba0b6f181a53b0192da69005b87516b9e48f5522b75a508d5f7bb35b3524448e848fa91fe9e3fe4807e048eef1fa2f2ec0ba42c32de0fd70218b4c005bc53fb413315ed61a1f57368504a1fcb2f003484c3f48495c0a4e563180f8877e4d5e8ffdfa4b7415a904afc182a359626a3a6e7ad5f2340bf294abf5acebacbf3ae8bf8d00623f19e15b65fedf53a9cecbabf456b5b6e4c13521a2033728212dcb35ff93618e39252a0ccd17485734a5c420fc88b2f3b289b6c906acc4d18fd13c5e7264a9306734d779c461403127fd0b7606a2390b796761a9b9fedffb64108e7ff8cccf955d6fc83e0cf10f9343e6eac7f0558382099db9a72de41cb07508c6d6262ba5926531730951e75d43c524f311004136f6e54f1c0edc1ecd3b10daac4308823b44412f7d440b305f64026c031448162e18010718dd595cee51972703e2236a8daee88331e03988930acbfd7bd587df961ac3dbe2b0b8f265d1e0673704875420b597e2492a33540b7f568be58c79dcb163880c00067eccda2e3d6db79677b8d1e72fc808cc867b015982da0fb44e9d4b1a6de137afebd45a0c92ef5702e53a8b70a47f661c93d20ab496dc4a46677c3c5b8c9eb2ae00dc37a88c6aa8260d96fa3569831678a6d8122bee3a0fd3447564415705ade9b702f313841acc24eeaa08da0d106ca39b91e11c98a15611114c205fe47964f42a743e89f41f057d79c1b87f3aaf1698acdb2de554dbd9367792e45696c2f2e6fe6b69dc0ee246f8fd1b682b4ef1af6da642ce633a3eaeff85da75bc52b298e8109329f1c8629639545bf450ecddc8483b167230c3daefe342ae75bd21389dd9288f3966b049482b6b33a90b27f279d7beb2c3c47bb54e1f0690bb33fb76530b898209ee5553381316bb2a4faf47bfb5d9972e4f91ebdd86688a0276dd9990d06cf1f4bd99a5f7197ab6c345f04dd6713a559fd1758bc58a04dd97695dd03e915bdb861df0b6fa2b1e750aafc8960c193889b02c77bfb04ae9c6967d3303f1a5625e302a1ed4135acbe91c51616d664735354f445c69074144a66a000ad454fba471b2f3a5b1bdd4274f03f083478430835047cabe03d85d1edc8d4ffcbeb6c47260ddc20fb7378b6ddd9d70ec3b63f919fc92263a64b9652a575c87e169e519e586ce04f89fd80a6f99b33b8fe6556478d516901db2180ef9cf5deca26462ce96bc505094df7b7cc80362be5c60f785390ac66c9d97b59b7ac31edf6cdffe10456b504f1f9639eafba1609f1b64160a10672a7f7cebf3a126629e0e8499c9117e65dffcb3d493efabd2e8555832d75203109e5cc2c8a18a39ba91d6e97ccf0652de701d4cd772e3cf2a9e9ad55a75dc6221fb0567dd5f6b19059ed75b623063adbaa8e94fdd3e7d930ccf58100d8613d4a0da154bd5042e5ac1bb96609edde45f6e3c8f1a139c0951828eef14bd671f602818237908eff97fe420c91130b92822c9b76bacee72c507ecbcf6cb21ccee94c010cba19d7acea9c9825093feff8c885cf6aefa9f421827463f3940aa3fdd299aca8030862efcac1fd6041ea7981cf3e8ab90a57de560000a77ca75fb5290314afe45d6a7046d618af29c73998e18625a939fbd612b6da5b4ce643bd6114f6c27df3bd38cd82d1b6ac2c540ccf3cef3b6f49deb2c42183b0f5e2d49ca4f9f550472d40978467ee004a4e05bc256d0fa4bd26fd2d09b20a99fd9819e85f78475dcf7f0aeb16b0c252254f0d754d53ad810002b6da98a321a01cc91da0dbafa9fba61c5c6412335524329bf52c800238036e67e76a5d5422c2917648674552dd6bff98f8968a83933e0e6c7351efeaf7c8b8b64ed308e30a10c0623555e2549b4200d9d8ac969bd455a2da753dd9f99856089c4111aca7428e22cbbb096ed7aae6f02c3bd4cbfdf809644ce299c91d86c92a3237249e826decc56b3c9f4c7b1ef23c52fee3c681d7540b6f55e7b0e2e7b94f8662677b99890d7ffd5808e437dff4e94dd90192b2a091c431eac4838d91f0bdc9e6b9cb83a7f17c63fd56eedaaa0e33869511ada32c830227739a575ead36b782ca6805843b4af13b673e2ec81939abcde6552a3f8f87856c4f633c323d8eca5ffef22a360e8fc751e37a05a51bf798a6831e976543fde306f59faf940fdb05494e7dcc7bab4aa49b2ab15e74b5b6f4e90aaebdf4b3d9bc037dc97728fd60591fddb6907531e0d0c9a3e97a1789cfd9ae0ce97f018a24c90afaa135b12f918ca68d087cd32f697a9b2448a0e707c716fb66054ade170ba1f57273be92e7765021a1228841040f1251e322047edf739cf4d9233ed225628d6613f6f4a472fc08b19a54502a452809943d20c654a27aac77c7c79455b0b384418773b903ddc03331bf819edd846753165b8dd257f1691b8425bf4ffe27f1cd708054fbc47eef53e144a035327f704af8d918555ddc59deeb171e8224c0ff358e7ad665b3d2133f66ca9dcd9c0706b79728cad71f07692ce29c13160eac8a1c29dabc3708fdc1e6a78749edd31bc9a01da6c24cfe790a63cd3a55b15ffc4d4bc175c647228fa3b12f5d149ee55d744dccb5587f6604e765284b95ada623296e2782fc6b60c96031a262a4a10bb7dc617a3fac9422ccae3c8888f8d77b2fec4a2d667f48c8cded2fb5dd67a0c605aea5294f89943fadb2f50bcc851a001c99269e0cdfd0c23b002518b6125e77509e84c33b7b2064263f22113ccac9c326a857d9563157dbc42911bf055573cc89f4632caaa2030a1d032c7c2ddeaa7a30344d238f647fe8e5ddf2a935ec45166e6ef5567603e7153742c008f4da5cdf8899f39592595603b567eaf91e95a6be75f0f5bd00e3008b3fb5d1e5387272d90865a6b1452bde9cc7877091d393e8321549d8c5e7c98df3cd0721dbb51923e0c3b46e51fe991468f8160e907fb85f66b0cf7b60e5db14a038542dfd1bfd9115f59cd78a9906e76564b2aaaa224623f1f7ac7fc4823d6ddb3e16cfa70b99d1676f81db9ba235dc680327d37fb3503c26e097e122c086445f7fc0fc78f69c919037f4880f542ddc88daf04c3e4174e45087ebadc20f7607503be8d8f02cd467f95f6ef1fc0e3599390fa5cebb9d56fc7bdcd72fbc30d7a8f480bb2fb59dc2f9081b4c4816df549ab5687579d9c38391e77d4474746949f20d84ef8887c8bb5918533e1e1d75a6dfe8f5f48b95e065cf24f2ac1e0be9cfc71e1b9f1f4de8fd6b203d92e875e205492a84861a7638c9ed709f8b717aa3cd5f98c2d5d3aebe529f69acaa1a60e47cbcb69bd6f5bf1e0e4565bd972b2b6f5f1b8fee37fcd0a4a815539b420fd71346930b01309db1a5157afdb072d1d024a03e30c6d8621f432689803fc2f4d1a4125d1eb164fdf70fac01a54d80eea764d6e2afc1bf28b8720e0e67d124e51d532b0cee2441005503337504679dfd6e2abe819a2074d91a2c841ecf069fefbdcf04b7c81ffc0ab27e7adc1ad0d7d2729eddacf1c0e5f23bb48f8efc0c07fbf5b055176f87cdcac4781d7c9d6dd475c69a93fefc6a34e08afe7ef68d4c9b14e7b6f91e9046d78eecf0c59fd0d39345aa60850dd7820209ba32ce4779fc47c194cf46eb686c36a0e8dd4534ae88665d0db86d354271725734e849a0684997084e676f67ae812f07d3d3ed2880bbe01160bca8ea34da253710f00bf12717aa716186970e484479552ee74805c44b126c4d5ac1ee99b5e4c4fa05f4c4519011d0e48bad8ca868cec64e6229d477ccde8907463e61b702c771c8454081eed8029ba725b31d5f449ce1e0ad1855f3a1e1825f9caa69b1f35ab96836b0be6bf0890397b06fc0dcaec3ce202a5fa9e06d51ddaa14a250d3213a90b952e5633bc96520b4075491d1ac809b7b911d3af7fa70c82a28efa110c152c395a27ed3dd54085d3570d398c73a93140bfbb3240447af1633ff345f4f813e0e3f7f792422ba8f00cb7471cd94307ca24a3627f7e623a07f4f7ba9ede037f132ec303687b7f0bbf50e7f6a4092901b7ff9814e3d9a4adb3834c2f0e908e8deca71cca0da3863987880700cb131284b30df2811f39ca611b255447105d028ab2601a70ec53a570b3b844491e032259c8152053f195a3470e05b9941f47620035ea6f3c3c28192dc5e3576d6bea2ccac2a15373e9f06c06cec755db322ed0446a58322174af17ce2004f6b5a31cdb23680fcfe431fab5ad9c75e4e305474c4c2d67ccd9491d59dda3617147fa536b71f68ae3ecaf8d19319cc628023b66cfc699266fe5abed35efda5970ae64bdfa8df88a75e07d9b268532a1dead70cbcb125aa257743b3f2f23776dd513349517ac7bad9b8a10c7beaeab325c4171c8951510e57b28b5330b52824a57626903b9593f31aa9324fab1e1c84ea922138fa80c3bf232f2a7ff6f8156bc4fce13dd5d2978e89c867be0ac80a90e7f42d7bfaf21f767c0baf1c55460e162771329b9659a065df2a3d2e3958451c0761f3f76f18e5701f5321617741559e2e796a8ec771e061c49a88df358d794645a4ec8bb6114ce576158139216f7ec8930267292de6d9e270ada3d2b9f23bab96776333150569dbe62b4185080f66b8a8563acdaac30831869b716d9ddb75a6087ad5a6ce322b4941b26ea9fd1a27afd9f6a9cde1cdaa3fb53b9512d9d099dafdad663811451174e849404574e10aa4cf8a21dcb2ab5b75f7e50aae75c45669c9dfe2e1afee076e728f1f5a50f734f383996e7c7b1ea0ce679084bd47962082f9f35cf47c263804ed5158072d586249a43cd839a545dbc0e9f1d9b6e9f9921101c6781c9475dfe37698b7c636cc99f7c7916ed21424b17350168f0d67b6b358056d37dc86b6c3ada8a35b3132c40224c9a2a4ae3e62c2bab283f9e19b263712909c52ca751d2745b66dbc5798b754b9d153f5e373484f76237049aaf6bad1ddddd62ce86920d71aa84a13d47d5468b2a4d6476ed705aef29dc984295dc855d0d5a944262fe169807fb8efc9825ea35b2b09a3c316657d6187c012edcb66ad01dd780f4f3ac2e6a1a68ae32d39ee8777be4e97518ec6759a47979e448028b90cc940ef96fab61a53695e0bdbb37976c2f4a69daa3c8014f1b9badb0ac57d5080601a84cbb8f1ca5059c34487764ab85a3da74852e21b75a00a1ea21791811fa23731035d21d2c2d96dacfd8e798f58a149ed39d0cbce5816d6c16389f8e644f13e87b595784180b45547d4e3364e562dabf4a3c391900b68d3139ba7010ba74bc944fad96daa114223bb3b3059857fcec755e0cdd187bb0a625bf13c38cf4d72e06f25ae54ba1af3d80774e13fbe347171c8646dc8f284cd40963fb35749bac7c6e47c961fd31ac08d98d70c3ab1061a6becbe5792d86</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好，请输入密码（我的真名全拼）</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记 - 多项式基础技术</title>
    <link href="/note-poly-basic/"/>
    <url>/note-poly-basic/</url>
    
    <content type="html"><![CDATA[<p>本学习笔记主要是用来总结一些多项式基础技术，包括 FFT、NTT、MTT。</p><h2 id="0-引入"><a href="#0-引入" class="headerlink" title="0. 引入"></a>0. 引入</h2><p>有两个多项式 $f(x)=\sum<em>{k=0}^{n-1} f_kx^k$ 和 $g(x)=\sum</em>{k=0}^{n-1} g_kx^k$（把 $x=10$ 带进去，这就是一个高精度整数的一个形式），求 $(f\times g)(x)$。</p><p>朴素的乘法就是逐位相乘，时间是 $O(n^2)$。如果 $n$ 级别达到 $10^5$ 呢？</p><p>我们考虑用 $n$ 个数值 $a_i$ 代进 $f$ 求值，得到 $f’_i$，以此表示 $f$。也就是，我们用 $n$ 个点 $(a_i,f’_i)$ 表示了一个 $n-1$ 次多项式，显然这是唯一对应的。这种表示多项式的方式，我们称为<strong>点值表示法</strong>。</p><p>我们用 $O(n)$ 的时间，将 $f’_i$ 和 $g’_i$ 相乘，得到的点值也就是 $(f\times g)’_i$，再将其变换回 $(f\times g)(x)$ 即可。</p><p>总结一下，我们从多项式的<strong>系数表示法</strong>，<strong>变换</strong>为<strong>点值表示法</strong>，进行乘法，再变换回<strong>系数表示法</strong>。乘法是 $O(n)$ 的，用朴素的方式求 $n$ 个点的值却还是 $O(n^2)$ 的时间。如果有一些特性使得变换的时间优于 $O(n^2)$，算法就得到了优化。</p><p>下文默认 $n$ 可以被表示为 $2^k$（如果不够补全即可）（原因是便于下文进行大量的 $\frac{n}{2}$ 计算）。</p><h2 id="1-FFT"><a href="#1-FFT" class="headerlink" title="1. FFT"></a>1. FFT</h2><p>FFT（Fast Fourier Transform，快速傅立叶变换）是可以在 $O(n\log n)$ 时间内借助复数完成的变换。</p><h3 id="DFT-概念"><a href="#DFT-概念" class="headerlink" title="DFT 概念"></a>DFT 概念</h3><p>DFT（Discrete Fourier Transform，离散傅里叶变换）选用的 $n$ 个参数为 $a_k=\omega_n^k=\cos(\frac{2\pi k}{n})+i\sin(\frac{2\pi k}{n})$。容易发现这就是复平面上单位圆的 $n$ 平分点，以逆时针顺序，从 $(1,0)$ 开始。</p><p>它有一些性质（可以用其几何意义解释）：</p><ol><li>$\omega_n^0=\omega_n^n=1$</li><li>$\omega_n^{\frac{n}{2}}=-1$</li><li>$\omega<em>n^k=\omega</em>{mn}^{mk}$</li><li>$\omega_n^a\omega_n^b=\omega_n^{a+b}$</li><li>$(\omega_n^k)^m=\omega_n^{mk}$</li></ol><p>概括地说，你可以把它按照 $1$ 的 $\frac{k}{n}$ 次方来运算。</p><h3 id="从-DFT-到-FFT"><a href="#从-DFT-到-FFT" class="headerlink" title="从 DFT 到 FFT"></a>从 DFT 到 FFT</h3><p>首先处理 $n=1$ 的情况，$\omega_1^0=1$，$f’(1)=f_0$。</p><p>我们把下标按奇偶分开，即</p><script type="math/tex; mode=display">f'_{0}(x)=\sum_{k=0}^{\frac{n}{2}-1}f_{2k}x^{k}</script><script type="math/tex; mode=display">f'_{1}(x)=\sum_{k=0}^{\frac{n}{2}-1}f_{2k+1}x^{k}</script><script type="math/tex; mode=display">f'(x)=f'_0(x^2)+xf'_1(x^2)</script><p>更详细地，设 $k&lt;\frac{n}{2}$，</p><script type="math/tex; mode=display">\begin{aligned} f'(\omega_n^k)&=f'_0(\omega_n^{2k})+\omega_n^kf'_1(\omega_n^{2k}) \\&=f'_0(\omega_{\frac{n}{2}}^{k})+\omega_n^kf'_1(\omega_{\frac{n}{2}}^{k}) \end{aligned}</script><script type="math/tex; mode=display">\begin{aligned} f'(\omega_n^{k+\frac{n}{2}})&=f'_0(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}f'_1(\omega_n^{2k+n}) \\&=f'_0(\omega_{\frac{n}{2}}^{k})-\omega_n^kf'_1(\omega_{\frac{n}{2}}^{k}) \end{aligned}</script><p>因此，每次计算都可以把 $f’$ 分为 $f’_0$ 和 $f’_1$ 两个大小为 $\frac{n}{2}$ 的问题来解决，然后 $O(n)$ 计算 $f’$。时间为 $T(n)=O(n)+2T(\frac{n}{2})=O(n\log n)$。</p><h3 id="从-DFT-到-IDFT"><a href="#从-DFT-到-IDFT" class="headerlink" title="从 DFT 到 IDFT"></a>从 DFT 到 IDFT</h3><p>IDFT（Inverse Discrete Fourier Transform，离散傅立叶逆变换）就是要完成从点值表示法转换回系数表示法。</p><p>我们直接考虑对原数组再做一遍傅里叶变换，但是参数变为 $\omega_n^{-k}$，看看结果如何：</p><script type="math/tex; mode=display">\begin{aligned} f''(x)&=\sum_{a=0}^{n-1}f'(-\omega_{n}^{a})x^a \\&=\sum_{a=0}^{n-1}x^a\sum_{b=0}^{n-1} f(\omega_n^b)\omega_{n}^{-ab} \\&= \sum_{a=0}^{n-1}x^a\sum_{b=0}^{n-1}\omega_{n}^{-ab}\sum_{c=0}^{n-1}f_c\omega_{n}^{bc}\\&= \sum_{a=0}^{n-1}x^a\sum_{c=0}^{n-1}f_c\sum_{b=0}^{n-1} \omega_{n}^{(c-a)b} \end{aligned}</script><p>$c-a\equiv 0\pmod n$ 即 $a=c$ 时，$\sum<em>{b=0}^{n-1} \omega</em>{n}^{(c-a)b}=\sum_{b=0}^{n-1} 1=n$。</p><p>否则，</p><script type="math/tex; mode=display">\begin{aligned} \sum_{b=0}^{n-1} \omega_{n}^{(c-a)b}&=\sum_{b=0}^{n-1} (\omega_{n}^{c-a})^b \\&=\frac{1-\omega_{n}^{n(c-a)}}{1-\omega_{n}^{c-a}} \\&=\frac{1-1}{1-\omega_{n}^{c-a}}=0 \end{aligned}</script><p>所以，</p><script type="math/tex; mode=display">f''(x)= \sum_{a=0}^{n-1}x^a\times nf_a</script><p>也就是说，在再做一遍参数为 $\omega_n^{-k}$ 的傅立叶变换，再将每个数 $\times \frac{1}{n}$，就得回原式。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>笔者没写过递归写法，但是显而易见地，递归常数相当大。</p><p>所以我们考虑倍增，只过回推的过程，让 $n$ 从 $1$ 开始不断翻倍。</p><p>顺推的时候，把偶数下标的值顺次移到较低的 $\frac{n}{2}$ 位，把奇数下标的值顺次移到较高的 $\frac{n}{2}$ 位。这样子的话，设 $f’’$ 为更深一层递归所得的 $f’$，则 $f’<em>{0,i}=f’’_i$，$f’</em>{1,i}=f’’_{i+\frac{n}{2}}$，。</p><p>模拟 $f$ 的下推过程，以下以 $n=8$ 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">0 1 2 3 4 5 6 7<br>0 2 4 6|1 3 5 7<br>0 4|2 6|1 5|3 7<br>0|4|2|6|1|5|3|7<br></code></pre></td></tr></table></figure><p>用二进制表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">000 001 010 011 100 101 110 111<br>000 010 100 110|001 011 101 111<br>000 100|010 100|001 101|011 111<br>000|100|010|100|001|101|011|111<br></code></pre></td></tr></table></figure><p>发现目标位置的下标是当前下标在二进制意义下的翻转。</p><p>于是整个过程就是：</p><ol><li>将每位和下标在二进制意义下翻转的位交换。</li><li>最外层从小到大枚举当前层每单位长度，下一层枚举每连续两个单位，并且依照公式递推。</li><li>如果是逆变换，就将每个数 $\times \frac{1}{n}$。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(Cplx* a, <span class="hljs-type">int</span> tp)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != L; ++i)<br>    <span class="hljs-keyword">if</span> (i &lt; tgt[i]) <span class="hljs-built_in">swap</span>(a[i], a[tgt[i]]);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != L; i &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != L; j += i * <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">0</span>); k != i; ++k) &#123;<br>        <span class="hljs-function">Cplx <span class="hljs-title">t</span><span class="hljs-params">((tp == <span class="hljs-number">1</span> ? angle[i + k] : conj(angle[i + k])) * a[j + i + k])</span></span>;<br>        a[j + i + k] = a[j + k] - t;<br>        a[j + k] = a[j + k] + t;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (tp == <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != L; ++i) a[i] = a[i] * <span class="hljs-built_in">Cplx</span>(<span class="hljs-number">1.0</span> / L, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>预处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (L = <span class="hljs-number">1</span>; L &lt;= N + M; L &lt;&lt;= <span class="hljs-number">1</span>)<br>  ;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != L; ++i) tgt[i] = (tgt[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) | ((i &amp; <span class="hljs-number">1</span>) * (L &gt;&gt; <span class="hljs-number">1</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != L; i &lt;&lt;= <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != i; ++j)<br>    angle[i + j] = <span class="hljs-built_in">Cplx</span>(<span class="hljs-built_in">cos</span>(PI / i * j), <span class="hljs-built_in">sin</span>(PI / i * j));<br></code></pre></td></tr></table></figure><h3 id="独属于-FFT-的乘法优化"><a href="#独属于-FFT-的乘法优化" class="headerlink" title="独属于 FFT 的乘法优化"></a>独属于 FFT 的乘法优化</h3><p>我们可以充分利用复数，将多项式乘法优化至只做 $2$ 遍 FFT。</p><p>考虑对 $h(x)=f(x)+ig(x)$ 进行平方，得到 $h^2(x)=(f^2(x)-g^2(x))+2if(x)g(x)$。虚部乘 $\frac{-i}{2}$ 就是乘积。</p><p>平方时直接将点值本身平方即可，总共 $1$ 遍 DFT，$1$ 遍 IDFT。</p><blockquote><p>修订于 20240414：也可以用下方 MTT 第二种办法中的原理，同时求出两个 FFT 结果；但是这两种方法都会带来不可忽视的精度损失。</p></blockquote><h2 id="2-NTT"><a href="#2-NTT" class="headerlink" title="2. NTT"></a>2. NTT</h2><p>NTT（Number Theory Transform，数论变换）是系数在模意义下的离散傅里叶变换。</p><h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><p>$g$ 是模 $p$ 的原根，当且仅当满足 $g^m\equiv 1\pmod p$ 的最小正整数 $m=\varphi(p)$。当 $p$ 是素数时，有 $g^m \bmod p(0&lt;m\le p-1)$ 互不相等。</p><p>NTT 常用的三个模数：</p><script type="math/tex; mode=display">\begin{aligned}998244353&=7\times 17\times 2^{23}+1 \\1004535809&=479\times 2^{21}+1 \\469762049&=7\times 2^{26}+1\end{aligned}</script><p>它们都形如 $p=n\times 2^m+1$（这意味着 $\varphi(p)=p-1$ 是 $2^m$ 的倍数，而且这些 $m$ 足够大），都有原根 $g=3$。</p><h3 id="原根的性质"><a href="#原根的性质" class="headerlink" title="原根的性质"></a>原根的性质</h3><p>原根满足 FFT 处所述单位元的许多性质。</p><p>令 $\omega_n^k=g^{\frac{k(\varphi(p)-1)}{n}}$，容易发现 $n$ 形如 $2^k$ 时，指数为整数。</p><ol><li>$\omega_n^0=\omega_n^n=g^0=1$</li><li>$(\omega_n^{\frac{n}{2}})^2=1$，而且由原根的定义，$\omega_n^{\frac{n}{2}}=g^{\frac{p-1}{2}}\neq g^{p-1}=1$，所以$\omega_n^{\frac{n}{2}}=-1$</li></ol><p>其余的都直接是分数的基本性质和幂运算的规则可以解释的。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>事实上，直接用 $g$ 的幂替换单位元就可以了。$g^{-1}$ 也就是求逆元。</p><p>NTT 在对系数取模的多项式乘法中很常用。一些时候，即使不需要取模，如果模数大于系数可能的最大值，同样可以用 NTT 来保证精度（例如高精度乘法）。</p><p>代码不放了，差不多。</p><h2 id="3-MTT"><a href="#3-MTT" class="headerlink" title="3. MTT"></a>3. MTT</h2><p>MTT 要实现的是任意模数多项式乘法。$n$ 为 $10^5$ 级别，$p$ 为 $10^9$ 级别。</p><p>NTT 对模数有限制，不能直接使用。而系数最大值为 $np^2$，可达 $10^{23}$。过程中使用浮点数而不能取模的 FFT 精度又不高。都需要进行改造。</p><h3 id="NTT-结合-exCRT"><a href="#NTT-结合-exCRT" class="headerlink" title="NTT 结合 exCRT"></a>NTT 结合 exCRT</h3><p>我们做 $3$ 轮，分别求出 $(f\times g)(x)$ 对 $3$ 个不同模数取模的结果，然后用扩展中国剩余定理的思路合并。</p><p>具体而言，我们知道 $h_k\equiv (f\times g)(x) \pmod {p_k}$，求$h=(f\times g)(x)$。</p><p>那么</p><script type="math/tex; mode=display">h_1+xp_1\equiv h_2\pmod {p_2}</script><script type="math/tex; mode=display">x\equiv (h_2-h_1)\times p_1^{-1}\pmod {p_2}</script><p>求得 $x$ 以后，令 $h’=h_1+xp_1$，则 $h\equiv h’\pmod {p_1p_2}$。</p><script type="math/tex; mode=display">h'+yp_1p_2=h_3\pmod {p_3}</script><script type="math/tex; mode=display">y=(h_3-h')\times (p_1p_2)^{-1}\pmod {p_3}</script><p>求得 $y$ 以后，令 $h’’=h’+yp_1p_2$，则 $h\equiv h’’\pmod {p_1p_2p_3}$。</p><p>我们可以选取 NTT 章节所提出的三个模数作为 $p_1$、$p_2$、$p_3$，那么 $p_1p_2p_3&gt;4\times 10^{26}$，远超系数最大值，所以 $h=h’’$。也正是因此，我们不能直接用 CRT，可能会爆精度。</p><p>在计算 $h’$、$h’’$ 的过程中对模数取模即可。</p><p>总共要跑 9 次 NTT（正向 6 次，逆向 3 次），常数较大。但是有一种写法，用结构体分别存下三个余数，同时跑 NTT，就相当于是 3 遍 NTT 但是乘上 3 的常数，速度得到了提高。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> TP = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DVS[] = &#123;<span class="hljs-number">998244353</span>, <span class="hljs-number">1004535809</span>, <span class="hljs-number">469762049</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INV0 = <span class="hljs-number">669690699</span>, INV01 = <span class="hljs-number">354521948</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> G = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> N, M, P, L, tgt[MXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Num</span> &#123;<br>  <span class="hljs-type">int</span> n[TP];<br>&#125; A[MXN], B[MXN];<br><span class="hljs-function">Num <span class="hljs-title">getnum</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>)</span> </span>&#123;<br>  Num n;<br>  n.n[<span class="hljs-number">0</span>] = a, n.n[<span class="hljs-number">1</span>] = b, n.n[<span class="hljs-number">2</span>] = c;<br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br>Num <span class="hljs-keyword">operator</span>+(Num a, Num b) &#123;<br>  Num n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != TP; ++i) n.n[i] = (a.n[i] + b.n[i]) % DVS[i];<br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br>Num <span class="hljs-keyword">operator</span>-(Num a, Num b) &#123;<br>  Num n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != TP; ++i) n.n[i] = (a.n[i] - b.n[i] + DVS[i]) % DVS[i];<br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br>Num <span class="hljs-keyword">operator</span>*(Num a, Num b) &#123;<br>  Num n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != TP; ++i) n.n[i] = a.n[i] * <span class="hljs-number">1LL</span> * b.n[i] % DVS[i];<br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">while</span> (p) &#123;<br>    <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>) s = s * <span class="hljs-number">1LL</span> * b % m;<br>    b = b * <span class="hljs-number">1LL</span> * b % m;<br>    p &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ntt</span><span class="hljs-params">(Num* a, <span class="hljs-type">bool</span> tp)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != L; ++i)<br>    <span class="hljs-keyword">if</span> (i &lt; tgt[i]) <span class="hljs-built_in">swap</span>(a[i], a[tgt[i]]);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != L; i &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-function">Num <span class="hljs-title">bas</span><span class="hljs-params">(getnum(pw(G, (DVS[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>) / (i * <span class="hljs-number">2</span>), DVS[<span class="hljs-number">0</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">                   pw(G, (DVS[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) / (i * <span class="hljs-number">2</span>), DVS[<span class="hljs-number">1</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">                   pw(G, (DVS[<span class="hljs-number">2</span>] - <span class="hljs-number">1</span>) / (i * <span class="hljs-number">2</span>), DVS[<span class="hljs-number">2</span>])))</span></span>;<br>    <span class="hljs-keyword">if</span> (tp)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != TP; ++j) bas.n[j] = <span class="hljs-built_in">pw</span>(bas.n[j], DVS[j] - <span class="hljs-number">2</span>, DVS[j]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != L; j += i * <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-function">Num <span class="hljs-title">e</span><span class="hljs-params">(getnum(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))</span></span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">0</span>); k != i; ++k, e = e * bas) &#123;<br>        <span class="hljs-function">Num <span class="hljs-title">w</span><span class="hljs-params">(e * a[j + i + k])</span></span>;<br>        a[j + i + k] = a[j + k] - w;<br>        a[j + k] = a[j + k] + w;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (tp) &#123;<br>    <span class="hljs-function">Num <span class="hljs-title">bas</span><span class="hljs-params">(getnum(pw(L, DVS[<span class="hljs-number">0</span>] - <span class="hljs-number">2</span>, DVS[<span class="hljs-number">0</span>]), pw(L, DVS[<span class="hljs-number">1</span>] - <span class="hljs-number">2</span>, DVS[<span class="hljs-number">1</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">                   pw(L, DVS[<span class="hljs-number">2</span>] - <span class="hljs-number">2</span>, DVS[<span class="hljs-number">2</span>])))</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != L; ++i) a[i] = a[i] * bas;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N &gt;&gt; M &gt;&gt; P;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>); i &lt;= N; ++i) &#123;<br>    cin &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != TP; ++j) A[i].n[j] = x % DVS[j];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>); i &lt;= M; ++i) &#123;<br>    cin &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != TP; ++j) B[i].n[j] = x % DVS[j];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (L = <span class="hljs-number">1</span>; L &lt;= N + M; L &lt;&lt;= <span class="hljs-number">1</span>)<br>    ;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != L; ++i) tgt[i] = (tgt[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (L &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">ntt</span>(A, <span class="hljs-number">0</span>), <span class="hljs-built_in">ntt</span>(B, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != L; ++i) A[i] = A[i] * B[i];<br>  <span class="hljs-built_in">ntt</span>(A, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i &lt;= N + M; ++i) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">K1</span><span class="hljs-params">((A[i].n[<span class="hljs-number">1</span>] - A[i].n[<span class="hljs-number">0</span>] + DVS[<span class="hljs-number">1</span>]) % DVS[<span class="hljs-number">1</span>] * <span class="hljs-number">1LL</span> * INV0 % DVS[<span class="hljs-number">1</span>])</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">x</span><span class="hljs-params">(A[i].n[<span class="hljs-number">0</span>] + K1 * <span class="hljs-number">1LL</span> * DVS[<span class="hljs-number">0</span>])</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">K2</span><span class="hljs-params">(((A[i].n[<span class="hljs-number">2</span>] - x) * <span class="hljs-number">1LL</span> % DVS[<span class="hljs-number">2</span>] + DVS[<span class="hljs-number">2</span>]) % DVS[<span class="hljs-number">2</span>] * INV01 % DVS[<span class="hljs-number">2</span>])</span></span>;<br>    cout &lt;&lt; (x % P + K2 * <span class="hljs-number">1LL</span> * DVS[<span class="hljs-number">0</span>] % P * DVS[<span class="hljs-number">1</span>] % P) % P &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>  &#125;<br>  cout &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拆系数-FFT"><a href="#拆系数-FFT" class="headerlink" title="拆系数 FFT"></a>拆系数 FFT</h3><p>我们把 $f<em>k$ 表示为 $bf</em>{0,k}+f<em>{1,k}(f</em>{1,k}&lt;b)$ 的形式。则 $f<em>kg_k=b^2f</em>{0,k}g<em>{0,k}+b(f</em>{0,k}g<em>{1,k}+f</em>{1,k}g<em>{0,k})+f</em>{1,k}g_{1,k}$。分别求出 $f_0$、$f_1$ 和 $g_0$、$g_1$ 两两之间的乘积即可。FFT 中系数最大值为 $nb^2$、$np$、$n\times \frac{p^2}{b^2}$ 的最大值。$b=\sqrt{p}$ 的时候值域在 $np$ 的级别，大约是 $10^{14}$，可以承受。</p><p>要跑 8 次 FFT（正向 4 次，逆向 4 次）。考虑优化。</p><p>还是充分发挥复数的优势，构造 $A(x)=f_0(x)g_0(x)+if_0(x)g_1(x)$、$B(x)=f_1(x)g_0(x)+if_1(x)g_1(x)$，那么逆向的变换就只要做 $2$ 次。</p><p>考虑正向的变换还有没有优化的余地。我们要用更少的次数，同时求出 $f_0$、 $f_1$、 $g_0$、 $g_1$ 的傅里叶变换。</p><p>考虑这样的两个共轭的多项式 $p(x)=s(x)+it(x)$，$q(x)=s-it(x)$。</p><p>对其进行傅里叶变换，</p><script type="math/tex; mode=display">p'(\omega_n^k)=\sum_{k=0}^{n-1}(\cos(\frac{2\pi k}{n})+i\sin(\frac{2\pi k}{n}))(s_k+it_k)</script><p>令 $X=\frac{2\pi k}{n}$，简化式子，</p><script type="math/tex; mode=display">\begin{aligned} p'(\omega_n^k)&=\sum_{k=0}^{n-1}(\cos(X)+i\sin(X))(s_k+it_k) \\&=\sum_{k=0}^{n-1}(\cos(X)+i\sin(X))(s_k+it_k) \\&=\sum_{k=0}^{n-1}(\cos(X)s_k-\sin(X)t_k)+i(\sin(X)s_k+\cos(X)t_k) \end{aligned}</script><script type="math/tex; mode=display">\begin{aligned} q'(\omega_n^k)&=\sum_{k=0}^{n-1}(\cos(X)+i\sin(X))(s_k-it_k) \\&=\sum_{k=0}^{n-1}(\cos(-X)-i\sin(-X))(s_k-it_k) \\&=\sum_{k=0}^{n-1}(\cos(-X)s_k-\sin(-X)t_k)-i(\sin(-X)s_k+\cos(-X)t_k) \\&=\overline{p'(\omega_n^{(n-k)\bmod n})} \end{aligned}</script><p>也就是说，我们可以用 $p’$ 求出 $q’$。那么我们就可以把两个数列合起来 DFT。</p><p>令 $p(x)=f_0(x)+if_1(x)$，$q(x)=f_0(x)-if_1(x)$。</p><script type="math/tex; mode=display">\begin{aligned}f'_{0,k}&=\frac{p'_k+q'_k}{2} \\&=\frac{p'_k+\overline{p'_{(n-k)\bmod n}}}{2}\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}f'_{1,k}&=\frac{p'_k-q'_k}{2i} \\&=-i\times \frac{p'_k-\overline{p'_{(n-k)\bmod n}}}{2}\end{aligned}</script><p>所以我们只需要做一次 FFT 求出 $p’(x)$ 就可以求出 $f’_0(x)$ 和 $f’_1(x)$。 $g’_0(x)$ 和 $g’_1(x)$ 同理。然后再通过这构造 $A(x)$ 和 $B(x)$ 即可。总共 2 次 DFT，2 次 IDFT。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> RDX = <span class="hljs-number">31623</span>;<br><span class="hljs-type">int</span> N, M, L, P, tgt[MXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(Cplx* a, <span class="hljs-type">int</span> tp)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != L; ++i)<br>    <span class="hljs-keyword">if</span> (i &lt; tgt[i]) <span class="hljs-built_in">swap</span>(a[i], a[tgt[i]]);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != L; i &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != L; j += i * <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">0</span>); k != i; ++k) &#123;<br>        <span class="hljs-function">Cplx <span class="hljs-title">t</span><span class="hljs-params">((tp == <span class="hljs-number">1</span> ? angle[i + k] : conj(angle[i + k])) * a[j + i + k])</span></span>;<br>        a[j + i + k] = a[j + k] - t;<br>        a[j + k] = a[j + k] + t;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (tp == <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != L; ++i) a[i] = a[i] * <span class="hljs-built_in">Cplx</span>(<span class="hljs-number">1.0</span> / L, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N &gt;&gt; M &gt;&gt; P;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>); i &lt;= N; ++i) &#123;<br>    cin &gt;&gt; x;<br>    A[i].r = x / RDX, A[i].i = x % RDX;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>); i &lt;= M; ++i) &#123;<br>    cin &gt;&gt; x;<br>    B[i].r = x / RDX, B[i].i = x % RDX;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (L = <span class="hljs-number">1</span>; L &lt;= N + M; L &lt;&lt;= <span class="hljs-number">1</span>)<br>    ;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != L; ++i)<br>    tgt[i] = (tgt[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) | ((i &amp; <span class="hljs-number">1</span>) * (L &gt;&gt; <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != L; i &lt;&lt;= <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != i; ++j)<br>      angle[i + j] = <span class="hljs-built_in">Cplx</span>(<span class="hljs-built_in">cos</span>(PI / i * j), <span class="hljs-built_in">sin</span>(PI / i * j));<br>  <span class="hljs-built_in">fft</span>(A, <span class="hljs-number">1</span>), <span class="hljs-built_in">fft</span>(B, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != L; ++i) &#123;<br>    <span class="hljs-function">Cplx <span class="hljs-title">a0</span><span class="hljs-params">((conj(A[(L - i) % L]) + A[i]) * Cplx(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>))</span>,</span><br><span class="hljs-function">        <span class="hljs-title">a1</span><span class="hljs-params">((conj(A[(L - i) % L]) - A[i]) * Cplx(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>))</span>,</span><br><span class="hljs-function">        <span class="hljs-title">b0</span><span class="hljs-params">((conj(B[(L - i) % L]) + B[i]) * Cplx(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>))</span>,</span><br><span class="hljs-function">        <span class="hljs-title">b1</span><span class="hljs-params">((conj(B[(L - i) % L]) - B[i]) * Cplx(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>))</span></span>;<br>    C[i] = a0 * b0 + <span class="hljs-built_in">Cplx</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) * a0 * b1;<br>    D[i] = a1 * b0 + <span class="hljs-built_in">Cplx</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) * a1 * b1;<br>  &#125;<br>  <span class="hljs-built_in">fft</span>(C, <span class="hljs-number">-1</span>), <span class="hljs-built_in">fft</span>(D, <span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i &lt;= N + M; ++i) &#123;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">a0b0</span><span class="hljs-params">(C[i].r + <span class="hljs-number">0.5</span>)</span>, <span class="hljs-title">a0b1</span><span class="hljs-params">(C[i].i + <span class="hljs-number">0.5</span>)</span>, <span class="hljs-title">a1b0</span><span class="hljs-params">(D[i].r + <span class="hljs-number">0.5</span>)</span>,</span><br><span class="hljs-function">        <span class="hljs-title">a1b1</span><span class="hljs-params">(D[i].i + <span class="hljs-number">0.5</span>)</span></span>;<br>    cout &lt;&lt; (a0b0 % P * RDX % P * RDX % P +<br>             ((a0b1 + a1b0) % P * <span class="hljs-number">1LL</span> * RDX % P + a1b1 % P) % P) %<br>                P<br>         &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>  &#125;<br>  cout &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - GDCPC 2023</title>
    <link href="/rec-2023gdcpc/"/>
    <url>/rec-2023gdcpc/</url>
    
    <content type="html"><![CDATA[<p>with <a href="https://www.luogu.com.cn/user/603135">this guy</a> and <a href="https://www.luogu.com.cn/user/245959">this guy</a>.</p><p>看看队长的<a href="https://www.luogu.com.cn/blog/xujindong/gdcpc2023">游记</a>。</p><h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY -1"></a>DAY -1</h2><p><em>2023.5.13.</em></p><p>2.5h，从南沙港过东莞到深圳。</p><p><img src="https://s2.loli.net/2025/08/31/QmD1C3dRjtW67Eu.png" alt="rec-2023gdcpc-1.png"></p><p>大江南去，潮平两岸阔。偶然有小洲，合两岸是青葱的草木，像人浓密的毛发。向远端望去，一切又都像笼罩在洁白、苍茫的天幕中。忽而下起绵绵细雨，于是雨点挂在车窗上，被风阻着，拖出一道长长的泪痕。</p><p>在坪山的路间草坪上，竟然看见一只羊，浑身褐色，埋着头疾速啃食着草，大概是饿坏了。这速度简直比凌晨三点赶作业的人还快。</p><p><img src="https://s2.loli.net/2025/08/31/NU1xdI4AK7VsHba.png" alt="rec-2023gdcpc-2.png"></p><p>走进校园的时候，根本没发现 SZTU 是这么大，一大片街区都是它的。校园中甚至还能办酒店。有钱就能为所欲为吗？</p><p><img src="https://s2.loli.net/2025/08/31/jQHOYeZVD13Rxgk.png" alt="rec-2023gdcpc-3.png"></p><p>enter 键保佑我！</p><p>见到了很多故人，其他学校的师生和本校的同学（我们教练没有来）。然而和其他学校的要打招呼便也生分而尴尬着，只是远远望着，大概我也被看见。</p><p><img src="https://s2.loli.net/2025/08/31/PluzYxeQFX31WyK.png" alt="rec-2023gdcpc-4.png"></p><p><strong>热身赛。</strong></p><p>C 题模拟，D 题莫反板子。A 题貌似是决策单调性 dp，但是没想好；B 题简单 dp，但是有点细节。所以只做了 C 和 D 题，D 我做的。</p><blockquote><p>A：把长度为 $n$ 的序列分成 $m$ 段，求每段颜色数总和的最小值。$n,m\le 5\times 10^4$。</p><p>B：求最少数目的 $3\times 3$ 矩阵覆盖 $5\times n$ 的 01 矩阵中的所有 $1$。$n\le 10^4$。</p></blockquote><p>迷路了一会才到 E-0 食堂。搞了个香肠和鱼蛋，这味道和分量，真值！坐旁边有一位，应该是本校的大学生，问我来做什么，问我编程竞赛的相关，以及很好奇为什么竞赛从中学就这么竞争，原来社会中还有很多人对竞赛如此陌生。他点的菜倒还多，但真的是吃得慢，若有所思状。脸是漫展中容易见到的外貌，但是又很难形容，大抵有一种纯粹和认真的气质。</p><p>晚上躺床上就昏昏欲睡了，不能写作业，不能写代码，连洗澡也顾不上，就要睡。凌晨两点又起来，兀自关了灯。忽而有一种凄神寒骨，好像期望特定的人就卧在我的枕边，也可以排解我的孤独和寒冷。然而胡思乱想了一会，还是归因为害怕自己的生物钟真的紊乱，于是还是要静下心睡觉并且继续调节生活节律。这绝不是一朝一夕能完成的，也不是摇摆不定能达成的。</p><h2 id="DAY-0"><a href="#DAY-0" class="headerlink" title="DAY 0"></a>DAY 0</h2><p><em>2023.5.14.</em></p><p>7:20 起来洗澡。吃完早餐，初步形成这篇游记。</p><p><img src="https://s2.loli.net/2025/08/31/QbroA87kGc4UOR6.png" alt="rec-2023gdcpc-5.png"></p><p><strong>正赛。</strong></p><p>队友有点发热。</p><p>做了 A,C,D,I,K。其中我写了 I,K。B 卡题了，考场上一直针对事件 dp，明知不通然后乱搞了一个前缀和建图跑最短路的方法，一直 WA。队长 E 卡题了，但我觉得看起来是正确的。J 队长想出来根号分治，但是解得不够完善，所以写不出来。总的来说还是要膜拜队长。</p><p>平时没有吃过一瓶雪碧、一个汉堡、一个鸡肉卷这么现代化而丰盛的午餐，前缀和建图的想法大概就是吃饱了撑的想出来的。</p><p>Ag 倒数。听了讲题，大部分觉得很有道理，归结原因：还是弱，对于基本的思维没有大量运用的经验。所以还是要多练啊。要赶回从前的相对实力，我就要多去练啊。</p><p>领完奖牌就走。</p><hr><p>开车，在大岭山休息站停歇，天显然是转黑了，然而还有一点亮光，就不忍得说这是天黑。全家的香肠、面啥的已经卖完，猜想休息站客人应是极多的。这些食物从何运来？这里上班的人儿夜晚又在哪里歇息？殷红的天幕下高速公路上，无数的红灯正飞驰而过。路的一侧是山丘，另一侧又被草木遮挡得严严实实，这背后有着什么呢？我怎么知道这后面有没有人烟呢？不相识的大车、小车从远方缓缓行来，在此停靠。或散步，或购物，或休憩，或吃饭，但想他们总是鲜能相识的，至少直觉告诉我，一日三餐选定某个加油站停靠的大车司机没那么多，更何况这里还是小轿车居多。大概每天都有各形各色的人来到这个站，或工作的，或旅游的，但想是不如城市的打工人们每日过着恒常的生活，恒常的节律，把每个十五分钟都安排妥当。于是郊野的工作人员自由地遇见永远陌生的面孔，而鲜少有人是他们的常客，他们永远工作在默默无闻的世界角落里。</p><p><img src="https://s2.loli.net/2025/08/31/tykmNUnzGgYpSKI.png" alt="rec-2023gdcpc-6.png"></p><p><img src="https://s2.loli.net/2025/08/31/Azh9nNG3FtHlJsT.png" alt="rec-2023gdcpc-7.png"></p><p>黑夜才有对灯光额外的敏感，于是能轻易发现虎门城区。灯光是一些散点，广阔的虎门在飞驰的车窗远方就平坦地展开在你的眼前，就像施加了二向箔一样，各色的灯光也水平起来，连成一条条五彩斑斓的横线不断地向后逝去。途径一座叫不出名字，但是弧度很优美的大桥，顺着驶去时，就能看到车流绕过大大的弯形成的壮观光流，浓缩在目前。然而过了这个弯，眼前就是笔直的星光大道。向回望，后面的弧度却不再那么震撼，不能在心中第二次掀起波澜。过了虎门大桥，入了广州，灯光显然就不一样了。可能是楼变高了的缘故，广州的灯光展现出一种竖直的线条。偶有的一些散灯，就像宁静的眼眸，就是在向你望去，下面光好像形成一个卧蚕，其中脉脉地含着些清水一样。</p><p><img src="https://s2.loli.net/2025/08/31/ethW2PAQmXVqKvE.png" alt="rec-2023gdcpc-8.png"></p><p><img src="https://s2.loli.net/2025/08/31/PVhBuH6Mvlz7bda.png" alt="rec-2023gdcpc-9.png"></p><p>昏暗的路灯照在光亮的高速路上，周围尽是植被，只能偶尔瞥见四号线高架起的车站。打开地图，就看到四号线像一个犄角，向着东南方远远伸去，到了石碁、黄阁等等我从来不会涉及的地方。这大概是广州番禺的许多村的一些吧，石碁村、黄阁村。于是想起我也曾和一些好伴儿来到过四号线的海傍。又惋惜和人坐十八号线，只到了番禺广场，浅尝辄止。真应该到极南的万顷沙一看，或许没有万顷的沙，但所见应当是水田广布——这是我对南沙的始终印象。无论如何，总比始终待在一模一样的、装饰现代化的车站里新奇。——但，没有故人再陪我了。我舍弃，想重拾，想哭泣。只有我和我的司机母亲在一架车里，或许很快，在车里的会只有我一个人。所有的过去，我相信它会过去，或许在潜意识里又以为还没过去。妄想。我从来不知道我想要和什么样的旅客同行。命运分配在我旁边的？和我有一些共同兴趣的？健谈可亲的？我想我终我一生也不能找到人兼备，然而——可能是一种挑剔——我于是也失去了向我身边的人高谈阔论、完全敞开心扉的可能。我不知道会不会再度打开，或是始终封闭，直到了成年，到了成家，到了 45 岁，到了 70 岁，还是孤僻冷漠。而真正出现这样的样子，我也从来不能怪命运，大概是怨自己太挑剔，没有抓住时机？然而真正相投的或许也会有一点时运的，不轻易擦肩而过，所以即便发生，大概也只是一种见怪不怪，少见多怪。</p><hr><p>去的时候走的新滘，回来稀里糊涂就上了新港西，司机还疑惑怎么到了黄埔古港。大概回来是难完全原路返回的。但总是见到了熟悉的公交车站，熟悉的道中树木，熟悉的天桥，熟悉的车灯流淌……从四号线区来到八号线区，啊，八号线是青色的，一开始相当不喜欢，现在这种颜色反而成为一种恒常的象征了。</p><p>补下：</p><p><img src="https://s2.loli.net/2025/08/31/1ihgnW3GAvlF5zX.png" alt="rec-2023gdcpc-10.png"></p><p><img src="https://s2.loli.net/2025/08/31/Wrp6xG85ESizlPy.png" alt="rec-2023gdcpc-11.png"></p><p>队友高烧。</p><h2 id="DAY-1-1"><a href="#DAY-1-1" class="headerlink" title="DAY 1"></a>DAY 1</h2><p><em>2023.5.15.</em></p><p>作业该请的假就请。</p><p>队友班十几个都感染了，班被隔离。向队友祝好。</p><p>向自己的远方腾着空奔去吧，其他的一切都应有舍弃的勇气，世间许多都是拥有是幸事，失去也如是则已。想有时既然选择了独立自主的道路，就要耐住寂寞。除此之外，就是增加广度和深度，多练，多用。加油。</p><h2 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h2><p><em>2023.5.16.</em></p><p>完善这篇游记。</p><p>并且很纳闷这么上传图片：</p><p><img src="https://s2.loli.net/2025/08/31/HLAKUJWTvcg1dO5.png" alt="rec-2023gdcpc-12.png"></p><p><img src="https://s2.loli.net/2025/08/31/SeImlTgFKAUdrRu.png" alt="rec-2023gdcpc-13.png"></p><p>有没有个解释，要不然我的高级空间一下子被用那么多，要考虑换图床了。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - GDOI 2023</title>
    <link href="/rec-2023gdoi/"/>
    <url>/rec-2023gdoi/</url>
    
    <content type="html"><![CDATA[<h2 id="DAY"><a href="#DAY" class="headerlink" title="DAY -?"></a>DAY -?</h2><p>奖励名额入选。</p><p>补测很烂，NOIP VP 也并不好，更何况根本没正式考。打了和没打，还有啥区别呢。</p><p>寒春，干燥的季节。我不习惯喝水。</p><p>右腿好酸。</p><h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY -1"></a>DAY -1</h2><p><em>2023.3.31.</em></p><p>试机。</p><p>学长给了一道题 P6790，甚至告诉了我这是广义串并联图，我也没想到。为溜走的一整年而有些叹惋，我想我的 OI 能力一定程度上总是退化了，自己的课余时间更多投入到音乐里去，不免顾此失彼。我想要什么？我应当做好规划。</p><p>对面学校老师挺好的，同学也挺好的。</p><p>考场号和座位号谐音不太吉利。</p><p>在一个没有同校同学的考场。不错。</p><p>不到十分钟就做完了基本的测试，同伴在搞虚拟机。等着等着就不知道人去哪了，没有手机，不知道他们反而在我后头。</p><p>广州的雨丝绵绵，在雨中走路也很惬意，不担心感冒，没有太大的击打感，又挑逗着我的注意，也不觉乏味。好像在空想，脑袋空空的，又像在思想着什么，正如雨点飘飘然，又有分明的触感。</p><p>夜晚，雨点声回荡。有一点感觉周围原本亲近的人正在慢慢疏远我。一部分只是我的压力导致的幻觉吧，我劝自己。</p><h2 id="DAY-0"><a href="#DAY-0" class="headerlink" title="DAY 0"></a>DAY 0</h2><p><em>2023.4.1.</em></p><p>同学发现文件名 day0，文件内容 day1，何尝不是一种愚人。</p><p>出车，天蒙着一层灰，有种黑云压城城欲摧之感。这反而让我有点激动，是压力的作用吗？</p><p>坐在有点熟悉了的考场上，舒服，半困半醒。打开窗，雨后气味挺不错的。在绝望的比赛中有点喘息，已知必败于是这点也可以算抚慰了。</p><p>T1 过于可做，让我迟疑了一下。T2、T3 基本不会，T3 想到费用流，于是猛敲一通，但跑起来贼慢，而且还有正环。不会模拟费用流啊！</p><p>预估 $100+25+22$。</p><p>进行了一个上午的思考，脑子愉悦了许多。</p><p>下午和同学出去玩。解密难度一般，最难的解密可能是寻找 Wi-Fi 密码。</p><h2 id="DAY-1-1"><a href="#DAY-1-1" class="headerlink" title="DAY 1"></a>DAY 1</h2><p><em>2023.4.2.</em></p><p>原来天本来并不灰，只是车窗没有擦干净。</p><p>预期很难。前一个半小时没什么有效思考。而我发现 T2 做法后，又迟疑了一会。</p><p>然后一直调 T1、T3 部分分，T3 第二问不会做，啥都骗不到。</p><p>然后本来会的 T2 拖到最后四十分钟，调不完了。脑子会了，不会找环，是不是很搞笑。</p><p>不想估分。这个策略安排，真的有点后悔。</p><p>受死吧。</p><p>广州又恢复为那个干爽的城市。宛如在雨夜做的一场梦。</p><h2 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h2><p>$100+25+22+10+5+1$。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - GDKOI 2023 提高组</title>
    <link href="/rec-2023gdkoi-s/"/>
    <url>/rec-2023gdkoi-s/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/blog/lzqy/gdkoi-2022-po-fang-ji-day1-post">膜</a><a href="https://www.luogu.com.cn/blog/lzqy/gdkoi-2023-you-ji-day2-post">拜</a><a href="https://www.luogu.com.cn/blog/279646/gdkoi2023-you-ji">学</a><a href="https://www.luogu.com.cn/blog/QQ82272760/gdkoi2023xhxsplit">长</a><a href="https://www.luogu.com.cn/blog/366581/gdkoi-2023-you-ji">。</a></p><h2 id="DAY-0"><a href="#DAY-0" class="headerlink" title="DAY 0"></a>DAY 0</h2><p><em>2023.3.11.</em></p><p>简要题意：</p><p>T1：判断两个 $n\times n$ 矩阵乘积是不是第三个矩阵。多测，$\sum n\le 3000$。模意义下。</p><p>T2：求 $1\sim n$ 的错排中满足前 $m$ 位的值 $&gt; m$ 的排列数目。$T,n\le 2\times 10^5$，$0\le m\le n$。模意义下。</p><p>T3：给一个图，给每个点赋权值，满足每个权值不超过这个点的限制，邻点值不同，且全部权值的异或和是给定的。$n\le 15$，$m\le \frac{n(n-1)}{2}$，权值 $\le 10^{18}$。模意义下。</p><p>果断写了 T1 判断每行每列之和和对角线相等的乱搞，和 T2,3 的暴力。还有两个半小时，睡觉，推不出来。</p><p>出来之后发现人均善于 T1 随机撒点，T2 人人会 dp/容斥，裂开。</p><p>T1 正解是把 $A\times B=C$ 写成 $v\times A\times B=v\times C$，生成一些一维向量 $v$。于是觉得我可能要挂。不过有无人 hack 我的做法？</p><p>T2 是从递推式出生成函数，T3 是数位 dp、容斥、从按边容斥到按联通块容斥。听不懂。</p><p>下午又来了大学讲座、企业广告，“把我们的一生都安排好了是吧”。</p><p>本来说滚榜发成绩，咕咕咕了，好像是有人每次测评结果都不一样。</p><h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY 1"></a>DAY 1</h2><p><em>2023.3.12.</em></p><p>T1：给一棵树，每次询问在树上找到三个点 $x,y,z$，满足两两之间的距离是给定的数。$n,q\le 2\times 10^5$。</p><p>T2（名字叫做“马戏团里你最忙”，当然是形容我啦）：给一个初始的数，每次均匀从 $[0,2^n)$ 里面选一个数，$p$ 的概率进行 $\texttt{OR}$ 操作，$1-p$ 的概率进行 $\texttt{AND}$ 操作，总共 $k$ 次操作，权值和是每次的 $c_x$，$x$ 表示当前的数，$c$ 是一个给定的数组。最后输出每个终点对应的权值和期望。$n\le 17$，$k\le 10^9$。模意义下。</p><p>T3：给一棵树，每次询问 $x$ 的子树中和 $x$ 的距离 $d(x,y)&lt;k$ 的 $\sum_y v_y\oplus d(x,y)$，算边数。$n,q\le 10^6$。</p><p>想象一下：自己本来算出可以拿到 $150+$ 的部分分，越推越发现其实也就 $90$ 的部分分。T2 甚至完全没部分分下手。T1 就直径+$O(nq)$ 暴力，听天由命。</p><p>出场一看：T1 这不明显的三维偏序，我干嘛。T2 有巨佬会 FWT，说是高维前缀和。我不会。</p><p>解法上，T2 好像是神秘矩阵快速幂。T3 讲题画的图好像是说：在 bfs 序上每次询问同一深度都在同一段上，所以最后可以长得很像前缀和。好像又可以长链剖分，可是长链剖分我不仅不会，甚至是 T1 想到的长链剖分。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>$100+20+20+70+0+20=230$，Ag。</p><p>无功无过。只是硬实力就这个鬼样。有点疑惑怎么 D2T1 少了 $10$ 分，不过 D2T3 比预期多了 $10$ 分，都可以接受。</p><p>Ag 线 $190$，Au 线 $260$。</p><p>还有什么好说的呢？磕多项式、概率、树论，这些让人望而生畏的总是要磕。</p><p>好多那么厉害的人，为什么都写挂。不过他们有可做的解，暴力那是连写挂的余地都没了。</p><p>憋屈的是这几天睡眠老是不足，就是想晚睡，情绪也比较低落。要调整了。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Luogu P9034 「KDOI-04」Again Counting Set</title>
    <link href="/sol-LGP9034/"/>
    <url>/sol-LGP9034/</url>
    
    <content type="html"><![CDATA[<h2 id="再述题意"><a href="#再述题意" class="headerlink" title="再述题意"></a>再述题意</h2><p>给出正整数 $n,k$，求有多少个可重整数集合 $S$ 满足：</p><ul><li>$|S|=k$；</li><li>对于任意 $x\in S$，$0\le x\le n$；</li><li>$\prod<em>{x\in S} x=\min</em>{x\in S} x$；</li><li>$\sum<em>{x\in S} x=\min</em>{x\in S} x+\max_{x\in S}x+{\operatorname{mex}}(S)$。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前两个条件，显然说明：$k$ 是集合的大小，$[0,n]$ 是集合的值域。</p><p>我们考虑第三个条件。假设 $a=\min<em>{x\in S} x$，$pa=\prod</em>{x\in S} x$。也就是说，$a$ 是集合最小值，$p$ 是其余元素的积，可以得到 $pa=a$。</p><p>当 $a=0$ 时，显然等式成立，否则 $p=1$。</p><p>也就是说，集合<strong>要么存在 $0$，要么全都是 $1$</strong>。</p><hr><p>接着来看第四个条件。</p><p>当集合全都是 $1$ 时，代入这个式子，得：</p><script type="math/tex; mode=display">\sum_{x\in S} x=2</script><p>所以这个情况<strong>只有 $k=2$ 的时候</strong>合法。</p><p>否则必然存在 $0$。设 $m=\max<em>{x\in S}x$，$r+m=\sum</em>{x\in S} x$，也就是说 $m$ 是集合最大值，$r$ 是其余元素的和。代入式子，可以得到：</p><script type="math/tex; mode=display">r+m=m+{\operatorname{mex}}(S)</script><script type="math/tex; mode=display">r={\operatorname{mex}}(S)</script><p>所以我们要求的集合特征很明显：<strong>去除一个最大值，剩下所有数的和就是 ${\operatorname{mex}}(S)$</strong>。</p><p>接下来就比较简单了。我们分类讨论一下。</p><hr><p>当 ${\operatorname{mex}}(S)=m+1$。</p><p>这意味着，集合包含 $[0,m-1]$ 的所有整数。所以：</p><script type="math/tex; mode=display">m+1=r\ge \frac{1}{2}m(m-1)</script><p>$m$ 的自然数取值只有 $[0,1,2,3]$。所以我们根据每个取值，求出 $r$，并且根据集合包含 $[0,m-1]$ 的所有整数，可以枚举这样的集合数。</p><ul><li>$m=0$ 意味着全部数都是 $0$，则 $r=0$，所以这是不可能合法的；</li><li>$m=1$ 的时候，$r=2$，集合应该长这样：${0,\ldots,0,1,1,1}$；</li><li>$m=2$ 的时候，$r=3$，并且集合包含一个 $1$，有两种可能：${0,\ldots,0,1,1,1,2}$，或 ${0,\ldots,0,1,2,2}$；</li><li>$m=3$ 的时候，$r=4$，并且集合包含一个 $1$ 和一个 $2$，应该长这样：${0,\ldots,0,1,1,2,3}$。</li></ul><p>这些集合在 $n,k$ 足够的时候都可以唯一构造。</p><hr><p>当 ${\operatorname{mex}}(S)=r&lt;m$。</p><p>这意味着，集合包含 $[0,r-1]$ 的所有整数，且不包含 $r$。所以：</p><script type="math/tex; mode=display">r\ge \frac{1}{2}r(r-1)</script><script type="math/tex; mode=display">r\le 3</script><ul><li>因为集合存在 $0$，所以 ${\operatorname{mex}}(S)\neq 0$。</li><li>$r=1$ 的时候，集合没有 $1$，所以元素和不能为 $1$，矛盾。</li><li>$r=2$ 的时候，集合包含一个 $1$，又要 $r=2$，则集合应该长成 ${0,\ldots,0,1,1,m}$。</li><li>$r=3$ 的时候，集合包含一个 $1$ 和一个 $2$，长成 ${0,\ldots,0,1,2,m}$。</li></ul><p>在后两种情况中，集合的数目与 $m$ 的取值数目有关，$m$ 只需要满足 $m&gt;r$ 即可。</p><hr><p>综上，我们来梳理一下答案的构成：</p><ul><li>$k=2$ 时，${1,1}$ 为合法集合，贡献为 $1$；</li><li>$k\ge 4$ 时，${0,\ldots,0,1,1,1}$ 为合法集合，贡献为 $1$；</li><li>$n\ge 2$ 且 $k\ge 5$ 时，${0,\ldots,0,1,1,1,2}$ 为合法集合，贡献为 $1$;</li><li>$n\ge 2$ 且 $k\ge 4$ 时，${0,\ldots,0,1,2,2}$ 为合法集合，贡献为 $1$；</li><li>$n\ge 3$ 且 $k\ge 5$ 时，${0,\ldots,0,1,1,2,3}$ 为合法集合，贡献为 $1$；</li><li>$n&gt;2$ 且 $k\ge 4$ 时，${0,\ldots,0,1,1,m}$ 为合法集合，贡献为 $n-2$；</li><li>$n&gt;3$ 且 $k\ge 4$ 时，${0,\ldots,0,1,2,m}$ 为合法集合，贡献为 $n-3$。</li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分类讨论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - WC 2023</title>
    <link href="/rec-2023wc/"/>
    <url>/rec-2023wc/</url>
    
    <content type="html"><![CDATA[<h2 id="上课"><a href="#上课" class="headerlink" title="上课"></a>上课</h2><p>后悔。后悔为什么没有认真上课。</p><p>本来以为只有第二课堂的东西够简单，结果去看还是无聊。第一课堂有趣啊，至少我上的一个欧洲信息学竞赛选讲的课是好的。上的唯一一节课还发了言，哈哈。</p><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>困。</p><p>会了暴力，但是总觉得 T1 快要推出来了，T2 快要推出来了。把 T1 做成平衡树，把 T2 想成一个无向完全图里找一条相邻边颜色不同的环路，其中每个颜色占且仅占一个完全图。</p><p>最后 1h，敲一下 T2 的 32pts，状压 + $m=1$。只测了小样例。</p><p>连讲题也能忘记听。</p><p>喜提爆零。</p><p>后来去测大样例，有这么一组输出：</p><p><code>1 2 3 4 6 6</code></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>下面提供一点极其情绪化的反思。</p><p>感觉自己根本没有认真对待。本来也只以为 WC 就是随便考一场超出能力范围的，课也完全没价值。但是至少我上的那一节就很好，比起校内的死气沉沉好的多了。这一次的 32pts 明明可以有 Cu，好。</p><p>思维上不够灵活，代码能力也不够。</p><p>还是觉得都是堆题的问题。不够，更多。</p><p>另一个比较纠结的就是，暴力到底应不应该写？很多时候暴力和对拍写起来非常冗长，但是很多时候又十分有意义，至少能拿稳分。但是一些月赛又没有部分分。这涉及到考试策略。</p><p>没准平时写一写大 ds 未必不好，学一学思维题也很有必要。</p><p>学校的训练很大程度上停滞了。自己也开始学一些其他学科的了，但是还是要想办法，保持键盘感。</p><p>做题吧，动起来吧。无论是月赛，或是静态的模拟赛题。没事写写吧，写写吧。</p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>啊，我指的是对题目的复盘。</p><p>只能说都还没想懂。T2 的构造已经基本有脉络，大概就是：判合不合法是简易的，只要看是否有集合超过 $\lfloor\frac{2}{3}n\rfloor$。</p><p>当这个最大集合的大小就是 $\lfloor\frac{2}{3}n\rfloor$，那么每三个放两个是基本策略。</p><p>其他的呢，可能也可以乱搞过，不过乱搞想的不明白，比如说可以在这个三个放两个里面夹住出现较多的集合里的，尽量使剩余合法。一个通俗的搞法就是直接随机。貌似贪心+随机可过来着。</p><p>其实不难啊，可是为什么我要想到环路呢。以及那个每两个集合的交集最大为 $1$ 依然不明白。</p><p>T1 的话好像是把边界横纵对应 $\pm 1$，然后变成找一对 $\pm 1$ 使得距离为 $q$，貌似是二分，但是不明白。</p><hr><p>Updated on Jan. 30th.</p><p>LOJ 出数据了。破案了，为啥 T2 没分：全 MLE 了，导致编译错误。</p><p>可恶。连随机构造都有 40pts，下面给出两种 40pts 的可行做法：</p><ul><li>限定前 $x$ 组数据的总次数不超过 $10000x$。</li><li>每次随机 $10^8\div t$ 次。</li></ul><p>这不白送的铜牌？我还不清楚 T1 暴力多少分，没准银牌是白送的？</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - CSP 2022 补考</title>
    <link href="/rec-2022csp2-r/"/>
    <url>/rec-2022csp2-r/</url>
    
    <content type="html"><![CDATA[<p>现在，是 2023。</p><h2 id="DAY-8-2"><a href="#DAY-8-2" class="headerlink" title="DAY -8 ~ -2"></a>DAY -8 ~ -2</h2><p><em>2023.1.7~2023.1.13.</em></p><p>学长陆陆续续给了 12 道题出来。</p><p>感觉是我的水平，所以最后一天我把它们做完了。挺好玩的。</p><p>其实倒数第二天本来快要放弃了，结果最后一天是用来补题的，不写白不写。解除了 ABC282 的怨念。</p><p>什么嘛，认真写还是写得完的。</p><h2 id="DAY-0"><a href="#DAY-0" class="headerlink" title="DAY 0"></a>DAY 0</h2><p><em>2023.1.15.</em></p><h3 id="Morning-Junior"><a href="#Morning-Junior" class="headerlink" title="Morning: Junior"></a>Morning: Junior</h3><p><em>8:30~12:00.</em></p><p>提前一小时进场，检查要延后半小时退场……</p><h3 id="Afternoon-Senior"><a href="#Afternoon-Senior" class="headerlink" title="Afternoon: Senior"></a>Afternoon: Senior</h3><p><em>14:30~18:30.</em></p><p>同上。</p><p>由于考试好像要求不能泄露题目，我就不写题面了。</p><p>前一个半小时都在看题和算。</p><p>T4 推卡住了，本来以为很顺利。</p><p>接着半小时，把 T1、2 写完。</p><p>然后推 T3。</p><p>然后 T3 推到考试只剩半小时的时候，终于出来像样的结论了。可是过不去样例！第二个样例错了一个点，第三个样例错的比较多。</p><p>求此时我的心理阴影面积。</p><p>拿了 15 pts，跑路。</p><p>回去看 T4，已经没有时间补想了，10 pts brute force 跑路。</p><p>乐。</p><p><em>提交的时候，有一个人的文件名是 task1, task2, task3, task4，并且「本人确认提交文件无误」。我感到当时我的沉默简直</em>……。</p><h3 id="Night"><a href="#Night" class="headerlink" title="Night"></a>Night</h3><p>睡不着。一直在反反复复想自己的 T3 到底是哪个情况跑不过去，因为结论看起来太有道理了。又不明白 T4 到底是什么数据结构。</p><p>很搞笑，我想过块状链表套块状数组，或平衡树套线段树。突然发现块状链表套线段树才可做。如果 $10^5$ 跑得过 $O(n\sqrt{n}\log n)$，这就是正解。</p><p>哈哈哈。诶，不对，为什么提高级会考块状链表和线段树合并？诶，能过就行。</p><p>又回到 T3，发现有一个情况的判断标准出问题。并且知道思路没问题，就是最后一步，在最后关头没能冷静下来推完、写完。</p><p>分还没出。就凭思维难度来说，四道题加起来差不多在我水平范围左右。还是挺好玩的。但是讲起代码，T3 可能确实要理清楚思维的细节，T4 的块状链表我也确实不熟悉。没话说。确实没有过硬本领。</p><p>在成绩出之前，留一两句总结吧：</p><p>……</p><p>行动起来，去写题吧！</p><h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY +1"></a>DAY +1</h2><p><em>2023.1.16.</em></p><p>写下这篇游记。</p><h2 id="DAY-9"><a href="#DAY-9" class="headerlink" title="DAY +9"></a>DAY +9</h2><p><em>2023.1.24.</em></p><p>出分。J：$100+100+100+100=400$。</p><p>S：$15+0+15+10=40$。</p><h2 id="DAY-13"><a href="#DAY-13" class="headerlink" title="DAY +13"></a>DAY +13</h2><p><em>2023.1.28.</em></p><p>S 组发现白挂分了。在 magicoj T1 可以上 $100$，如果上 HydroOJ T2 可以上 $90$。申诉无果。</p><p>如果是常数跑不过，我觉得组织者也不太够走心吧。</p><p>以及，T4 暴力可 AC。这比 <em>总司令，不可以</em> 不知道夸张多少。</p><p>T3 还是比较妙妙的，虽然还不算会。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - P8884 「JEOI-R1」棋</title>
    <link href="/sol-LGP8884/"/>
    <url>/sol-LGP8884/</url>
    
    <content type="html"><![CDATA[<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>本人出题，觉得自己写得比较明白，所以不想再加简述。</p><h2 id="部分分-1"><a href="#部分分-1" class="headerlink" title="部分分 1"></a>部分分 1</h2><p>只是觉得大部分的暴力都应该跑得过，给点暴力分。依照题意模拟能过吧。</p><h2 id="部分分-2"><a href="#部分分-2" class="headerlink" title="部分分 2"></a>部分分 2</h2><p>下文称一个位置 $(x,y)$ 为奇数位置，当且仅当 $x+y\equiv 1\pmod 2$，偶数位置则相对，$x+y\equiv 0\pmod 2$。</p><p>我们考虑任意两个偶数位置，一个有棋子，另一个是空位，那么经过一些移动，另一个空位必然可达。</p><p>首先如果路径上没有点，那么一定有一条路径，这个不想解释了。</p><p>如果路径上会被阻隔，那么只要让阻隔的那个点移过去就可以了，等价。</p><p>这启示我们分奇偶判断。</p><h2 id="部分分-3"><a href="#部分分-3" class="headerlink" title="部分分 3"></a>部分分 3</h2><p>这一部分都是子矩阵内空间不是很够的提示。</p><p>这启示我们既要考虑棋子够不够，还要考虑空位够不够。</p><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p><del>这样一看，好像上面的部分分都不是真的在给分，只是给一点思考的提示。</del></p><p>结论：看<strong>奇数位置的棋、奇数位置的空、偶数位置的棋、偶数位置的空够不够</strong>。</p><p>对于如何计算奇数/偶数位置的总量：</p><ul><li><p><strong>当有任意一维长为偶数的时候</strong>：显然奇偶数位置相等（考虑这一维相邻两行/列两两配对互补），总位置除以二即为每一种的数目。</p></li><li><p><strong>当两维都长为奇数的时候</strong>：考虑两维长度同时 $\bmod\ 2$（两两配对互补），发现只可能一种比另一种刚好多 $1$ 个，这一个就是任意一个角的奇偶。</p></li></ul><p>综上，如果两维 $n,m$ 都为奇数，左上角为奇数位置，那么奇数位置数就是 $\lceil\frac{nm}{2}\rceil$，偶数位置数即为 $\lfloor\frac{nm}{2}\rfloor$；否则，奇数位置数是 $\lfloor\frac{nm}{2}\rfloor$，偶数位置数是 $\lceil\frac{nm}{2}\rceil$。</p><p>那么上述四个变量对于任意一个子矩阵都可以 $O(1)$ 求出。最后时间复杂度 $O(C+\sum p)$。</p><p><del>std 用的是 <code>iostream</code>，跑得很快，有人会被卡常吗？</del></p><p><del>记得开 <code>long long</code>。</del></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll N, M, C, C0, C1, Q, R0, R1;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N &gt;&gt; M &gt;&gt; C;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">b</span>(<span class="hljs-number">0</span>); C--;) &#123;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">if</span> ((a + b) &amp; <span class="hljs-number">1</span>)<br>      ++C1;<br>    <span class="hljs-keyword">else</span><br>      ++C0;<br>  &#125;<br>  R0 = <span class="hljs-built_in">ceil</span>(N / <span class="hljs-number">2.0</span> * M) - C0; <span class="hljs-comment">// 偶数空有多少。注意左上角必为偶数空</span><br>  R1 = <span class="hljs-built_in">floor</span>(N / <span class="hljs-number">2.0</span> * M) - C1; <span class="hljs-comment">// 奇数空有多少</span><br>  cin &gt;&gt; Q;<br>  <span class="hljs-keyword">for</span> (ll <span class="hljs-built_in">x1</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y1</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x2</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y2</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">p</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">c0</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">c1</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">r0</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">r1</span>(<span class="hljs-number">0</span>); Q--;) &#123;<br>    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; p;<br>    c0 = c1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">c</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">d</span>(<span class="hljs-number">0</span>); p--;) &#123;<br>      cin &gt;&gt; c &gt;&gt; d;<br>      <span class="hljs-keyword">if</span> ((c + d) &amp; <span class="hljs-number">1</span>)<br>        ++c1;<br>      <span class="hljs-keyword">else</span><br>        ++c0;<br>    &#125;<br>    r0 = <span class="hljs-built_in">ceil</span>((x2 - x1 + <span class="hljs-number">1</span>) / <span class="hljs-number">2.0</span> * (y2 - y1 + <span class="hljs-number">1</span>)) - c0; <span class="hljs-comment">// 子矩阵内偶数空</span><br>    r1 = <span class="hljs-built_in">floor</span>((x2 - x1 + <span class="hljs-number">1</span>) / <span class="hljs-number">2.0</span> * (y2 - y1 + <span class="hljs-number">1</span>)) - c1; <span class="hljs-comment">// 子矩阵内奇数空</span><br>    <span class="hljs-keyword">if</span> ((x2 - x1 + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span> &amp;&amp; (y2 - y1 + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span> &amp;&amp; (x1 + y1) &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 分两类讨论</span><br>      r0 = <span class="hljs-built_in">floor</span>((x2 - x1 + <span class="hljs-number">1</span>) / <span class="hljs-number">2.0</span> * (y2 - y1 + <span class="hljs-number">1</span>)) - c0;<br>      r1 = <span class="hljs-built_in">ceil</span>((x2 - x1 + <span class="hljs-number">1</span>) / <span class="hljs-number">2.0</span> * (y2 - y1 + <span class="hljs-number">1</span>)) - c1;<br>    &#125;<br>    cout &lt;&lt; ((C0 &gt;= c0 &amp;&amp; C1 &gt;= c1 &amp;&amp; R0 &gt;= r0 &amp;&amp; R1 &gt;= r1) ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) <span class="hljs-comment">// 只要四个变量都是够的，就可以移</span><br>         &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ad-hoc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记 - LCA 求法总结</title>
    <link href="/note-lca/"/>
    <url>/note-lca/</url>
    
    <content type="html"><![CDATA[<p>LCA：Lowest Common Ancestor，树上最近公共祖先。</p><p>代码以 <a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA）</a> 为例。</p><h2 id="树上倍增"><a href="#树上倍增" class="headerlink" title="树上倍增"></a>树上倍增</h2><h3 id="树上倍增-思路"><a href="#树上倍增-思路" class="headerlink" title="树上倍增 - 思路"></a>树上倍增 - 思路</h3><p>对于一个询问，我们可以考虑两个点深度相等的时候同时向上跳，不等就跳到相等，LCA 就是两者第一次跳到重合的点。这么做是 $O(n)$ 的。</p><p>发现太慢了，考虑一次可不可以多跳一点。考虑倍增。设 $jump_{i,j}$ 为点 $i$ 跳了 $2^j$ 步之后的点，即 $2^j$ 级祖先。对于一个询问，我们就由大倍往小倍一个一个试跳。如果跳到同一个点，那么可能就超过 LCA 了。所以跳到最高的不同的两个点，此时再跳一步必然重合，也就是说这两个点必为兄弟，父亲即为 LCA。这么做，在跳两个点深度相等时也可以二进制分解，倍增地跳。如果一者是另一者祖先，那么这一步就可以判定出来然后返回了。</p><p>具体实现来说，我们把 $jump$ 数组和每个点的深度在一次 dfs 中预处理。$jump<em>{i,0}$ 必为其父亲，别的可以用 $2^i=2^{i-1}+2^{i-1}$ 来合并，也就是可以 $jump</em>{i,j}=jump<em>{jump</em>{i,j-1},j-1}$。在每一次询问中，先看两个点的深度差，二进制分解，跳到深度相等为止。如果此时两点重合，显然是因为一点是另一点祖先，返回该点即可。然后从大倍往小倍试，跳到最高而不重合，返回这对兄弟的父亲即可。</p><p>空间 $O(n\log n)$，时间 $O(n\log n)-O(\log n)$。</p><p>优点：思路简单。</p><p>缺点：复杂度较大。</p><h3 id="树上倍增-代码"><a href="#树上倍增-代码" class="headerlink" title="树上倍增 - 代码"></a>树上倍增 - 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">500005</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXLG = <span class="hljs-number">19</span>;<br><span class="hljs-type">int</span> N, M, S;<br><span class="hljs-type">int</span> head[MXN], to[MXN &lt;&lt; <span class="hljs-number">1</span>], nxt[MXN &lt;&lt; <span class="hljs-number">1</span>], egsz;<br><span class="hljs-type">int</span> depth[MXN], jump[MXN][MXLG];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  to[egsz] = y, nxt[egsz] = head[x], head[x] = egsz++;<br>  to[egsz] = x, nxt[egsz] = head[y], head[y] = egsz++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>  depth[x] = d;<br>  <span class="hljs-built_in">fill</span>(jump[x], jump[x] + MXLG, <span class="hljs-number">-1</span>);<br>  jump[x][<span class="hljs-number">0</span>] = f;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= d; ++i) jump[x][i] = jump[jump[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(head[x]); ~i; i = nxt[i]) &#123;<br>    <span class="hljs-keyword">if</span> (to[i] == f) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">pre</span>(x, to[i], d + <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (depth[x] &lt; depth[y]) <span class="hljs-built_in">swap</span>(x, y);<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diff</span><span class="hljs-params">(depth[x] - depth[y])</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(MXLG - <span class="hljs-number">1</span>); ~i; --i)<br>    <span class="hljs-keyword">if</span> (diff &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) x = jump[x][i];<br>  <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(MXLG - <span class="hljs-number">1</span>); ~i; --i)<br>    <span class="hljs-keyword">if</span> (jump[x][i] ^ jump[y][i]) x = jump[x][i], y = jump[y][i];<br>  <span class="hljs-keyword">return</span> jump[x][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;N, &amp;M, &amp;S);<br>  --S;<br>  <span class="hljs-built_in">fill</span>(head, head + N, <span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), --x, --y;<br>    <span class="hljs-built_in">addedge</span>(x, y);<br>  &#125;<br>  <span class="hljs-built_in">pre</span>(<span class="hljs-number">-1</span>, S, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); M--;) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), --x, --y;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">(query(x, y))</span></span>;<br>    ++ans, <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Tarjan-离线算法"><a href="#Tarjan-离线算法" class="headerlink" title="Tarjan 离线算法"></a>Tarjan 离线算法</h2><h3 id="Tarjan-离线算法-思路"><a href="#Tarjan-离线算法-思路" class="headerlink" title="Tarjan 离线算法 - 思路"></a>Tarjan 离线算法 - 思路</h3><p>考虑对于一个点，它子孙与它的 LCA 是它自己，它兄弟及兄弟的子孙与它的 LCA 是他的父亲，它爷爷的其他孩子及子孙与它的 LCA 是它的爷爷……</p><p>思考这样一个过程——我在一个点全部遍历完之后，把它与父亲的连边启用，意思类似于合并它与它的父亲。</p><p>考虑点 $p$ 已被访问，在访问点 $q$ 的时候要回答 $\operatorname{LCA}(p,q)$ 的询问。此时与点 $p$ 合并在一起的最高的点 $a$ 一定是 $p$ 的祖先，并且这个 $a$ 还没有遍历完，否则 $a$ 也会被和它的父亲合并。既然如此，$q$ 就必然是这个 $a$ 的子孙。那么，点 $a$ 就是 LCA，因为它是公共祖先，同时不会存在更低的公共祖先，因为更低的公共祖先子孙已经遍历完，不可能是 $q$ 的祖先。</p><p>如果我要在一次 dfs 里面解决所有询问，那么一个询问一定有一种写法，使得当我访问到其中一个节点的时候，另一个已经被访问过了。所以对于这种形式的询问，只要动态维护另一个点的答案即可。</p><p>例如样例的 $\operatorname{LCA}(2,3)$。假设先遍历 $2$，然后就可以将 $2$ 与 $4$ 合并，因为只要不是它的子孙，就不可能与它的 LCA 是它自己，所以答案都可以是 $4$。当我遍历到 $3$ 的时候，就更新其答案为 $4$。</p><p>这个合并实际上就是并查集。</p><p>具体一些，就是我把每个询问正反各加入一次，这一步可以用链表/<code>vector</code> 维护。在一次 dfs 中，先往下 dfs，否则对于一个为另一个祖先的询问永远不会被回答到。每遍历完一个儿子，就让它与自己合并，以自己为根。然后一个一个处理询问，对于另一个点还未遍历过的询问就跳过，否则答案就是另一个点所在并查集的根。</p><p>时间复杂度：使用路径压缩并查集，就是 $O((n+m)\alpha(n))$（$\alpha$ 是反阿克曼函数<del>众所周知就是常数</del>）。</p><p>空间复杂度：$O(n+m)$。</p><p>优点：效率极高。</p><p>缺点：思路有点绕弯。</p><h3 id="Tarjan-离线算法-代码"><a href="#Tarjan-离线算法-代码" class="headerlink" title="Tarjan 离线算法 - 代码"></a>Tarjan 离线算法 - 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">500005</span>;<br><span class="hljs-type">int</span> N, M, S;<br><span class="hljs-type">int</span> head[MXN], to[MXN &lt;&lt; <span class="hljs-number">1</span>], nxt[MXN &lt;&lt; <span class="hljs-number">1</span>], egsz;<br><span class="hljs-type">int</span> ahead[MXN], ato[MXN &lt;&lt; <span class="hljs-number">1</span>], anxt[MXN &lt;&lt; <span class="hljs-number">1</span>], asz;<br><span class="hljs-type">int</span> fa[MXN];<br><span class="hljs-type">bool</span> vis[MXN];<br><span class="hljs-type">int</span> ans[MXN];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  to[egsz] = y, nxt[egsz] = head[x], head[x] = egsz++;<br>  to[egsz] = x, nxt[egsz] = head[y], head[y] = egsz++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addask</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  ato[asz] = y, anxt[asz] = ahead[x], ahead[x] = asz++;<br>  ato[asz] = x, anxt[asz] = ahead[y], ahead[y] = asz++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>  vis[x] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(head[x]); ~i; i = nxt[i]) &#123;<br>    <span class="hljs-keyword">if</span> (to[i] == f) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">dfs</span>(x, to[i]);<br>    fa[<span class="hljs-built_in">find</span>(to[i])] = x;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(ahead[x]); ~i; i = anxt[i]) &#123;<br>    <span class="hljs-keyword">if</span> (!vis[ato[i]]) <span class="hljs-keyword">continue</span>;<br>    ans[i &gt;&gt; <span class="hljs-number">1</span>] = <span class="hljs-built_in">find</span>(ato[i]);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;N, &amp;M, &amp;S);<br>  --S;<br>  <span class="hljs-built_in">fill</span>(head, head + N, <span class="hljs-number">-1</span>);<br>  <span class="hljs-built_in">fill</span>(ahead, ahead + N, <span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) fa[i] = i;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), --x, --y;<br>    <span class="hljs-built_in">addedge</span>(x, y);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); i != M; ++i) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), --x, --y;<br>    <span class="hljs-built_in">addask</span>(x, y);<br>  &#125;<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">-1</span>, S);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != M; ++i) &#123;<br>    ++ans[i], <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧拉序-RMQ"><a href="#欧拉序-RMQ" class="headerlink" title="欧拉序 RMQ"></a>欧拉序 RMQ</h2><h3 id="欧拉序-RMQ-思路"><a href="#欧拉序-RMQ-思路" class="headerlink" title="欧拉序 RMQ - 思路"></a>欧拉序 RMQ - 思路</h3><p>首先我们要知道欧拉序是什么。</p><p>每经过一次点（包括从父亲到自己或者儿子遍历完回到自己）就在欧拉序中记录一次。例如样例的一个欧拉序就是 <code>4 2 4 1 3 1 5 1 4</code>。</p><p>那么对于两个点，它们的非最低公共祖先不可能存在于他们在欧拉序中两个位置之间，根据定义即可理解。反之，它们的非公共祖先可能不出现，也可能出现，但是一定不会高过最低公共祖先。最低公共祖先也一定会出现，这个根据定义即可理解啊……</p><p>例如这里的 $\operatorname{LCA}(2,3)$，因为最低公共祖先要换一个儿子来遍历，所以这里之间 $4$ 会出现一次。反之，$3$ 和 $5$ 之间就没有 $4$，但是有 $1$，是最高点。</p><p>所以对于每个询问，只要知道它在欧拉序上两个端点之间（包括）最高的点就可以了，这里一个点虽然可能出现多次，任意一个即可，这个比较好想的。</p><p>那不就是 RMQ 吗。</p><p>这个 RMQ 理论上来说用 Sparse Table 或线段树都可以，但是一般都用 Sparse Table，此时询问 $O(1)$。</p><p>空间 $O(n\log n)$，时间 $O(n\log n)-O(1)$。</p><p>优点：思路清奇，快。</p><p>缺点：写的多一点。</p><h3 id="欧拉序-RMQ-代码"><a href="#欧拉序-RMQ-代码" class="headerlink" title="欧拉序 RMQ - 代码"></a>欧拉序 RMQ - 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">500005</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXLG = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> N, M, S;<br><span class="hljs-type">int</span> head[MXN], to[MXN &lt;&lt; <span class="hljs-number">1</span>], nxt[MXN &lt;&lt; <span class="hljs-number">1</span>], egsz;<br><span class="hljs-type">int</span> depth[MXN], pos[MXN];<br><span class="hljs-type">int</span> lg[MXN &lt;&lt; <span class="hljs-number">1</span>], seq[MXLG][MXN &lt;&lt; <span class="hljs-number">1</span>], sl;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> depth[x] &lt; depth[y] ? x : y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  to[egsz] = y, nxt[egsz] = head[x], head[x] = egsz++;<br>  to[egsz] = x, nxt[egsz] = head[y], head[y] = egsz++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>  depth[x] = d;<br>  pos[x] = sl;<br>  seq[<span class="hljs-number">0</span>][sl++] = x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(head[x]); ~i; i = nxt[i]) &#123;<br>    <span class="hljs-keyword">if</span> (to[i] == f) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">dfs</span>(x, to[i], d + <span class="hljs-number">1</span>);<br>    seq[<span class="hljs-number">0</span>][sl++] = x;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(lg[r - l])</span></span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">cmp</span>(seq[n][l], seq[n][r - (<span class="hljs-number">1</span> &lt;&lt; n)]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;N, &amp;M, &amp;S);<br>  --S;<br>  <span class="hljs-built_in">fill</span>(head, head + N, <span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), --x, --y;<br>    <span class="hljs-built_in">addedge</span>(x, y);<br>  &#125;<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">-1</span>, S, <span class="hljs-number">0</span>);<br>  lg[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>, lg[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">2</span>); i &lt;= sl; ++i) lg[i] = lg[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= sl; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j + (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>)) &lt;= sl; ++j) &#123;<br>      seq[i][j] = <span class="hljs-built_in">cmp</span>(seq[i - <span class="hljs-number">1</span>][j], seq[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); M--;) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), --x, --y;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">(query(min(pos[x], pos[y]), max(pos[x], pos[y]) + <span class="hljs-number">1</span>))</span></span>;<br>    ++ans, <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dfs-序-RMQ"><a href="#dfs-序-RMQ" class="headerlink" title="dfs 序 RMQ"></a>dfs 序 RMQ</h2><h3 id="dfs-序-RMQ-思路"><a href="#dfs-序-RMQ-思路" class="headerlink" title="dfs 序 RMQ - 思路"></a>dfs 序 RMQ - 思路</h3><p>从 ckj 的 blog 里面学来的另一种 $O(1) \operatorname{LCA}$ 写法。stO ckj Orz。</p><p>考虑 dfs 序有什么性质：一个子树是连续的，根在第一位，后面是一棵棵连续的子树。也就是说，一个点的祖先一定在它的前面。</p><p>假设询问的两个点的 dfs 序上位置是 $p,q$，答案的 dfs 序上位置是 $a$。</p><p>分类讨论：</p><ul><li>$p\neq a$。</li></ul><p>在 dfs 序中，$a$ 就是最靠前的，路径应该是 $a$ 下到 $p$，然后回来，进入另一个 $a$ 的儿子，下去到 $q$。意思是说，$[p,q]$ 一定有一个 $a$ 的儿子，而且也必然没有深度更浅的点了。</p><p>所以可以 RMQ 求 $[p,q]$ 之间最浅的点，取父亲即可。</p><ul><li>$p=a$。</li></ul><p>我们当然可以特判。但这样多一个数组。</p><p>考虑 $[p,q]$ 也一定有一个 $p$ 的儿子，那也就是说，$[p+1,q]$ 里面最浅的点是 $p$ 的儿子。代回到上一个情况，发现也是合法的，不会漏判。</p><p>所以——我们还是要特判的，判 $p=q$ 时。</p><p>空间 $O(n\log n)$，时间 $O(n\log n)-O(1)$。</p><p>优点：保持时间优势的同时时空常数更小。</p><p>缺点：有点难找。可能没有前者好理解、以及容易漏特判？</p><h3 id="dfs-序-RMQ-代码"><a href="#dfs-序-RMQ-代码" class="headerlink" title="dfs 序 RMQ - 代码"></a>dfs 序 RMQ - 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">500005</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXLG = <span class="hljs-number">19</span>;<br><span class="hljs-type">int</span> N, M, S;<br><span class="hljs-type">int</span> head[MXN], to[MXN &lt;&lt; <span class="hljs-number">1</span>], nxt[MXN &lt;&lt; <span class="hljs-number">1</span>], egsz;<br><span class="hljs-type">int</span> depth[MXN], pos[MXN], fa[MXN];<br><span class="hljs-type">int</span> lg[MXN], seq[MXLG][MXN], sl;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> depth[x] &lt; depth[y] ? x : y; &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  to[egsz] = y, nxt[egsz] = head[x], head[x] = egsz++;<br>  to[egsz] = x, nxt[egsz] = head[y], head[y] = egsz++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>  depth[x] = d;<br>  pos[x] = sl;<br>  fa[x] = f;<br>  seq[<span class="hljs-number">0</span>][sl++] = x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(head[x]); ~i; i = nxt[i]) &#123;<br>    <span class="hljs-keyword">if</span> (to[i] == f) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">dfs</span>(x, to[i], d + <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(lg[r - l])</span></span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">cmp</span>(seq[n][l], seq[n][r - (<span class="hljs-number">1</span> &lt;&lt; n)]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;N, &amp;M, &amp;S);<br>  --S;<br>  <span class="hljs-built_in">fill</span>(head, head + N, <span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), --x, --y;<br>    <span class="hljs-built_in">addedge</span>(x, y);<br>  &#125;<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">-1</span>, S, <span class="hljs-number">0</span>);<br>  lg[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>, lg[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">2</span>); i &lt;= N; ++i) lg[i] = lg[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= N; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j + (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>)) &lt;= N; ++j) &#123;<br>      seq[i][j] = <span class="hljs-built_in">cmp</span>(seq[i - <span class="hljs-number">1</span>][j], seq[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); M--;) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), --x, --y;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">(x ^ y ? fa[query(min(pos[x], pos[y]) + <span class="hljs-number">1</span>, max(pos[x], pos[y]) + <span class="hljs-number">1</span>)]</span></span><br><span class="hljs-params"><span class="hljs-function">                  : x)</span></span>;<br>    ++ans, <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><h3 id="树链剖分-思路"><a href="#树链剖分-思路" class="headerlink" title="树链剖分 - 思路"></a>树链剖分 - 思路</h3><p><a href="https://sunsetglow95.github.io/2022/02/28/note-hld/">同样的话没法再说一遍。</a>最多就是并不需要 $dfn$ 和 $rdfn$ 数组。</p><p>空间复杂度：$O(n)$。</p><p>时间复杂度：$O(n)-O(\log n)$。</p><p>优点：树剖比较通用。</p><p>缺点：代码较长，数组多（虽然只有 LCA 的时候看起来并不多呀）。</p><h2 id="斜二进制倍增"><a href="#斜二进制倍增" class="headerlink" title="斜二进制倍增"></a>斜二进制倍增</h2><h3 id="斜二进制倍增-思路"><a href="#斜二进制倍增-思路" class="headerlink" title="斜二进制倍增 - 思路"></a>斜二进制倍增 - 思路</h3><p>详见<a href="https://www.luogu.com.cn/article/x0sfn9kl">原作者出处</a>。</p><p>简单来说就是摒弃掉二进制意义的倍增，而改为斜二进制，然后你发现空间复杂度丢掉了一只 $\log$。</p><p>空间复杂度：$O(n)$。</p><p>时间复杂度：$O(n)-O(\log n)$。</p><p>优点：在所有单次查询 $O(\log n)$ 的做法里面，常数和代码长度几乎是最优的。</p><p>缺点：在长剖求 k 级祖先问题中无法打败二进制倍增。</p><h3 id="斜二进制倍增-代码"><a href="#斜二进制倍增-代码" class="headerlink" title="斜二进制倍增 - 代码"></a>斜二进制倍增 - 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">500005</span>;<br><span class="hljs-type">int</span> N, M, S;<br>vector&lt;<span class="hljs-type">int</span>&gt; to[MXN];<br><span class="hljs-type">int</span> dep[MXN], fa[MXN], lb[MXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> f)</span> </span>&#123;<br>  dep[p] = dep[f] + <span class="hljs-number">1</span>, fa[p] = f;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(lb[f])</span>, <span class="hljs-title">y</span><span class="hljs-params">(lb[x])</span></span>;<br>  lb[p] = (dep[f] + dep[y] == dep[x] * <span class="hljs-number">2</span> ? y : f);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q : to[p]) <span class="hljs-keyword">if</span> (q ^ f) <span class="hljs-built_in">pre</span>(q, p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getlca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);<br>  <span class="hljs-keyword">while</span> (dep[x] &gt; dep[y]) x = (dep[lb[x]] &gt;= dep[y] ? lb : fa)[x];<br>  <span class="hljs-keyword">while</span> (x ^ y) lb[x] ^ lb[y] ? (x = lb[x], y = lb[y]) : (x = fa[x], y = fa[y]);<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;N, &amp;M, &amp;S);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); i != N; ++i)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), to[x].<span class="hljs-built_in">push_back</span>(y), to[y].<span class="hljs-built_in">push_back</span>(x);<br>  <span class="hljs-built_in">pre</span>(S, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); M--;)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">getlca</span>(x, y));<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - CSP-J/S 2022 第二轮 VP</title>
    <link href="/rec-2022csp2-v/"/>
    <url>/rec-2022csp2-v/</url>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>广州三区被禁止考试，要么去考场附近做三天核酸，住酒店上网课。</p><p>初中一刀砍。</p><p>CSP 的下一个星期初就是期中考试。</p><p>……</p><p>还记得，2021 CSP J 组的 336，S 组的 55。一轮遗憾的绿勾。</p><p>初二，还没到我能修补遗憾的机会。</p><p>GD 或许会做一个补测，但有用么？谁知道呢。</p><hr><h2 id="CSP-J-VP"><a href="#CSP-J-VP" class="headerlink" title="CSP-J VP"></a>CSP-J VP</h2><p><strong><em>2022.10.29 13:00-14:00.</em></strong></p><p>当天看题，一眼会了。算有至多一小时的思考时间吧。</p><p>T1 一看到幂，然后还有大小限制，八成离不开快速幂的应用了。也确实如此，只要小改一点点，加点判断，可以做。</p><p>T2 第一反应是数论，拆了半天发现 $e_i\times d_i$ 那个式子没什么特别意义，再加上题面还有那么明显的 $m$ 的提示，那就是解二元二次方程组了。</p><p>T3 看到运算表达式加上算短路，大概就知道栈或者树了。</p><p>T4 其实一开始看，怀疑他是不是就是横纵坐标排个序然后背包一下，以为太简单了，后来一看数据范围，真是。</p><p><strong><em>2022.10.31 8:55-9:35.</em></strong></p><p>先秒掉前两题。</p><p>中间有一段时间在认真听网课，一段时间蹲茅坑听网课。</p><p><strong><em>2022.11.1 21:30-22:30.</em></strong></p><p>感觉 T4 思路比较简单一些，搞了 T4。</p><p>突然发现 T3 建树是 $O(n^2)$ 的，于是发现可以直接用递归。</p><p>然后测样例，发现同级 <code>&amp;</code> 比 <code>|</code> 优先，又改了改，用了 <code>vector</code>、<code>tuple</code> 啥的，确实有点复杂，对于理清思路的锻炼来说也比较有意义。</p><p>四道题，都是写完即交，一遍 A。</p><p>总时间约为 2.5h。</p><p>如果在考场上，我应该还有 1 小时可以练一练对拍。</p><hr><h2 id="CSP-S-VP"><a href="#CSP-S-VP" class="headerlink" title="CSP-S VP"></a>CSP-S VP</h2><p><strong><em>2022.11.3 13:30-14:00.</em></strong></p><p>抽点午睡来看题。</p><p>没思路。</p><p>但是 T2 看起来是简单区间最值问题。T4 看起来像是长得像单调队列的东西。</p><p><strong><em>2022.11.5 14:00-17:30.</em></strong></p><p>花 1h 把 T2 ST 表码了。</p><p>然后看 T1。感觉既可做又不可做。</p><p>时间复杂度很宽裕，跑得过 $O(nm)$，足以跑全源最短路，$O(n^2)$ 更是绰绰有余。</p><p>枚举路途的点？四个点无法承受，三个点也不行——枚举中间的两个点不就可以了嘛？</p><p>！！！那么这道题就被切了。</p><p>但已经快没时间了。看看 T3、T4？</p><p>T4 $k$ 好小，应该是动态 dp——可是我不会。</p><p>看看 T3——中间两档性质的部分分，是不是也可以放暴力过？可是真的快没时间了……</p><p>最终提交：$100+100+60+0=260$。</p><p>翻身了？或许也没有完全翻。代码依然打得磕磕绊绊的，这耗费了大量时间。</p><p>结束了。</p><p>结束了？</p><hr><h2 id="Beside-OI"><a href="#Beside-OI" class="headerlink" title="Beside OI"></a>Beside OI</h2><h3 id="Hobby"><a href="#Hobby" class="headerlink" title="Hobby"></a>Hobby</h3><p>从第一次看到 D-Low 开始，看一些 GBB 的视频，被各种 bbxr 吸引了，开始练。</p><p>大概是写下这篇游记的今天才确认，这个随时随地都在练习的习惯是招人厌恶的，是对我的社交关系有负面影响的，还是别人不会提醒的。</p><h3 id="WHK"><a href="#WHK" class="headerlink" title="WHK"></a>WHK</h3><p>在我的不懈努力之下，期中考真的挂了。至少，我的理科挂了：</p><p>数学 $109$，物理 $88$。</p><p>有人要说了：“你这不是凡尔赛吗？”</p><p>数学这分数我以前也考过，七上期末就是 $109$。那是我在大考中的至暗时刻。</p><p>至少数学，我真的感受到开始远离那些平常可以一起聊的同学了。我成功地把数学成绩越拉越低，从班里较高梯队掉到中等可能偏下水平。更扎心：没什么错题是我在考后自己觉悟。只有一道，非常简单的构造完全平方，我居然没有想到，考场上去想些硬凑的法子。好。信息学还是一门应用数学呢，讽刺。</p><p>物理向来不太好，我也确实不喜欢。</p><p>语文，老样子，不上不下。</p><p>历史，老样子，上上下下。</p><p>但是托福——额，我的意思是托同学、学长和老师的福——我的道法好了一些。很开心。</p><p>英语又一次回到了近巅峰状态——在哪里有投入，哪里就有收获。</p><p>可是我的上课状态依然是对于想好好听课的学科才能好好听，上数学课的因式分解全然不能找到有意义的事情做——初中还有时间试一点错，以后可能真没机会了。可是现在摆——或者说，只是一种尝试——了，以后还可能重振雄风么？我又为什么要在初中遇到好的人，却不能把最好的一面给 ta 们……</p><hr><p>But have no fear. Do your best.</p><p>Right?…</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - CSP-J/S 2022 第一轮</title>
    <link href="/rec-2022csp1/"/>
    <url>/rec-2022csp1/</url>
    
    <content type="html"><![CDATA[<p>新年新气象。</p><h2 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY -2"></a>DAY -2</h2><p><em>2022.9.16.</em></p><p>暴躁了。</p><p>为什么成年人开始那么喜欢脱口秀这种只为图一乐的东西了？一个晚上，一堆知乎网页，给不了我郦道元的山水情怀，只把我逼向无趣的脱口秀，和 22:49 的深夜。</p><p>我目前对自己作息的最优先计划是 21:30 上床睡觉，次目标是 22:00。但是如果总是犹疑不决，计划如何落实呢？常说自律与他律缺一不可，如果真的缺一，如何合理补救？</p><h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY -1"></a>DAY -1</h2><p><em>2022.9.17.</em></p><p>呵，考场在自己学校。</p><p>颓了一天，作业没怎么动，快睡觉翻一小会书吧。</p><h2 id="DAY-0"><a href="#DAY-0" class="headerlink" title="DAY 0"></a>DAY 0</h2><p><em>2022.9.18.</em></p><h2 id="Morning-Junior"><a href="#Morning-Junior" class="headerlink" title="Morning: Junior"></a>Morning: Junior</h2><p>哦。</p><p>为什么说“哦”？因为我觉得并没有很大的波澜、看点。不如去年。大部分题给人的感受就是：已阅。虽然我不一定打得好就是了。</p><h2 id="Noon"><a href="#Noon" class="headerlink" title="Noon"></a>Noon</h2><p>溜去 lzx 的房间陪他睡，顺便给了他一道思维题。哈哈。</p><h2 id="Afternoon-Senior"><a href="#Afternoon-Senior" class="headerlink" title="Afternoon: Senior"></a>Afternoon: Senior</h2><p>哦。好像比上午顺一点。</p><h2 id="Night"><a href="#Night" class="headerlink" title="Night"></a>Night</h2><p>luogu 估分：Junior 94.5，Senior 83。</p><p>哦。虽然危险，虽然不亮眼。反正能过就行。</p><hr><p>最累的反而是 WHK。</p><p>我越来越感受到人的精力是有限的。人不可能又有极强动力码 OI 题，又有充足动力搞 WHK，更不要谈为其他的预留时间了。</p><p>如何抉择？如何走下去？到底是先让自己将要迎来的期中考试绽放，还是志心搞体育或搞音乐，还是鼓起勇气好好做一个码农？</p><p>作业堆在桌上，厚重的一沓书也叠在桌上，桌子的骨架已松动。昏暗的台灯照着布满污垢的直尺，闪着一抹惨淡的反光，卧着一丝水笔，漫着几点墨迹。半开的笔记本浮动着暗淡的深蓝光标。只有口边的、耳畔的、心中的音乐还在孜孜不倦响动。</p><p>如果这样的我能走下去，我自己都不信。一个连自己手头要务都不知道的 SunsetGlow95！</p><p>作为学生，传统意义上，我的第一要务是弄好 WHK。</p><p>作为一个喜欢音乐的人，（以及一个或许辜负了一个音乐老师的学生，）我喜爱、也期盼能做出音乐。</p><p>作为一个已经想要把人生押在编程上的人，我不可能不为 OI 奔跑。</p><p>或许就在此后，可能有三个 SunsetGlow95 在三个不同的时空分支：守旧的顽固学者 SunsetGlow95，热爱音乐的凡人 SunsetGlow95，或是低头劳作的码农 SunsetGlow95。</p><p>这个时空的 SunsetGlow95，会是谁？Who will be this version of me?</p><hr><p>If I reach the light of day now,</p><p>如果我在此时接触到那抹日光——</p><p>哦，我心中的日光，你在哪里？</p><p>你在行行代码间，</p><p>你在跳动的音乐中，</p><p>但有时，你也要寄身于白色的试卷中。</p><p>你要放弃什么？</p><p>你会放弃什么？</p><p>你在承受什么苦难？</p><p>你又在逃避着什么苦难？</p><p>在没有未来的黑暗里，</p><p>在没有火把的隧道中，</p><p>只凭心中的信仰，易碎的光芒，</p><p>你会走下去吗？</p><p>你愿意走下去吗？</p><p>Until somewhere on my way…</p><h2 id="DAY-N"><a href="#DAY-N" class="headerlink" title="DAY +N"></a>DAY +N</h2><p><em>2022.9.29.</em></p><p>Junior 96.5，Senior 83。</p><p>初赛篇，完结。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - APIO 2022</title>
    <link href="/rec-2022apio/"/>
    <url>/rec-2022apio/</url>
    
    <content type="html"><![CDATA[<p>学校调休，请假了。</p><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>简略题意：$100$ bits 状压维护 $40\times 40$ 矩阵联通块数目，是一个很怪异的通信（自己看比较好）。</p><p>很怪异，找不到性质，打了个暴力：每次存下矩阵内所有的位置，最后一次跑完。$14$ pts 遗憾离场。</p><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>简略题意：在线判有向图是否有环经过某些钦定的点，$n,m$ 是 $10^5$ 级别。</p><p>离线可以二分。</p><p>赛场上直接维护每个非特别点的最左特别出点和最右特别入点，前者小于等于后者即可。本来该有 $30$ pts，最后不知道哪里挂了，$12$ pts 遗憾离场。</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>简略题意：构造一个排列，上升序列的数目 $k$ 给定，长度尽量在 $90$ 以内。</p><p>本来想明白如果都是连续上升序列，每一个贡献 $2^n-1$，再 $+1$。但是由于直接这么上，是不能直接二进制拆分的。所以打了 $10$ pts，遗憾离场。</p><h2 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h2><p>原来 T3 只要找到一个 $m\ge \text{lowbit}(m+k)$ 就可以了……</p><p>别人各种 $100+$，最后自己是 $36$ pts 遗憾离场……</p><p>不过不会就是不会。</p><p>优点有：</p><ol><li>心态相对平稳，发挥相对正常；</li><li>能骗到分。</li></ol><p>缺点有：</p><ol><li>思维灵活度不行；</li><li>还是容易写挂代码；</li><li>不熟悉非传统题型。</li></ol><p>状态从上半学期调整过来了，只是再多见识见识题目，思维要打开。要总结就是打了个寂寞……呵呵。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces 380C Sereja and Brackets</title>
    <link href="/sol-CF380C/"/>
    <url>/sol-CF380C/</url>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>每次询问一个区间的最大合法括号子序列长度。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一般遇到合法括号序列，很多时候可以直接转化：</p><p><strong>每个左括号视为 $1$，右括号视为 $-1$。合法的序列中每个前缀和不为负数，且以 $0$ 结束。</strong></p><p>所以对于一段前缀和，先考虑是否存在负数，如果存在，就去掉相应数量的右括号。</p><p>不以 $0$ 结束，就去掉相应数量的左括号。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一开始就直接维护整体的前缀和。那么，把单个区间的前缀和拎出来也就简单了。</p><p>默认是整个区间长度。查找负数直接用 RMQ 找个最小值即可。</p><p>注意，去掉右括号时要对整个区间的前缀和做对应的处理。</p><p>如果此时还不以 $0$ 结尾，就再去掉对应的左括号。</p><p>那么，这道题就被转化成了一个简单 RMQ！</p><p>假设区间长度是 $n$。$r=-\min(0,\min_{i=l}^{r}{a_i})$，而（未经变化的）整个区间的前缀和是 $s$。</p><p>那我的结论就是 $n-r-(s+r)$。</p><p>ST 表时间复杂度 $O(n\log n+m)$，线段树可以做到 $O(n+m\log n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>ST 表都可以跑过去。更怪异的是，如果写错 ST 表，取 $r$ 的时候不考虑最后一个元素，那么只要在 $s+r$ 那里加上绝对值也可以过（具体可以推一推式子，错解我就不赘述了）。笑死了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">1000005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXLG = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> st[MXN][MXLG], lg[MXN];<br><span class="hljs-type">char</span> str[MXN];<br><span class="hljs-type">int</span> N, M;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">(lg[r - l + <span class="hljs-number">1</span>])</span></span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(st[l][g], st[r - (<span class="hljs-number">1</span> &lt;&lt; g) + <span class="hljs-number">1</span>][g]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; (str + <span class="hljs-number">1</span>);<br>  N = <span class="hljs-built_in">strlen</span>(str + <span class="hljs-number">1</span>);<br>  lg[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">2</span>); i &lt;= N; ++i) lg[i] = lg[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;(&#x27;</span>) st[i][<span class="hljs-number">0</span>] = st[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> st[i][<span class="hljs-number">0</span>] = st[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= N; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">1</span>); j + (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>)) &lt;= N; ++j) &#123;<br>      st[j][i] = <span class="hljs-built_in">min</span>(st[j][i - <span class="hljs-number">1</span>], st[j + (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))][i - <span class="hljs-number">1</span>]);<br>    &#125;<br>  &#125;<br>  cin &gt;&gt; M;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">l</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">r</span>(<span class="hljs-number">0</span>); M--; ) &#123;<br>    cin &gt;&gt; l &gt;&gt; r;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nmin</span><span class="hljs-params">(-min(query(l, r) - st[l - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-number">0</span>))</span></span>;<br>    cout &lt;&lt; (r - l + <span class="hljs-number">1</span>) - nmin - (st[r][<span class="hljs-number">0</span>] - st[l - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + nmin) &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>括号序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 网络流 24 题</title>
    <link href="/sol-flow-network-24/"/>
    <url>/sol-flow-network-24/</url>
    
    <content type="html"><![CDATA[<p>这是个人的 网络流 24 题 做题记录。</p><h2 id="1-飞行员配对方案问题"><a href="#1-飞行员配对方案问题" class="headerlink" title="1. 飞行员配对方案问题"></a>1. 飞行员配对方案问题</h2><p><strong>类型：最大流（二分图）。</strong></p><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>一共有 $n$ 个飞行员，其中有 $m$ 个外籍飞行员和 $(n - m)$ 个英国飞行员，<strong>外籍飞行员从 $1$ 到 $m$ 编号</strong>，<strong>英国飞行员从 $m + 1$ 到 $n$ 编号</strong>。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>二分图最大匹配一眼题。</p><h2 id="2-方格取数问题"><a href="#2-方格取数问题" class="headerlink" title="2. 方格取数问题"></a>2. 方格取数问题</h2><p><strong>类型：最大流（最小割）。</strong></p><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>有一个 $m$ 行 $n$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>没有公共边 $\rightarrow$ 割。</p><p>所以就按照<strong>棋盘的二分图染色</strong>，跑这个图的最小割。总和 $-$ 最小割 $=$ 最大和。</p><p>总有指定一种颜色连向另一颜色。其中每个点与源/汇的容量是这个点的值，而两个颜色中间的连边为 INF，表示不作限制，在左右两种颜色之中取最优。</p><h2 id="3-最长不下降子序列问题"><a href="#3-最长不下降子序列问题" class="headerlink" title="3. 最长不下降子序列问题"></a>3. 最长不下降子序列问题</h2><p><strong>类型：最大流</strong></p><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p>给定正整数序列 $x_1 \ldots, x_n$。</p><ol><li>计算其最长不下降子序列的长度 $s$。</li><li>如果每个元素只允许使用一次，计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。</li><li>如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$（其他元素仍然只允许使用一次），则从给定序列中最多可取出多少个<strong>不同的</strong>长度为 $s$ 的不下降子序列。</li></ol><p>令 $a<em>1, a_2, \ldots, a_s$ 为构造 $S$ 时所使用的下标，$b_1, b_2, \ldots, b_s$ 为构造 $T$ 时所使用的下标。且 $\forall i \in [1,s-1]$，都有 $a_i \lt a</em>{i+1}$，$b<em>i \lt b</em>{i+1}$。则 $S$ 和 $T$ <strong>不同</strong>，当且仅当 $\exists i \in [1,s]$，使得 $a_i \neq b_i$。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>第一问，是朴素的 DP，$O(n^2)$。</p><p>第二问，做一个转化：<strong>序列 $=$ 路径</strong>，或者说，<strong>前驱-后继 $=$ 边</strong>。意思是说，把前后可能在序列里并列的两个元素连一条边，流就会经过这个路径。</p><p>再加一个<strong>拆点限流</strong>技巧，保证每个点只有一次。</p><p>再假设每个序列虚的头元素为 $S$，虚的尾元素为 $T$，最大流即可。</p><p>第三问，取消 $x_1$ 和 $x_n$ 的流量限制即可。</p><h2 id="4-圆桌问题"><a href="#4-圆桌问题" class="headerlink" title="4. 圆桌问题"></a>4. 圆桌问题</h2><p><strong>类型：最大流（二分图）。</strong></p><h3 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h3><p>有来自 $m$ 个不同单位的代表参加一次国际会议。第 $i$ 个单位派出了 $r_i$ 个代表。</p><p>会议的餐厅共有 $n$ 张餐桌，第 $i$ 张餐桌可容纳 $c_i$ 个代表就餐。</p><p>为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。请给出一个满足要求的代表就餐方案。</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>就是说，从源点连出每个单位，再将每个餐桌连向汇点，如果源点出来的每个流都能到汇点就有方案。</p><p><strong>从源点连出一部分点，将一部分点连向汇点，这两部分点又有其他的连边，这是一个常形——二分图。</strong></p><p>因为一个单位每个人都要在不同的餐桌，所以一个单位向每个餐桌连一条容量为 $1$ 的边。跑个最大流即可。</p><h2 id="5-试题库问题"><a href="#5-试题库问题" class="headerlink" title="5. 试题库问题"></a>5. 试题库问题</h2><p><strong>类型：最大流（二分图）。</strong></p><h3 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h3><p>假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。</p><h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>与上一题基本一致，只是左边每个试题（单位）连向右边每个餐桌（卷子）的边是给定的，不是全都连。</p><h2 id="6-魔术球问题"><a href="#6-魔术球问题" class="headerlink" title="6. 魔术球问题"></a>6. 魔术球问题</h2><p><strong>类型：最大流（二分图）。</strong></p><h3 id="题面-5"><a href="#题面-5" class="headerlink" title="题面"></a>题面</h3><p>假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1$，$2$，$3$，…的球：</p><ol><li><p>每次只能在某根柱子的最上面放球。</p></li><li><p>同一根柱子中，任何 $2$ 个相邻球的编号之和为完全平方数。</p></li></ol><p>试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球。例如，在 $4$ 根柱子上最多可放 $11$ 个球。</p><p>对于给定的 $n$，计算在 $n$ 根柱子上最多能放多少个球。</p><h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>依然用二分图最大匹配模型。左部只向右部连出边，表示一堆关系的前驱；右部只从左部连入边，表示一对关系的后继。</p><p><strong>前驱-后继 $=$ 边</strong>，枚举每个完全平方数连边。</p><p>此时，最大流就是最小割，也就是 最大匹配数 $=$ 总数 $-$ 最小柱子数。</p><p>所以，我们一个一个加点，看一看何时的最小柱子数超过 $n$ 然后输出即可。</p><h2 id="归纳：题型"><a href="#归纳：题型" class="headerlink" title="归纳：题型"></a>归纳：题型</h2><ol><li>最大流-二分图，可以使用二分图表示匹配/选择，<em>例：圆桌问题</em>；</li><li>最大流-最小割，用割表示当前元素存在某种独立关系，<em>例：方格取数问题</em>；</li><li>最大流，使用路径表示序列，<em>例：最长不下降子序列问题</em>。</li></ol><h2 id="归纳：技巧"><a href="#归纳：技巧" class="headerlink" title="归纳：技巧"></a>归纳：技巧</h2><ol><li>棋盘使用二分图染色，<em>例：方格取数问题</em>；</li><li>对于序列并行/序列数目最大化，用源点表示虚的头结点，用汇点表示虚的尾结点，<em>例：最长不下降子序列问题</em>；</li><li>一个点可以拆成两个点，其中间连边，表示这个点的最大流量，即拆点限流，<em>例：最长不下降子序列问题</em>；</li><li>特殊容量 $1$，表示一个路径，可用于计数，<em>例：试题库问题</em>；</li><li>特殊容量 INF，表示不作限制/自然选择最优，<em>例：方格取数问题</em>；</li><li>表示序列，用路径表示，<em>例：最长不下降子序列问题</em>；</li><li>表示前驱-后继关系，用连边（容量常为 $1$）表示，<em>例：魔术球问题</em>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - GDOI Junior 2022</title>
    <link href="/rec-2022gdoi-j/"/>
    <url>/rec-2022gdoi-j/</url>
    
    <content type="html"><![CDATA[<p>由于防疫，初中组集体劝退提高组省选。呵呵。</p><h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY 1"></a>DAY 1</h2><p>早上起来，头是木的，人是麻的。</p><p>先扫一遍。</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>入门题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, val[3] </span>= &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>  cin &gt;&gt; N &gt;&gt; val[<span class="hljs-number">0</span>] &gt;&gt; val[<span class="hljs-number">1</span>] &gt;&gt; val[<span class="hljs-number">2</span>];<br>  map&lt;string, <span class="hljs-type">int</span>&gt; mp;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mxv</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  string ans;<br>  <span class="hljs-keyword">while</span> (N--) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tp</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    string name;<br>    cin &gt;&gt; name &gt;&gt; tp;<br>    --tp;<br>    <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">find</span>(name) == mp.<span class="hljs-built_in">end</span>()) mp[name] = <span class="hljs-number">0</span>;<br>    mp[name] += val[tp];<br>    <span class="hljs-keyword">if</span> (mp[name] &gt; mxv) ans = name, mxv = mp[name];<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; mxv &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>看到区间异或和，马上想到前缀和差分。</p><p>要求的数组没有任何一个区间异或和为 $0$，放到前缀异或和数组上，就是没有两个数相等。</p><p>而合并两个数，就是在前缀异或和数组上删掉一个数。</p><p>所以最后就是看这个数组上有多少种数，因为是前缀和差分所以 $-1$。</p><p>结果如果是 $0$，就是不存在，输出 $-1$。</p><p>一眼题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  N = <span class="hljs-built_in">read</span>();<br>  set&lt;<span class="hljs-type">int</span>&gt; s;<br>  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">sum</span>(<span class="hljs-number">0</span>); N--; ) &#123;<br>    x = <span class="hljs-built_in">read</span>();<br>    sum ^= x;<br>    s.<span class="hljs-built_in">insert</span>(sum);<br>  &#125;<br>  <span class="hljs-built_in">write</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>), <span class="hljs-built_in">putchar</span>(<span class="hljs-number">10</span>);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>这题居然把我卡住了，做的时候各种思考人生，最后发现答案如此简单。</p><p>我们考虑放一个数组，$a_i$ 表示最大值不超过 $i$ 时分成的模块数，结论是 $\min i\times a_i$。</p><p>考虑对于一个点 $x$，他的权值是 $w<em>x$，那么对于 $a</em>{w_x}$ 以下的情况，该节点必然分裂给所有儿子，DFS 递归处理。</p><p>此外的情况，整颗子树只有 $1$ 的贡献。</p><p>所以我们在 DFS 的过程中维护一个差分数组，每次遍历到一个点都用如上规则更新一遍，最后前缀和一下，完了。</p><p>至于值域太大的问题，用 map 维护就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(head[x]); i; i = nxt[i], isleaf[x] = <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-built_in">dfs</span>(to[i]);<br>    ++sons[x];<br>  &#125;<br>  sum[tim[x]] += <span class="hljs-number">1</span> - sons[x];<br>  <span class="hljs-keyword">if</span> (!sons[x]) mxtm = <span class="hljs-built_in">max</span>(mxtm, tim[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  N = <span class="hljs-built_in">read</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) tim[i] = <span class="hljs-built_in">read</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>); i != N; ++i) <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>, i);<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>  map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-function">iterator <span class="hljs-title">i</span><span class="hljs-params">(sum.begin())</span></span>;<br>  map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-function">iterator <span class="hljs-title">j</span><span class="hljs-params">(i++)</span></span>;<br>  <span class="hljs-keyword">while</span> (i != sum.<span class="hljs-built_in">end</span>()) &#123;<br>    i-&gt;second += j-&gt;second;<br>    <span class="hljs-keyword">if</span> (i-&gt;first &gt;= mxtm) ans = <span class="hljs-built_in">min</span>(ans, i-&gt;first * <span class="hljs-number">1LL</span> * i-&gt;second);<br>    ++i, ++j;<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>赛时摆烂。太困了，明明都想到枚举方差都没有往下想。</p><p>对于一个合法等差数列，考虑以 $i$ 为右端点的贡献：（暂不考虑左端点超过当前区间，可以随便处理）（暂不考虑公差，随便转化）</p><script type="math/tex; mode=display">\sum_{j=i-R}^{i-L}{\prod_{k=j}^{i}{a_k}}</script><p>对于右边的乘积，我们可以前缀积去优化。</p><p>设前缀积所得数组为 $p$，原式化为：</p><script type="math/tex; mode=display">\sum_{j=i-R}^{i-L}{p_i\times p_j^{-1}}</script><p>对于这个 $\sum{p_j^{-1}}$，我们再用前缀和优化。</p><p>令 $p$ 数组的逆元前缀和数组为 $v$，原式化为：</p><script type="math/tex; mode=display">p_i\times(v_{i-L}-v_{i-R})</script><p>做完了。</p><h3 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h3><p>$100+100+100+0=300$。</p><p>不出所料。</p><p>期待下一天翻盘。</p><hr><h2 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h2><h3 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h3><p>式子中合法的 $i$，必满足 $n\not\equiv 0\pmod{i}$，$n\not\equiv 1\pmod{i}$，$n\not\equiv 2\pmod{i}$。</p><p>不会（其实只是懒得推简单做法），整除分块乱搞。</p><p>怎么乱搞呢？令 $n=mi+p$（$0\le p&lt;i$）。</p><p>有 $n=m(i+1)+(p-m)$，$n=m(i-1)+(p+m)$。</p><p>对于 $m$ 相同的一个块，只需要让右端点往左边慢慢移，看合不合法，反正移不了多少，顶多 $3$ 次，甚至不一定有。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  cin &gt;&gt; T;<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    cin &gt;&gt; N;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">4</span>); i &lt; N; i = N / (N / i) + <span class="hljs-number">1</span>)  &#123;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">a</span><span class="hljs-params">(N % i)</span>, <span class="hljs-title">b</span><span class="hljs-params">(N / (N / i) - i + <span class="hljs-number">1</span>)</span></span>;<br>      <span class="hljs-keyword">while</span> (~b &amp;&amp; a - N / i * b &lt;= <span class="hljs-number">2</span>) --b;<br>      ++b;<br>      ans += b;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h3><p>赛时瞎打 DP，直接挂开。</p><p>首先有一点：选择返回永远不是唯一最优解。</p><p>如果返回，会有至少 $1$ 的代价；即使新开，也一定可以有至多 $1$ 的花费。</p><p>所以对于一个节点向下访问，就选择一个节点替代打开，其他的新标签页打开。</p><p>这样子下去，每个点有 $1$ 的进入代价，一个标签页只在叶子结点关闭。</p><p>令叶子结点有 $l$ 个，答案就是 $n+l$。</p><h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>模拟题。我图个方便，就弄了一个前缀和的 trick，变成是 0.1.1 00:00:00 至后一个时间点的花费，减去到前一个点的花费。</p><p>样例一次过，不知道为啥好像挂了。</p><h3 id="T4-1"><a href="#T4-1" class="headerlink" title="T4"></a>T4</h3><p>看到这种题，第一反应是搜索。</p><p>分几个阶段讲讲我的思路。</p><h4 id="Stage-1-O-T-nm-S"><a href="#Stage-1-O-T-nm-S" class="headerlink" title="Stage 1: $O(T(nm|S|))$"></a>Stage 1: $O(T(nm|S|))$</h4><p>DP。对于每一步，遍历每个点，看能不能走到。</p><h4 id="Stage-2-O-T-nm-S-with-an-array"><a href="#Stage-2-O-T-nm-S-with-an-array" class="headerlink" title="Stage 2: $O(T(nm|S|))$ with an array"></a>Stage 2: $O(T(nm|S|))$ with an array</h4><p>搜索，从原点出发搜索，每次往数组里面永久增加待走结点。这样子做，可以减少起点不可达的无用状态。</p><h4 id="Stage-3-O-T-nm-S-with-a-list"><a href="#Stage-3-O-T-nm-S-with-a-list" class="headerlink" title="Stage 3: $O(T(nm|S|))$ with a list"></a>Stage 3: $O(T(nm|S|))$ with a list</h4><p>做个小优化：把每个被墙和已访问结点围住的结点去掉，也就是去除无意义状态，用链表维护。这样子，其实应该已经可以过了。但是最坏也可以卡到 $O(T(nm|S|))$。</p><h4 id="Stage-4-O-T-nm-S-with-four-queues"><a href="#Stage-4-O-T-nm-S-with-four-queues" class="headerlink" title="Stage 4: $O(T(nm+|S|))$ with four queues"></a>Stage 4: $O(T(nm+|S|))$ with four queues</h4><p>上述在什么时候会被卡？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">*RRR*RRR<br>*R*R*R*R<br>*R*R*R*R<br>*R*R*R*R<br>*R*R*R*R<br>*R*R*R*R<br>*R*R*R*R<br>*R*RRR*R<br></code></pre></td></tr></table></figure><p>虽然几乎达不到，但是此时如果一直往左走，每个点都会一直被访问，但是此时的访问没有意义。</p><p>所以我们考虑维护四个队列，维护四个方向的可扩展点。</p><p>对于每个点，在每个队列里最多进一次出一次，这一部分的时间复杂度就是 $O(nm)$。</p><p>此时我们可以证明，时间复杂度是严格的 $O(T(nm+|S|))$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pt;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DIRs = <span class="hljs-number">4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> MTCH[] = <span class="hljs-string">&quot;WSAD&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Xs[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Ys[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> pt <span class="hljs-title">gtnxt</span><span class="hljs-params">(pt p, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(p.first + Xs[d], p.second + Ys[d]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">isgoal</span><span class="hljs-params">(pt p)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> p.first &lt; <span class="hljs-number">0</span> || p.second &lt; <span class="hljs-number">0</span> || p.first &gt;= N || p.second &gt;= M;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">judg</span><span class="hljs-params">(pt p)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">isgoal</span>(p) || graph[p.first][p.second] == SPC;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(pt x)</span> </span>&#123;<br>  graph[x.first][x.second] = FPT;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != DIRs; ++i) &#123;<br>    <span class="hljs-function">pt <span class="hljs-title">nxt</span><span class="hljs-params">(gtnxt(x, i))</span></span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">judg</span>(nxt)) ques[i].<span class="hljs-built_in">push_back</span>(x);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != DIRs; ++i)<br>    ques[i].<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">trslt</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(MTCH, MTCH + DIRs, c) - MTCH; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, opts, &amp;N, &amp;M);<br>    <span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != M; ++j) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;graph[i][j]);<br>        <span class="hljs-keyword">if</span> (graph[i][j] == FPT) <span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(i, j));<br>      &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> *<span class="hljs-built_in">i</span>(opts); *i &amp;&amp; !ans; ++i) &#123;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">t</span><span class="hljs-params">(trslt(*i))</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sz</span><span class="hljs-params">(ques[t].size())</span></span>;<br>      <span class="hljs-keyword">while</span> (sz-- &amp;&amp; !ques[t].<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-function">pt <span class="hljs-title">nxt</span><span class="hljs-params">(gtnxt(ques[t].front(), t))</span></span>;<br>        ques[t].<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">judg</span>(nxt)) &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isgoal</span>(nxt)) &#123;<br>            ans = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-built_in">insert</span>(nxt);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(ans ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="std"><a href="#std" class="headerlink" title="std"></a>std</h4><p>最短路 $+$ DP。听不太懂，时间复杂度好像也没我的好，$O(T(nm\log(nm)+|S|))$。</p><p>不过好像可以优化 Dijkstra 算法，去掉 $\log$。</p><h3 id="赛后-1"><a href="#赛后-1" class="headerlink" title="赛后"></a>赛后</h3><p>$100+30+40+100=270$。</p><p>在这种略微比 CSP-J 难的比赛，就只剩 $570$ in $800$。</p><p>太惨烈了。这次主要失利的就是 D1T4、D2T2、D2T3。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以发展的优点还有：</p><ol><li>能够很快且精准地使用搜索；</li><li>能够在基础题上尽快地做过去，提高效率；</li><li>能够运用前缀和与差分的技巧。</li></ol><p>需要注意的缺陷还有：</p><ol><li>基础算法（模拟、贪心）掌握不熟练；</li><li>太追求效率去做压轴，导致简单题来不及做；</li><li>精神状态差。</li></ol><p>应对问题的措施包括：</p><ol><li>更注重基础算法；</li><li>在考试时合理安排节奏；</li><li>在赛时，甚至是最近的一段精神、效率低谷期，要保持一个平稳的心态，不能太松懈，不能太急躁。</li></ol>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游记 - NOI Online 2022</title>
    <link href="/rec-2022noio/"/>
    <url>/rec-2022noio/</url>
    
    <content type="html"><![CDATA[<p><em>Date: 2022-3-26.</em></p><h2 id="Morning-Senior"><a href="#Morning-Senior" class="headerlink" title="Morning: Senior"></a>Morning: Senior</h2><p>上午在七楼机房。</p><p>老师给我们的寄语是：权当增加比赛经验，练手。</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>读题的时候推了一下，发现只需要记录每个点在栈中的前驱在不在当前区间内，然后就变成是主席树水题了。复习数据结构。</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>不会，打了个暴力。就是，按集合从大到小排序，每遇到一个集合就分两种情况：是“开创者”还是“依附者”。弄个 map，每次存最后一个包含该数的集合编号，然后用常识判一下就完了。依据是必然有大的集合包含小的集合。</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>不会，拿了前 20 pts 部分分。10 pts 是暴力，10 pts 是 $m=2$ 时的 $2n\sum a$。</p><h3 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h3><p>洛谷给我估了个 $100+100+20=220$。</p><p>交流的时候，了解到学长 T1 用了离线树状数组的做法，又意识到 T2 本来用数组的地方用了 <code>std::map</code>。你好。</p><p>最终拿了 $100+50+20=170$。</p><p>突然发现，T2 有一个致命的问题：一旦出现两个完全相同的集合，它就无了。</p><p>打完之后，切身感觉到自己目前的一个奇怪的处境：对于熟练的东西很轻松，对于不会的东西根本不会，拿到的分微乎其微。</p><p>T3 后来了解到是很有趣的偏序。但在赛时，我根本不知道如何想。事实上，我知道二维数点，也知道 Min-Max 容斥，但就是想不到。</p><h2 id="Afternoon-Junior"><a href="#Afternoon-Junior" class="headerlink" title="Afternoon: Junior"></a>Afternoon: Junior</h2><p>下午回到六楼。</p><p>没有七楼爽。</p><h3 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h3><p>推了一个多小时的式子，最后大道至简地用图示确认了结论是 $\frac{z}{x\sqrt{gcd(\frac{z}{x}, x^2)}}$。</p><h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>不会，直接打了个逆推的 dfs。就是说，从目标往前推，如果遇到 <code>-</code>，就尝试在前或后加一个 <code>X</code>；否则，判断当前可不可能然后往下搜索即可。加了一个小的剪枝，当当前字符串已空时，答案就是 $2$ 的 还需要走多少个 <code>-</code> 次方：这个你就想，无论如何总是要删空的，每一个 <code>-</code> 只有 $2$ 种走法，就完了。</p><p>当时急了，不想做了，离交卷还有 1h 就溜了。</p><h3 id="赛后-1"><a href="#赛后-1" class="headerlink" title="赛后"></a>赛后</h3><p>我居然没有判不合法！！！</p><p>我太危了。</p><p>更离谱的是，赛时我都没发现检测 T2 是否合法的一个关键：是不是完全平方数。实验证明，<code>pow(sqrt(n))==n</code> 这样的做法在一个极小的数据集里可行，但也只是极小，大样例没有一个 <code>-1</code>。</p><p>洛谷估分 $100+20+30=150$。</p><p>结束了！！！</p><p>我想过 T3 会挂，因为我当时真的没静下心；但是我没想到 T2 能成这样。</p><p>实际分数 $100+100+80=280$。</p><p>这是否……</p><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>学到了：</p><ol><li>了解了离线树状数组的技巧，可以避免书写高级数据结构；</li><li>练习了有难度的数学题，巩固了数学；</li><li>练习了骗分。</li></ol><p>不好的现状：</p><ol><li>赛时静不下心，全忘了判合不合法，把数组用成 map，把就差一步的 DP 只留下 dfs，判完全平方数也写错；</li><li>对于基础知识的高级运用还是想不到；</li><li>对于复杂的 DP 模型还是建不起来。</li></ol><p>我觉得，这些东西还是应该在平时的练习里面多加感受与总结。另一方面，我近期的个人状态也不太好，希望能调整过来。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Luogu P4055 [JSOI2009]游戏</title>
    <link href="/sol-LGP4055/"/>
    <url>/sol-LGP4055/</url>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一个格点图上，两方轮流移动棋子一步，不能移到已走过的位置，移不动者输。问如何设定棋子的初始位置，使得后手必胜？</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>将这题可以分类为一类 <strong>二分图博弈</strong> 问题。</p><h3 id="为什么是二分图？"><a href="#为什么是二分图？" class="headerlink" title="为什么是二分图？"></a>为什么是二分图？</h3><p>这是一个常用的转换技巧，在许多网络流题目中体现的更精湛。一般一个网格图按照国际象棋的染色方式，可以被染成一个二分图。</p><p><img src="https://s2.loli.net/2025/08/31/5duWPC8UHJ6vwGB.png" alt="sol-LGP4055-1.png"></p><p>对于点 $(x,y)$，颜色就是 $x+y$ 的奇偶。</p><h3 id="转换后要怎么做？"><a href="#转换后要怎么做？" class="headerlink" title="转换后要怎么做？"></a>转换后要怎么做？</h3><p>首先给出一个大家都知道的结论：<strong>在这个博弈中，如果初始在二分图的所有最大匹配上，那么先手必胜，反之后手必胜。</strong></p><h3 id="为什么我是对的？"><a href="#为什么我是对的？" class="headerlink" title="为什么我是对的？"></a>为什么我是对的？</h3><p>先给出样例的拟图：</p><p><img src="https://s2.loli.net/2025/08/31/n8HRS95CoAkLhgG.png" alt="sol-LGP4055-2.png"></p><p>其中加粗的点为在任意最大匹配上的点。不妨先称为“粗点”，相对地有“细点”。</p><p>可以发现，从一个粗点出发（如 $(2,2)$），只需要任意选择一个在任意一个最大匹配上的匹配点（$(2,3)$ 或 $(3,2)$）即可。只要先手走的是最大匹配，无论后手怎么走，因为题目要求不能回头，所以一定可以继续沿着一个最大匹配走。</p><p>梳理一下这是怎么回事：只要先手在粗点，那么无论对方怎么走，永远可以再次走最大匹配。如果不可以，这就与最大匹配的“最大”矛盾了。</p><p>反之，如果在细点上，那么后手一定可以在一个粗点上出发，即后手必胜。</p><p>所以，题目所求的就转化为：<strong>求在一个二分图上，有哪些点不一定在最大匹配上。</strong></p><p>只要求出这个细点集，空（也就是说，存在完美匹配，任意点皆为粗点）即输出 <code>LOSE</code>，非空输出 <code>WIN</code> 即可。</p><h2 id="具体地怎么实现？"><a href="#具体地怎么实现？" class="headerlink" title="具体地怎么实现？"></a>具体地怎么实现？</h2><p>首先用任意可以解决二分图最大匹配问题的算法（匈牙利或 Dinic）都可以。此时我们知道，不在当前匹配的点必然是细点。</p><p>接下去，我们可以做一个 DFS。如果一个点 $P$ 已被证实是细点，设它有一边连着 $Q$，且 $Q$ 在最大匹配上，则 $Q$ 的匹配点也是细点。如样例，如果当前 $(2,2)$ 匹配 $(2,3)$，当我们从 $(3,2)$ 开始 DFS 时，就会发现 $(2,3)$ 是细点。想想看，将 $(2,2)\Rightarrow(2,3)$ 换成 $(2,2)\Rightarrow(3,2)$ 都是最大匹配。根据这样的性质，找出所有的细点即可。</p><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">101</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXPTS = <span class="hljs-number">10001</span>;<br><br><span class="hljs-type">bool</span> enable[MXPTS];<br><span class="hljs-type">int</span> n, m, pts;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x * m + y; &#125;<br><br><span class="hljs-type">int</span> head[MXPTS], to[MXPTS &lt;&lt; <span class="hljs-number">2</span>], nxt[MXPTS &lt;&lt; <span class="hljs-number">2</span>], es;  <span class="hljs-comment">// for base graph</span><br><span class="hljs-type">int</span> link[MXPTS], vis[MXPTS];                           <span class="hljs-comment">// for bi-graph</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fill</span>(head, head + pts, <span class="hljs-number">-1</span>);<br>  <span class="hljs-built_in">fill</span>(link, link + pts, <span class="hljs-number">-1</span>);<br>  <span class="hljs-built_in">fill</span>(vis, vis + pts, <span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>  to[es] = t;<br>  nxt[es] = head[f];<br>  head[f] = es++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vis[cur] == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  vis[cur] = t;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(head[cur]); ~i; i = nxt[i]) &#123;<br>    <span class="hljs-keyword">if</span> (!~link[to[i]] || <span class="hljs-built_in">ask</span>(link[to[i]], t)) &#123;<br>      link[to[i]] = cur;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makepair</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != m; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (!((i + j) &amp; <span class="hljs-number">1</span>) &amp;&amp; enable[<span class="hljs-built_in">id</span>(i, j)]) <span class="hljs-built_in">ask</span>(<span class="hljs-built_in">id</span>(i, j), <span class="hljs-built_in">id</span>(i, j));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != pts; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (~link[i]) link[link[i]] = i;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">bool</span> cango[MXPTS], ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findfake</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span> </span>&#123;<br>  ans = cango[cur] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(head[cur]); ~i; i = nxt[i]) &#123;<br>    <span class="hljs-keyword">if</span> (~link[to[i]] &amp;&amp; !cango[link[to[i]]]) <span class="hljs-built_in">findfake</span>(link[to[i]]);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  pts = n * m;<br>  <span class="hljs-built_in">init</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != pts; ++i) &#123;<br>    <span class="hljs-type">char</span> c;<br>    cin &gt;&gt; c;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>) enable[i] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != m; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (enable[<span class="hljs-built_in">id</span>(i, j)]) &#123;<br>        <span class="hljs-keyword">if</span> (i != n - <span class="hljs-number">1</span> &amp;&amp; enable[<span class="hljs-built_in">id</span>(i + <span class="hljs-number">1</span>, j)])<br>          <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">id</span>(i, j), <span class="hljs-built_in">id</span>(i + <span class="hljs-number">1</span>, j)), <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">id</span>(i + <span class="hljs-number">1</span>, j), <span class="hljs-built_in">id</span>(i, j));<br>        <span class="hljs-keyword">if</span> (j != m - <span class="hljs-number">1</span> &amp;&amp; enable[<span class="hljs-built_in">id</span>(i, j + <span class="hljs-number">1</span>)])<br>          <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">id</span>(i, j), <span class="hljs-built_in">id</span>(i, j + <span class="hljs-number">1</span>)), <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">id</span>(i, j + <span class="hljs-number">1</span>), <span class="hljs-built_in">id</span>(i, j));<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">makepair</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != pts; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (enable[i] &amp;&amp; !~link[i]) &#123;<br>      <span class="hljs-built_in">findfake</span>(i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(ans ? <span class="hljs-string">&quot;WIN&quot;</span> : <span class="hljs-string">&quot;LOSE&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != m; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (cango[<span class="hljs-built_in">id</span>(i, j)]) cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; j + <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>二分图</tag>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - CSP/NOIP 2021</title>
    <link href="/sol-2021csp-2021noip/"/>
    <url>/sol-2021csp-2021noip/</url>
    
    <content type="html"><![CDATA[<h2 id="CSP-J-2021-解题报告"><a href="#CSP-J-2021-解题报告" class="headerlink" title="CSP-J 2021 解题报告"></a>CSP-J 2021 解题报告</h2><p>当前做法得分: $100 + 100 + 100 + 100 = 400$。</p><h3 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>实际上，就是在 $[L, R]$ 的区间里面取一个数，使得它对 $n$ 取模得的余数最大。</p><p>显然，答案的最大值不超过 $n - 1$。</p><p>答案不为 $n - 1$ 时，显然，$R \bmod n \ge L \bmod n$。</p><p>所以，我们只要判断区间里面有没有向 $n$ 取余得 $n - 1$ 的数即可。</p><p>如何判定？显然，直接判断 $\lfloor \frac{L}{n} \rfloor$ 与 $\lfloor \frac{R}{n} \rfloor$ 是否相等即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">L</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">R</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;N, &amp;L, &amp;R);<br>  <span class="hljs-keyword">if</span> (R / N == L / N) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, R % N);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, N - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>注意到类型 $1$ 的操作数量较少，所以我们可以暴力修改。</p><p>首先预处理，排序。对于每一个修改，我们直接将对应的数前后移动，进行插入排序。询问时输出即可。注意，需要一个映射数组。</p><p>预处理需要 $\mathcal O(n\log{n})$，修改需要 $\mathcal O(5000n)$，询问需要 $\mathcal O(Q)$，可以通过。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Num</span> &#123;<br>  <span class="hljs-type">int</span> id, ele;<br>  <span class="hljs-built_in">Num</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span>, <span class="hljs-type">int</span> e = <span class="hljs-number">0</span>) : <span class="hljs-built_in">id</span>(i), <span class="hljs-built_in">ele</span>(e) &#123;&#125;<br>&#125;;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Num lhs, Num rhs) &#123;<br>  <span class="hljs-keyword">return</span> lhs.ele == rhs.ele ? lhs.id &lt; rhs.id : lhs.ele &lt; rhs.ele;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">M</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  cin &gt;&gt; N &gt;&gt; M;<br>  <span class="hljs-function">vector&lt;Num&gt; <span class="hljs-title">nums</span><span class="hljs-params">(N)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    nums[i].id = i;<br>    cin &gt;&gt; nums[i].ele;<br>  &#125;<br>  <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mp</span><span class="hljs-params">(N)</span></span>;  <span class="hljs-comment">// bef-&gt;now 映射数组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    mp[nums[i].id] = i;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">op</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">v</span>(<span class="hljs-number">0</span>); M--;) &#123;<br>    cin &gt;&gt; op &gt;&gt; x;<br>    --x;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>      cin &gt;&gt; v;<br>      x = mp[x];<br>      nums[x].ele = v;<br>      <span class="hljs-comment">// 暴力修改 插入排序</span><br>      <span class="hljs-keyword">while</span> (x &amp;&amp; nums[x] &lt; nums[x - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-built_in">swap</span>(mp[nums[x].id], mp[nums[x - <span class="hljs-number">1</span>].id]);<br>        <span class="hljs-built_in">swap</span>(nums[x], nums[x - <span class="hljs-number">1</span>]);<br>        --x;<br>      &#125;<br>      <span class="hljs-keyword">while</span> (x + <span class="hljs-number">1</span> &lt; N &amp;&amp; nums[x + <span class="hljs-number">1</span>] &lt; nums[x]) &#123;<br>        <span class="hljs-built_in">swap</span>(mp[nums[x + <span class="hljs-number">1</span>].id], mp[nums[x].id]);<br>        <span class="hljs-built_in">swap</span>(nums[x + <span class="hljs-number">1</span>], nums[x]);<br>        ++x;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>      cout &lt;&lt; mp[x] + <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h3><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>简易的模拟题。我们可以按照题目对合法地址串的规定，一条条实行。全题只要能判好是否合法，剩下的就是用 map 弄过去。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; ad)</span> </span>&#123;<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">nums</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">dot_cnt</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">dd_cnt</span>(<span class="hljs-number">0</span>);; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i == ad.<span class="hljs-built_in">size</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (dot_cnt != <span class="hljs-number">3</span> || dd_cnt != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">switch</span> (ad[i]) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;.&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (dd_cnt) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ++dot_cnt;<br>        nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;:&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (dot_cnt != <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ++dd_cnt;<br>        nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(ad[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        nums.<span class="hljs-built_in">back</span>() += ad[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dot_cnt &gt; <span class="hljs-number">3</span> || dd_cnt &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i].<span class="hljs-built_in">empty</span>() || (i &lt; <span class="hljs-number">4</span> &amp;&amp; nums[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span>) ||<br>        (i == <span class="hljs-number">4</span> &amp;&amp; nums[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">5</span>))<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (nums[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (string::const_iterator <span class="hljs-built_in">j</span>(nums[i].<span class="hljs-built_in">begin</span>()); j != nums[i].<span class="hljs-built_in">end</span>(); ++j)<br>      n = (n &lt;&lt; <span class="hljs-number">3</span>) + (n &lt;&lt; <span class="hljs-number">1</span>) + (*j - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span> ((i &lt; <span class="hljs-number">4</span> &amp;&amp; n &gt; <span class="hljs-number">255</span>) || (i == <span class="hljs-number">4</span> &amp;&amp; n &gt; <span class="hljs-number">65535</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  cin &gt;&gt; N;<br>  string op, ad;<br>  map&lt;string, <span class="hljs-type">int</span>&gt; dict;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    cin &gt;&gt; op &gt;&gt; ad;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isvalid</span>(ad)) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;ERR&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;Server&quot;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (dict.<span class="hljs-built_in">find</span>(ad) == dict.<span class="hljs-built_in">end</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;OK&quot;</span> &lt;&lt; endl, dict[ad] = i + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;FAIL&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;Client&quot;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (dict.<span class="hljs-built_in">find</span>(ad) == dict.<span class="hljs-built_in">end</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;FAIL&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-keyword">else</span><br>        cout &lt;&lt; dict[ad] &lt;&lt; endl;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="小熊的果篮"><a href="#小熊的果篮" class="headerlink" title="小熊的果篮"></a>小熊的果篮</h3><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>第一眼看过去，就肯定感觉跟链表有关。</p><p>我们考虑用循环队列去维护每一个块，一旦遇到相邻的两个块合并即可。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  cin &gt;&gt; N;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num</span><span class="hljs-params">(N)</span>, <span class="hljs-title">nxt</span><span class="hljs-params">(N, <span class="hljs-number">-1</span>)</span>, head, tail</span>;<br>  queue&lt;<span class="hljs-type">int</span>&gt; heads;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">cur</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    cin &gt;&gt; num[i];<br>    <span class="hljs-keyword">if</span> (!i || num[i - <span class="hljs-number">1</span>] != num[i]) &#123;<br>      heads.<span class="hljs-built_in">push</span>(head.<span class="hljs-built_in">size</span>());<br>      <span class="hljs-keyword">if</span> (i) tail.<span class="hljs-built_in">push_back</span>(i - <span class="hljs-number">1</span>);<br>      head.<span class="hljs-built_in">push_back</span>(i);<br>    &#125; <span class="hljs-keyword">else</span><br>      nxt[i - <span class="hljs-number">1</span>] = i;<br>  &#125;<br>  tail.<span class="hljs-built_in">push_back</span>(N - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">while</span> (!heads.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-type">int</span> sz = heads.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (sz--) &#123;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cur</span><span class="hljs-params">(heads.front())</span></span>;<br>      heads.<span class="hljs-built_in">pop</span>();<br>      cout &lt;&lt; head[cur] + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>      head[cur] = nxt[head[cur]];<br>      <span class="hljs-keyword">if</span> (~head[cur] &amp;&amp; heads.<span class="hljs-built_in">back</span>() &lt; cur &amp;&amp;<br>          num[head[cur]] == num[head[heads.<span class="hljs-built_in">back</span>()]]) &#123;<br>        nxt[tail[heads.<span class="hljs-built_in">back</span>()]] = head[cur];<br>        tail[heads.<span class="hljs-built_in">back</span>()] = tail[cur];<br>        head[cur] = <span class="hljs-number">-1</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (~head[cur]) &#123;<br>        heads.<span class="hljs-built_in">push</span>(cur);<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="CSP-S-2021-解题报告"><a href="#CSP-S-2021-解题报告" class="headerlink" title="CSP-S 2021 解题报告"></a>CSP-S 2021 解题报告</h2><p>当前做法得分: $100 + 100 + 100 + 100 = 400$。</p><hr><h3 id="廊桥分配"><a href="#廊桥分配" class="headerlink" title="廊桥分配"></a>廊桥分配</h3><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>首先有一个定论：无论廊桥总数多少，每架飞机对应的廊桥是唯一的。</p><p>意思就是，比如有一架飞机，当有 $5$ 架飞机时它对应第 $4$ 架，那么当只有 $4$ 个廊桥时它还对应第 $4$ 架。只有三个廊桥时，它就不能乘廊桥。</p><p>原因是，廊桥分配遵循先到先得原则。</p><p>所以，我们可以处理出来每架飞机对应的廊桥编号，用优先队列。然后投入桶里，对桶进行前缀和，就得到了廊桥数量对应的飞机数量。再枚举分配给哪边多少个，就完成了。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span> &#123;<br>  <span class="hljs-type">int</span> first, second;<br>  <span class="hljs-built_in">Pair</span>(<span class="hljs-type">int</span> fst = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> sec = <span class="hljs-number">0</span>) : <span class="hljs-built_in">first</span>(fst), <span class="hljs-built_in">second</span>(sec) &#123;&#125;<br>&#125;;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Pair a, Pair b) &#123; <span class="hljs-keyword">return</span> a.first &gt; b.first; &#125;  <span class="hljs-comment">// 优先队列的规则</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Pair a, Pair b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a.first == b.first ? a.second &lt; b.second : a.first &lt; b.first;<br>&#125;  <span class="hljs-comment">// 排序的规则</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> M, vector&lt;<span class="hljs-type">int</span>&gt;&amp; buckets)</span> </span>&#123;<br>  <span class="hljs-function">vector&lt;Pair&gt; <span class="hljs-title">vec</span><span class="hljs-params">(M)</span></span>;<br>  <span class="hljs-keyword">for</span> (vector&lt;Pair&gt;::iterator <span class="hljs-built_in">i</span>(vec.<span class="hljs-built_in">begin</span>()); i != vec.<span class="hljs-built_in">end</span>(); ++i)<br>    cin &gt;&gt; i-&gt;first &gt;&gt; i-&gt;second;<br>  <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp);<br>  <span class="hljs-comment">// 用优先队列来维护可用的廊桥与正在使用廊桥的飞机</span><br>  priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; bridges;<br>  priority_queue&lt;Pair&gt; usings;<br>  vector&lt;<span class="hljs-type">int</span>&gt; id;<br>  <span class="hljs-keyword">for</span> (vector&lt;Pair&gt;::const_iterator <span class="hljs-built_in">i</span>(vec.<span class="hljs-built_in">begin</span>()); i != vec.<span class="hljs-built_in">end</span>(); ++i) &#123;<br>    <span class="hljs-keyword">while</span> (!usings.<span class="hljs-built_in">empty</span>() &amp;&amp;<br>           usings.<span class="hljs-built_in">top</span>().first &lt;= i-&gt;first) &#123;  <span class="hljs-comment">// 用完廊桥就归还</span><br>      bridges.<span class="hljs-built_in">push</span>(usings.<span class="hljs-built_in">top</span>().second);<br>      usings.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cur</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (bridges.<span class="hljs-built_in">empty</span>())  <span class="hljs-comment">// 需要新廊桥</span><br>      cur = id.<span class="hljs-built_in">size</span>(), id.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span><br>      cur = bridges.<span class="hljs-built_in">top</span>(), bridges.<span class="hljs-built_in">pop</span>();<br>    ++id[cur];                          <span class="hljs-comment">// 放入桶里</span><br>    usings.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Pair</span>(i-&gt;second, cur));  <span class="hljs-comment">// 启用廊桥</span><br>  &#125;<br>  buckets.<span class="hljs-built_in">assign</span>(id.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != buckets.<span class="hljs-built_in">size</span>(); ++i)<br>    buckets[i] = buckets[i - <span class="hljs-number">1</span>] + id[i - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 对桶进行前缀和</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">M1</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">M2</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  cin &gt;&gt; N &gt;&gt; M1 &gt;&gt; M2;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">buckets1</span><span class="hljs-params">(M1)</span>, <span class="hljs-title">buckets2</span><span class="hljs-params">(M2)</span></span>;<br>  <span class="hljs-built_in">process</span>(M1, buckets1);<br>  <span class="hljs-built_in">process</span>(M2, buckets2);<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i &lt;= N; ++i)  <span class="hljs-comment">// 枚举</span><br>    res = <span class="hljs-built_in">max</span>(res, buckets1[<span class="hljs-built_in">min</span>(buckets<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, i)] +<br>                       buckets2[<span class="hljs-built_in">min</span>(buckets<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, N - i)]);<br>  cout &lt;&lt; res &lt;&lt; endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="括号序列"><a href="#括号序列" class="headerlink" title="括号序列"></a>括号序列</h3><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>一眼，显然是区间 DP。</p><p>我们考虑直接用 $f_{l,r}$ 表示区间内合法的序列数。</p><p>然而，我们发现，如果直接维护可能在 AB / ASB 转移中算重。</p><p>所以我们考虑维护 $f_{l,r,0/1}$。0 表示最后一次转移是加上一对括号，即左右括号配对；1 表示左右括号不配对，最后一次转移为 AB / ASB。</p><p>转移就很简单了。</p><p>规则一：直接判断即可，$O(1)$。</p><p>规则二：考虑枚举最右边的一个左右括号配对串，设为 $[j,r)$；枚举可以全为星号的串 $[i,j)$；答案就为 $(f<em>{l,i,0} + f</em>{l,i,1}) \times f_{j,r,0}$，未优化为 $O(n^2)$。</p><p>规则三：从左往右、从右往左枚举两端可能的 $S$ 串，直接判断，$O(n)$。</p><p>我们发现规则二如果不优化，时复 $O(n^4)$，荣获 65pts。</p><p>我们考虑维护双指针，同时维护 $i$、$j$，都是单调往右走，动态维护 $\sum{f_{j,r,0}}$。最后的时间复杂度是 $O(n^3)$。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DVS = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">505</span>;<br><span class="hljs-type">char</span> str[MXN];<br>uint cnt[MXN][MXN][<span class="hljs-number">2</span>], cbs[MXN][MXN];<br><span class="hljs-type">int</span> N, K;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (str[l] == <span class="hljs-string">&#x27;(&#x27;</span> || str[l] == <span class="hljs-string">&#x27;?&#x27;</span>) &amp;&amp;<br>         (str[r - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;)&#x27;</span> || str[r - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;?&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N &gt;&gt; K &gt;&gt; str;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    cbs[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;*&#x27;</span> || str[i] == <span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>      cbs[i][i + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, i - K + <span class="hljs-number">1</span>)); j != i; ++j) cbs[j][i + <span class="hljs-number">1</span>] = cbs[j][i];<br>    &#125;<br>  &#125;<br>  cbs[N][N] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i &lt; N - <span class="hljs-number">1</span>; ++i) cnt[i][i + <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">match</span>(i, i + <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">len</span>(<span class="hljs-number">3</span>); len &lt;= N; ++len) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">l</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">r</span>(len); r &lt;= N; ++l, ++r) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">match</span>(l, r)) <span class="hljs-keyword">continue</span>;<br>      cnt[l][r][<span class="hljs-number">0</span>] = (cbs[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>] +<br>                      (cnt[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + cnt[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % DVS) %<br>                     DVS;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(l + <span class="hljs-number">2</span>); i &lt; r - <span class="hljs-number">2</span> &amp;&amp; cbs[l + <span class="hljs-number">1</span>][i]; ++i)<br>        cnt[l][r][<span class="hljs-number">0</span>] =<br>            (cnt[l][r][<span class="hljs-number">0</span>] + (cnt[i][r - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + cnt[i][r - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % DVS) % DVS;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(r - <span class="hljs-number">2</span>); i &gt; l + <span class="hljs-number">2</span> &amp;&amp; cbs[i][r - <span class="hljs-number">1</span>]; --i)<br>        cnt[l][r][<span class="hljs-number">0</span>] =<br>            (cnt[l][r][<span class="hljs-number">0</span>] + (cnt[l + <span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>] + cnt[l + <span class="hljs-number">1</span>][i][<span class="hljs-number">1</span>]) % DVS) % DVS;<br>      <span class="hljs-keyword">for</span> (uint <span class="hljs-built_in">i</span>(l + <span class="hljs-number">2</span>), <span class="hljs-built_in">j</span>(i - <span class="hljs-number">1</span>), <span class="hljs-built_in">rp</span>(<span class="hljs-number">0</span>); i &lt; r - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (j &lt;= i) &#123;<br>          j = i, rp = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (cbs[i][j] &amp;&amp; j &lt; r - <span class="hljs-number">1</span>) rp = (rp + cnt[j++][r][<span class="hljs-number">0</span>]) % DVS;<br>        cnt[l][r][<span class="hljs-number">1</span>] = (cnt[l][r][<span class="hljs-number">1</span>] +<br>                        (cnt[l][i][<span class="hljs-number">0</span>] + cnt[l][i][<span class="hljs-number">1</span>]) % DVS * <span class="hljs-number">1LL</span> * rp % DVS) %<br>                       DVS;<br>        rp = (rp + DVS - cnt[i][r][<span class="hljs-number">0</span>]) % DVS;<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; (cnt[<span class="hljs-number">0</span>][N][<span class="hljs-number">0</span>] + cnt[<span class="hljs-number">0</span>][N][<span class="hljs-number">1</span>]) % DVS &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h3><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>我们只要手动模拟如何取第一个数，就会发现：它是四指针！</p><p>我们用逆向思维，外层指针的运动对应的必然是内层指针也要运动，以满足回文属性。</p><p>所以我们每次贪心：如果我们第 $k$ 个选 $x$，倒数第 $k$ 个能不能也选 $x$？优先考虑当前选 <code>L</code>，然后在内层两指针尝试匹配，然后考虑 <code>R</code>，都不行就输出 <code>-1</code>。</p><p>因为一个数至多出现 $2$ 次，所以这个贪心是必然最优、不会影响到后续动作的。</p><p>这题就做完了。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">c</span><span class="hljs-params">(getchar())</span></span>;<br>  <span class="hljs-keyword">while</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">while</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>    x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">1000005</span>;<br><span class="hljs-type">int</span> arr[MXN], T, N;<br><span class="hljs-type">char</span> str[MXN];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">able</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">n</span>(N - <span class="hljs-number">2</span>); i &lt; n; ++i, --n) &#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b &amp;&amp; arr[a] == arr[b]) &#123;<br>      str[i] = <span class="hljs-string">&#x27;L&#x27;</span>, str[n] = <span class="hljs-string">&#x27;L&#x27;</span>, ++a, --b;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &lt;= b &amp;&amp; c &lt;= d &amp;&amp; arr[a] == arr[c]) &#123;<br>      str[i] = <span class="hljs-string">&#x27;L&#x27;</span>, str[n] = <span class="hljs-string">&#x27;R&#x27;</span>, ++a, ++c;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &lt;= b &amp;&amp; c &lt;= d &amp;&amp; arr[b] == arr[d]) &#123;<br>      str[i] = <span class="hljs-string">&#x27;R&#x27;</span>, str[n] = <span class="hljs-string">&#x27;L&#x27;</span>, --b, --d;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &lt; d &amp;&amp; arr[c] == arr[d]) &#123;<br>      str[i] = <span class="hljs-string">&#x27;R&#x27;</span>, str[n] = <span class="hljs-string">&#x27;R&#x27;</span>, ++c, --d;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) <span class="hljs-built_in">putchar</span>(str[i]);<br>  <span class="hljs-built_in">putchar</span>(<span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  T = <span class="hljs-built_in">read</span>();<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    N = <span class="hljs-built_in">read</span>() &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) arr[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">m</span><span class="hljs-params">(find(arr + <span class="hljs-number">1</span>, arr + N, arr[<span class="hljs-number">0</span>]) - arr)</span></span>;<br>    str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;L&#x27;</span>, str[N - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;L&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">able</span>(<span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, N - <span class="hljs-number">1</span>)) &#123;<br>      <span class="hljs-built_in">print</span>();<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    m = <span class="hljs-built_in">find</span>(arr, arr + N - <span class="hljs-number">1</span>, arr[N - <span class="hljs-number">1</span>]) - arr;<br>    str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;R&#x27;</span>, str[N - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;L&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">able</span>(<span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, N - <span class="hljs-number">2</span>)) &#123;<br>      <span class="hljs-built_in">print</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;1&#x27;</span>), <span class="hljs-built_in">putchar</span>(<span class="hljs-number">10</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="交通规划"><a href="#交通规划" class="headerlink" title="交通规划"></a>交通规划</h3><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>首先从 $k=2$ 的部分分发现它想要找的是一组比较像割的东西。我们知道割一般用流做，这里 $k&gt;2$ 应该是不好做，所以转平面图最短路。</p><p>然后发现要达成相邻不同颜色的附加点之间的无界面之间做两两匹配即可。进一步，我们发现它可以在环上形成括号序列状物，因为交叉一定可以变成包含。所以断环为链做区间 DP。</p><p>时间复杂度 $O(\sum knm+k^3)$，空间复杂度 $O(nm+k^2)$。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">505</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXK = <span class="hljs-number">55</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXV = <span class="hljs-number">250105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXE = MXV * <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> N, M, B, T, K, bdp[<span class="hljs-number">4</span> * MXN], bde[<span class="hljs-number">4</span> * MXN];<br><span class="hljs-type">int</span> dist[MXV], cst[MXK][MXK], ans, res[MXK * <span class="hljs-number">2</span>][MXK * <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> head[MXV], to[MXE], len[MXE], nxt[MXE], egsz;<br>tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pts[MXK];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(getchar())</span></span>;<br>  <span class="hljs-keyword">while</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">while</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = x * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>), c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">14</span>];<br>  <span class="hljs-keyword">if</span> (!x) &#123;<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">while</span> (x) buf[d++] = x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>, x /= <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">while</span> (d) <span class="hljs-built_in">putchar</span>(buf[--d]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">pt</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x * (M - <span class="hljs-number">1</span>) + y; &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>  to[egsz] = y, len[egsz] = w, nxt[egsz] = head[x], head[x] = egsz++;<br>  to[egsz] = x, len[egsz] = w, nxt[egsz] = head[y], head[y] = egsz++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">remedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  egsz -= <span class="hljs-number">2</span>;<br>  head[x] = nxt[head[x]], head[y] = nxt[head[y]];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">useless</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(pts[p]) == <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(pts[(p + <span class="hljs-number">1</span>) % K]); &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">get_bdid</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">2</span> * M + N) --x;<br>  <span class="hljs-keyword">if</span> (x &gt;= M + N) --x;<br>  <span class="hljs-keyword">if</span> (x &gt;= M) --x;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">setbd</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> e)</span> </span>&#123; bdp[id] = p, bde[id] = e; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calsp</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != B + K; ++i) dist[i] = INF;<br>  priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; pq;<br>  pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist[S] = <span class="hljs-number">0</span>, S));<br>  <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">d</span><span class="hljs-params">(-pq.top().first)</span>, <span class="hljs-title">c</span><span class="hljs-params">(pq.top().second)</span></span>;<br>    pq.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (dist[c] != d) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(head[c]); ~i; i = nxt[i]) &#123;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(to[i])</span>, <span class="hljs-title">l</span><span class="hljs-params">(len[i])</span></span>;<br>      <span class="hljs-keyword">if</span> (dist[n] &gt; d + l)<br>        dist[n] = d + l, pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(-dist[n], n));<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> head);<br>  N = <span class="hljs-built_in">read</span>(), M = <span class="hljs-built_in">read</span>(), T = <span class="hljs-built_in">read</span>(), B = (N - <span class="hljs-number">1</span>) * (M - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>); i != N - <span class="hljs-number">1</span>; ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != M; ++j) &#123;<br>      x = <span class="hljs-built_in">read</span>();<br>      <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) <span class="hljs-built_in">setbd</span>(<span class="hljs-number">2</span> * M + <span class="hljs-number">2</span> * N - <span class="hljs-number">5</span> - i, <span class="hljs-built_in">pt</span>(i, j), x);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != M - <span class="hljs-number">1</span>) <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">pt</span>(i, j), <span class="hljs-built_in">pt</span>(i, j - <span class="hljs-number">1</span>), x);<br>      <span class="hljs-keyword">else</span> <span class="hljs-built_in">setbd</span>(M - <span class="hljs-number">1</span> + i, <span class="hljs-built_in">pt</span>(i, j - <span class="hljs-number">1</span>), x);<br>    &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>); i != N; ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != M - <span class="hljs-number">1</span>; ++j) &#123;<br>      x = <span class="hljs-built_in">read</span>();<br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-built_in">setbd</span>(j, <span class="hljs-built_in">pt</span>(i, j), x);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != N - <span class="hljs-number">1</span>) <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">pt</span>(i, j), <span class="hljs-built_in">pt</span>(i - <span class="hljs-number">1</span>, j), x);<br>      <span class="hljs-keyword">else</span> <span class="hljs-built_in">setbd</span>(<span class="hljs-number">2</span> * M + N - <span class="hljs-number">4</span> - j, <span class="hljs-built_in">pt</span>(i - <span class="hljs-number">1</span>, j), x);<br>    &#125;<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    K = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">p</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">t</span>(<span class="hljs-number">0</span>); i != K; ++i)<br>      x = <span class="hljs-built_in">read</span>(), p = <span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>, t = <span class="hljs-built_in">read</span>(), pts[i] = <span class="hljs-built_in">make_tuple</span>(p, x, t);<br>    <span class="hljs-built_in">sort</span>(pts, pts + K);<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">no_use</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != K; ++i)<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">useless</span>(i)) no_use = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (no_use) &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != K; ++i) &#123;<br>      <span class="hljs-built_in">addedge</span>(B + (i + K - <span class="hljs-number">1</span>) % K, B + i, <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(pts[i]));<br>      pts[i] =<br>        <span class="hljs-built_in">make_tuple</span>(<span class="hljs-built_in">get_bdid</span>(<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(pts[i])), <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(pts[i]), <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(pts[i]));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">it</span>(<span class="hljs-number">0</span>); i != <span class="hljs-number">2</span> * M + <span class="hljs-number">2</span> * N - <span class="hljs-number">4</span>; ++i) &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(pts[it]) == i) it = (it + <span class="hljs-number">1</span>) % K;<br>      <span class="hljs-built_in">addedge</span>(bdp[i], B + (it + K - <span class="hljs-number">1</span>) % K, bde[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != K; ++i) &#123;<br>      <span class="hljs-built_in">calsp</span>(B + i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != K; ++j) cst[i][j] = dist[B + j];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i &lt;= <span class="hljs-number">2</span> * K; ++i) res[i][i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != <span class="hljs-number">2</span> * K; ++i) res[i][i + <span class="hljs-number">1</span>] = (<span class="hljs-built_in">useless</span>(i % K) ? <span class="hljs-number">0</span> : INF);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">len</span>(<span class="hljs-number">2</span>); len &lt;= K; ++len) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i + len &lt;= <span class="hljs-number">2</span> * K; ++i) &#123;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">r</span><span class="hljs-params">(i + len)</span></span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">useless</span>(i % K) || <span class="hljs-built_in">useless</span>((r - <span class="hljs-number">1</span>) % K)) &#123;<br>          <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">a</span><span class="hljs-params">(i)</span>, <span class="hljs-title">b</span><span class="hljs-params">(r)</span></span>;<br>          <span class="hljs-keyword">while</span> (a &lt; b &amp;&amp; <span class="hljs-built_in">useless</span>(a % K)) ++a;<br>          <span class="hljs-keyword">while</span> (b &gt; a &amp;&amp; <span class="hljs-built_in">useless</span>((b - <span class="hljs-number">1</span>) % K)) --b;<br>          res[i][r] = res[a][b];<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        res[i][r] = <span class="hljs-built_in">min</span>(INF, res[i + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>] + cst[i % K][(r - <span class="hljs-number">1</span>) % K]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(i + <span class="hljs-number">1</span>); j &lt; r; ++j)<br>          res[i][r] = <span class="hljs-built_in">min</span>(res[i][r], res[i][j] + res[j][r]);<br>      &#125;<br>    &#125;<br>    ans = INF;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != K; ++i) ans = <span class="hljs-built_in">min</span>(ans, res[i][i + K]);<br>    <span class="hljs-built_in">write</span>(ans), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != K; ++i)<br>      <span class="hljs-built_in">remedge</span>(B + (i + K - <span class="hljs-number">1</span>) % K, B + i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">it</span>(<span class="hljs-number">0</span>); i != <span class="hljs-number">2</span> * M + <span class="hljs-number">2</span> * N - <span class="hljs-number">4</span>; ++i) &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(pts[it]) == i) it = (it + <span class="hljs-number">1</span>) % K;<br>      <span class="hljs-built_in">remedge</span>(bdp[i], B + (it + K - <span class="hljs-number">1</span>) % K);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="NOIP-2021-解题报告"><a href="#NOIP-2021-解题报告" class="headerlink" title="NOIP 2021 解题报告"></a>NOIP 2021 解题报告</h2><p>当前做法得分: $100 + 100 + 100 + 32 = 332$。</p><hr><h3 id="报数"><a href="#报数" class="headerlink" title="报数"></a>报数</h3><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>一眼看，不能报某些数的倍数……</p><p>$1 \le x \le 10^7$……</p><p>筛它！</p><p>这题就做完了。</p><p>注意边界为 $10^7 + 1$，不然对于极限数会炸开。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">1e7</span> + <span class="hljs-number">2</span>;<br><span class="hljs-type">bool</span> invalid[SIZE];<br><span class="hljs-type">int</span> nxt[SIZE];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">has7</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (; x; x /= <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">10</span> == <span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">bef</span>(<span class="hljs-number">0</span>); i != SIZE; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (!invalid[i] &amp;&amp; <span class="hljs-built_in">has7</span>(i)) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">1</span>); i * j &lt; SIZE; ++j) &#123;<br>        invalid[i * j] = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(SIZE - <span class="hljs-number">2</span>), <span class="hljs-built_in">bef</span>(SIZE - <span class="hljs-number">1</span>); i; --i) &#123;<br>    <span class="hljs-keyword">if</span> (invalid[i])<br>      nxt[i] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>      nxt[i] = bef, bef = i;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>); T--;) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, nxt[x]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h3><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>直接从小往大 DP 即可，模拟比较高几位的具体状态，具体见代码，复杂度 $O(mn^4)$。思路还挺绕。</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DVS = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXN = <span class="hljs-number">35</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MXM = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> comb[MXN][MXN], cnt[MXM][MXN][MXN][MXN], pw[MXN];<br><span class="hljs-type">int</span> N, M, K, ans;<br><br><span class="hljs-comment">// i digits;</span><br><span class="hljs-comment">// chose j;</span><br><span class="hljs-comment">// add k i;</span><br><span class="hljs-comment">// before, there are l 1s;</span><br><span class="hljs-comment">// from now on, the status is s;</span><br><span class="hljs-comment">// f[i][j][l][s] * C(N - j, k) -&gt; f[i + 1][j + k][l + (s + k) &amp; 1][(s + k) &gt;&gt; 1]</span><br><span class="hljs-comment">// f[m][n][?][?]</span><br><span class="hljs-comment">// mnnkk</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;<br>  comb[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i &lt;= N; ++i) &#123;<br>    comb[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">1</span>); j &lt;= i; ++j)<br>      comb[i][j] = (comb[i - <span class="hljs-number">1</span>][j] + comb[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % DVS;<br>  &#125;<br>  cnt[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">v</span>(<span class="hljs-number">0</span>); i &lt;= M; ++i) &#123;<br>    cin &gt;&gt; v;<br>    pw[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">1</span>); j &lt;= N; ++j) pw[j] = pw[j - <span class="hljs-number">1</span>] * <span class="hljs-number">1LL</span> * v % DVS;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j &lt;= N; ++j)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">0</span>); j + k &lt;= N; ++k)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">l</span>(<span class="hljs-number">0</span>); l &lt;= K; ++l)<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">s</span>(<span class="hljs-number">0</span>); s &lt;= N; ++s)<br>            (cnt[i + <span class="hljs-number">1</span>][j + k][l + ((s + k) &amp; <span class="hljs-number">1</span>)][(s + k) &gt;&gt; <span class="hljs-number">1</span>]<br>             += cnt[i][j][l][s] * <span class="hljs-number">1LL</span> * pw[k] % DVS * comb[N - j][k] % DVS) %= DVS;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">pp</span>(<span class="hljs-number">0</span>); j &lt;= N; ++j) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cp</span><span class="hljs-params">(j)</span></span>;<br>    pp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cp) pp += cp &amp; <span class="hljs-number">1</span>, cp &gt;&gt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i + pp &lt;= K; ++i)<br>      (ans += cnt[M + <span class="hljs-number">1</span>][N][i][j]) %= DVS;<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>什么比赛有 2 道神奇 DP 呢。</p><p>观察操作，其实是交换差分。结论是：差分呈单谷时最优（我就不会证了，感觉上比较有道理吧）。</p><p>推式子。</p><script type="math/tex; mode=display">\begin{aligned} &\frac{1}{n} \sum_{i = 1}^{n} {(a_i - \bar a)}^2 \\=& \frac{1}{n} \sum_{i = 1}^{n} (a_i - \frac{1}{n} \sum_{i = 1}^{n} a_i)^2 \\=& \frac{1}{n} \sum_{i = 1}^{n} {(a_i^2 - 2 \times a_i \times \frac{1}{n} \sum_{i = 1}^{n} a_i + \frac{1}{n^2}(\sum_{i = 1}^{n} a_i)^2)} \\=& (\frac{1}{n} \sum_{i = 1}^{n} a_i^2) - 2(\frac{1}{n^2} \sum_{i = 1}^{n} (a_i \sum_{j = 1}^{n} a_j)) + (\frac{1}{n^2} \sum_{i = 1}^{n} a_i)^2 \\=& \frac{1}{n}(\sum_{i = 1}^{n} a_i^2) - \frac{1}{n^2}(\sum_{i = 1}^{n} a_i)^2\end{aligned}</script><p>乘上 $n^2$，就变成了 $n(\sum<em>{i = 1}^{n} a_i^2) - (\sum</em>{i = 1}^{n} a_i)^2$。</p><p>感觉 $\sum<em>{i = 1}^{n} a_i$ 比较容易拿捏，那就把状态的一维设为它，另一维表示已经往前后插了前几个差分，值为最小的 $\sum</em>{i = 1}^{n} a_i^2$。这样直接做，是 $O(n^2a)$。</p><p>最后一档分 $a$ 很小，告诉我们非 $0$ 的差分很少，$0$ 差分我们就不做了，那就只会做 $a$ 轮，复杂度 $O(na^2)$。</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  cin &gt;&gt; N;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dif</span><span class="hljs-params">(N)</span>, <span class="hljs-title">sum</span><span class="hljs-params">(N)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) cin &gt;&gt; dif[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(N - <span class="hljs-number">1</span>); i; --i) dif[i] -= dif[i - <span class="hljs-number">1</span>];<br>  <span class="hljs-built_in">sort</span>(dif.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, dif.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != N; ++i) sum[i] = sum[i - <span class="hljs-number">1</span>] + dif[i];<br>  <span class="hljs-type">int</span> S = N * sum[N - <span class="hljs-number">1</span>], <span class="hljs-built_in">mn</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">mx</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cur</span><span class="hljs-params">(S + <span class="hljs-number">1</span>, INF)</span>, <span class="hljs-title">nxt</span><span class="hljs-params">(S + <span class="hljs-number">1</span>, INF)</span></span>;<br>  cur[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>); i != N; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (!dif[i]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j &lt;= S; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (cur[j] == INF) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (j + sum[i] &lt;= S) &#123;<br>        nxt[j + sum[i]]<br>            = <span class="hljs-built_in">min</span>(nxt[j + sum[i]], cur[j] + sum[i] * sum[i]);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (j + i * dif[i] &lt;= S) &#123;<br>        nxt[j + i * dif[i]]<br>            = <span class="hljs-built_in">min</span>(nxt[j + i * dif[i]],<br>                cur[j] + <span class="hljs-number">2</span> * dif[i] * j + i * dif[i] * dif[i]);<br>      &#125;<br>    &#125;<br>    cur.<span class="hljs-built_in">swap</span>(nxt);<br>    nxt.<span class="hljs-built_in">assign</span>(S + <span class="hljs-number">1</span>, INF);<br>  &#125;<br>  ll ans = INT64_MAX;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i &lt;= S; ++i)<br>      ans = <span class="hljs-built_in">min</span>(ans, N * <span class="hljs-number">1LL</span> * cur[i] - i * <span class="hljs-number">1LL</span> * i);<br>  cout &lt;&lt; ans &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="棋局"><a href="#棋局" class="headerlink" title="棋局"></a>棋局</h3><h4 id="分析-32pts"><a href="#分析-32pts" class="headerlink" title="分析 - 32pts"></a>分析 - 32pts</h4><p>模拟！！！根据各条道路的类型，在 bfs 的框架上乱搞就可以了。</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DIRs = <span class="hljs-number">4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Xs[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Ys[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-string">&#x27; &#x27;</span>)</span></span>;<br>  x = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isspace</span>(c)) &#123;<br>    c = <span class="hljs-built_in">getchar</span>();<br>  &#125;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>    x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + (c - <span class="hljs-number">48</span>);<br>    c = <span class="hljs-built_in">getchar</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span>&amp; c)</span> </span>&#123;<br>  c = <span class="hljs-string">&#x27; &#x27;</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isspace</span>(c)) &#123;<br>    c = <span class="hljs-built_in">getchar</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-built_in">putchar</span>(x + <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">print</span>(x / <span class="hljs-number">10</span>);<br>  <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-number">48</span>);<br>&#125;<br><br><span class="hljs-keyword">namespace</span> Task01 &#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; he, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; sh)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;::const_iterator <span class="hljs-built_in">i</span>(he.<span class="hljs-built_in">begin</span>()); i != he.<span class="hljs-built_in">end</span>();<br>       ++i) &#123;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">char</span>&gt;::const_iterator <span class="hljs-built_in">j</span>(i-&gt;<span class="hljs-built_in">begin</span>()); j != i-&gt;<span class="hljs-built_in">end</span>(); ++j) &#123;<br>      <span class="hljs-keyword">if</span> (*j == <span class="hljs-string">&#x27;2&#x27;</span> || *j == <span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;::const_iterator <span class="hljs-built_in">i</span>(sh.<span class="hljs-built_in">begin</span>()); i != sh.<span class="hljs-built_in">end</span>();<br>       ++i) &#123;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">char</span>&gt;::const_iterator <span class="hljs-built_in">j</span>(i-&gt;<span class="hljs-built_in">begin</span>()); j != i-&gt;<span class="hljs-built_in">end</span>(); ++j) &#123;<br>      <span class="hljs-keyword">if</span> (*j == <span class="hljs-string">&#x27;2&#x27;</span> || *j == <span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> Q, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; he,</span></span><br><span class="hljs-params"><span class="hljs-function">         vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; sh)</span> </span>&#123;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">color</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">-1</span>)),<br>      <span class="hljs-built_in">level</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">-1</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">col</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">lv</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); Q--;) &#123;<br>    <span class="hljs-built_in">read</span>(col), <span class="hljs-built_in">read</span>(lv), <span class="hljs-built_in">read</span>(x), <span class="hljs-built_in">read</span>(y);<br>    --x, --y;<br>    color[x][y] = col, level[x][y] = lv;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (x &amp;&amp; sh[x - <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp;<br>        (color[x - <span class="hljs-number">1</span>][y] != col &amp;&amp; level[x - <span class="hljs-number">1</span>][y] &lt;= lv)) &#123;<br>      ++ans;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (y &amp;&amp; he[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp;<br>        (color[x][y - <span class="hljs-number">1</span>] != col &amp;&amp; level[x][y - <span class="hljs-number">1</span>] &lt;= lv)) &#123;<br>      ++ans;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x != N - <span class="hljs-number">1</span> &amp;&amp; sh[x][y] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp;<br>        (color[x + <span class="hljs-number">1</span>][y] != col &amp;&amp; level[x + <span class="hljs-number">1</span>][y] &lt;= lv)) &#123;<br>      ++ans;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (y != M - <span class="hljs-number">1</span> &amp;&amp; he[x][y] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp;<br>        (color[x][y + <span class="hljs-number">1</span>] != col &amp;&amp; level[x][y + <span class="hljs-number">1</span>] &lt;= lv)) &#123;<br>      ++ans;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(ans);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;  <span class="hljs-comment">// namespace Task01</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-built_in">read</span>(T);<br>  <span class="hljs-keyword">while</span> (T--) &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">M</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">Q</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">read</span>(N), <span class="hljs-built_in">read</span>(M), <span class="hljs-built_in">read</span>(Q);<br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt; <span class="hljs-built_in">he</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(M - <span class="hljs-number">1</span>)),<br>        <span class="hljs-built_in">sh</span>(N - <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(M));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != M - <span class="hljs-number">1</span>; ++j) &#123;<br>        <span class="hljs-built_in">read</span>(he[i][j]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N - <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != M; ++j) &#123;<br>        <span class="hljs-built_in">read</span>(sh[i][j]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Task01::<span class="hljs-built_in">check</span>(he, sh)) &#123;<br>      Task01::<span class="hljs-built_in">main</span>(N, M, Q, he, sh);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">color</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">-1</span>)),<br>        <span class="hljs-built_in">level</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">-1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">col</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">lv</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>); Q--;) &#123;<br>      <span class="hljs-built_in">read</span>(col), <span class="hljs-built_in">read</span>(lv), <span class="hljs-built_in">read</span>(x), <span class="hljs-built_in">read</span>(y);<br>      --x, --y;<br>      color[x][y] = col, level[x][y] = lv;<br>      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>      vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; <span class="hljs-built_in">vis</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(M));<br>      queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q;<br>      q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(x, y));<br>      vis[x][y] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">cur</span><span class="hljs-params">(q.front())</span></span>;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> nx = cur.first, ny = cur.second;<br>        <span class="hljs-keyword">if</span> (nx &amp;&amp; sh[nx - <span class="hljs-number">1</span>][ny] == <span class="hljs-string">&#x27;3&#x27;</span> &amp;&amp; !vis[nx - <span class="hljs-number">1</span>][ny]) &#123;<br>          vis[nx - <span class="hljs-number">1</span>][ny] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">if</span> (~color[nx - <span class="hljs-number">1</span>][ny] || ~level[nx - <span class="hljs-number">1</span>][ny]) &#123;<br>            ans += color[nx - <span class="hljs-number">1</span>][ny] != col &amp;&amp; level[nx - <span class="hljs-number">1</span>][ny] &lt;= lv;<br>          &#125; <span class="hljs-keyword">else</span><br>            ++ans, q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(nx - <span class="hljs-number">1</span>, ny));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ny &amp;&amp; he[nx][ny - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;3&#x27;</span> &amp;&amp; !vis[nx][ny - <span class="hljs-number">1</span>]) &#123;<br>          vis[nx][ny - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">if</span> (~color[nx][ny - <span class="hljs-number">1</span>] || ~level[nx][ny - <span class="hljs-number">1</span>]) &#123;<br>            ans += color[nx][ny - <span class="hljs-number">1</span>] != col &amp;&amp; level[nx][ny - <span class="hljs-number">1</span>] &lt;= lv;<br>          &#125; <span class="hljs-keyword">else</span><br>            ++ans, q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(nx, ny - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nx != N - <span class="hljs-number">1</span> &amp;&amp; sh[nx][ny] == <span class="hljs-string">&#x27;3&#x27;</span> &amp;&amp; !vis[nx + <span class="hljs-number">1</span>][ny]) &#123;<br>          vis[nx + <span class="hljs-number">1</span>][ny] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">if</span> (~color[nx + <span class="hljs-number">1</span>][ny] || ~level[nx + <span class="hljs-number">1</span>][ny]) &#123;<br>            ans += color[nx + <span class="hljs-number">1</span>][ny] != col &amp;&amp; level[nx + <span class="hljs-number">1</span>][ny] &lt;= lv;<br>          &#125; <span class="hljs-keyword">else</span><br>            ++ans, q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(nx + <span class="hljs-number">1</span>, ny));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ny != M - <span class="hljs-number">1</span> &amp;&amp; he[nx][ny] == <span class="hljs-string">&#x27;3&#x27;</span> &amp;&amp; !vis[nx][ny + <span class="hljs-number">1</span>]) &#123;<br>          vis[nx][ny + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">if</span> (~color[nx][ny + <span class="hljs-number">1</span>] || ~level[nx][ny + <span class="hljs-number">1</span>]) &#123;<br>            ans += color[nx][ny + <span class="hljs-number">1</span>] != col &amp;&amp; level[nx][ny + <span class="hljs-number">1</span>] &lt;= lv;<br>          &#125; <span class="hljs-keyword">else</span><br>            ++ans, q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(nx, ny + <span class="hljs-number">1</span>));<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (x &amp;&amp; sh[x - <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !vis[x - <span class="hljs-number">1</span>][y]) &#123;<br>        <span class="hljs-keyword">if</span> (color[x - <span class="hljs-number">1</span>][y] != col &amp;&amp; level[x - <span class="hljs-number">1</span>][y] &lt;= lv) ++ans;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &amp;&amp; sh[x - <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;2&#x27;</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">nx</span>(x), <span class="hljs-built_in">ny</span>(y); nx &amp;&amp; sh[nx - <span class="hljs-number">1</span>][ny] == <span class="hljs-string">&#x27;2&#x27;</span>; --nx) &#123;<br>          <span class="hljs-keyword">if</span> (~color[nx - <span class="hljs-number">1</span>][ny] || ~level[nx - <span class="hljs-number">1</span>][ny]) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[nx - <span class="hljs-number">1</span>][ny])<br>              ans += color[nx - <span class="hljs-number">1</span>][ny] != col &amp;&amp; level[nx - <span class="hljs-number">1</span>][ny] &lt;= lv;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!vis[nx - <span class="hljs-number">1</span>][ny]) ++ans;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (y &amp;&amp; he[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !vis[x][y - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">if</span> (color[x][y - <span class="hljs-number">1</span>] != col &amp;&amp; level[x][y - <span class="hljs-number">1</span>] &lt;= lv) ++ans;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y &amp;&amp; he[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;2&#x27;</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">nx</span>(x), <span class="hljs-built_in">ny</span>(y); ny &amp;&amp; he[nx][ny - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;2&#x27;</span>; --ny) &#123;<br>          <span class="hljs-keyword">if</span> (~color[nx][ny - <span class="hljs-number">1</span>] || ~level[nx][ny - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[nx][ny - <span class="hljs-number">1</span>])<br>              ans += color[nx][ny - <span class="hljs-number">1</span>] != col &amp;&amp; level[nx][ny - <span class="hljs-number">1</span>] &lt;= lv;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!vis[nx][ny - <span class="hljs-number">1</span>]) ++ans;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (x != N - <span class="hljs-number">1</span> &amp;&amp; sh[x][y] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !vis[x + <span class="hljs-number">1</span>][y]) &#123;<br>        <span class="hljs-keyword">if</span> (color[x + <span class="hljs-number">1</span>][y] != col &amp;&amp; level[x + <span class="hljs-number">1</span>][y] &lt;= lv) ++ans;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x != N - <span class="hljs-number">1</span> &amp;&amp; sh[x][y] == <span class="hljs-string">&#x27;2&#x27;</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">nx</span>(x), <span class="hljs-built_in">ny</span>(y); nx != N - <span class="hljs-number">1</span> &amp;&amp; sh[nx][ny] == <span class="hljs-string">&#x27;2&#x27;</span>; ++nx) &#123;<br>          <span class="hljs-keyword">if</span> (~color[nx + <span class="hljs-number">1</span>][ny] || ~level[nx + <span class="hljs-number">1</span>][ny]) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[nx + <span class="hljs-number">1</span>][ny])<br>              ans += color[nx + <span class="hljs-number">1</span>][ny] != col &amp;&amp; level[nx + <span class="hljs-number">1</span>][ny] &lt;= lv;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!vis[nx + <span class="hljs-number">1</span>][ny]) ++ans;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (y != M - <span class="hljs-number">1</span> &amp;&amp; he[x][y] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !vis[x][y + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">if</span> (color[x][y + <span class="hljs-number">1</span>] != col &amp;&amp; level[x][y + <span class="hljs-number">1</span>] &lt;= lv) ++ans;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y != M - <span class="hljs-number">1</span> &amp;&amp; he[x][y] == <span class="hljs-string">&#x27;2&#x27;</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">nx</span>(x), <span class="hljs-built_in">ny</span>(y); ny != M - <span class="hljs-number">1</span> &amp;&amp; he[nx][ny] == <span class="hljs-string">&#x27;2&#x27;</span>; ++ny) &#123;<br>          <span class="hljs-keyword">if</span> (~color[nx][ny + <span class="hljs-number">1</span>] || ~level[nx][ny + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[nx][ny + <span class="hljs-number">1</span>])<br>              ans += color[nx][ny + <span class="hljs-number">1</span>] != col &amp;&amp; level[nx][ny + <span class="hljs-number">1</span>] &lt;= lv;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!vis[nx][ny + <span class="hljs-number">1</span>]) ++ans;<br>        &#125;<br>      &#125;<br>      <span class="hljs-built_in">print</span>(ans);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记 - 树链剖分-轻重链剖分</title>
    <link href="/note-hld/"/>
    <url>/note-hld/</url>
    
    <content type="html"><![CDATA[<p>树链剖分，是<del>强行增加码量至 100+ 行的东西</del>将一棵树拆分为若干条链，套用数据结构，以便于维护路径与子树信息的一种转换。</p><h2 id="例题-P3384-【模板】轻重链剖分-树链剖分"><a href="#例题-P3384-【模板】轻重链剖分-树链剖分" class="headerlink" title="例题 P3384 【模板】轻重链剖分/树链剖分"></a>例题 P3384 【模板】轻重链剖分/树链剖分</h2><p>如题，已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：</p><ul><li><code>1 x y z</code>，表示将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。</li><li><code>2 x y</code>，表示求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。</li><li><code>3 x z</code>，表示将以 $x$ 为根节点的子树内所有节点值都加上 $z$。</li><li><code>4 x</code> 表示求以 $x$ 为根节点的子树内所有节点值之和。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们先考虑前两问。</p><p>如果这是在一个序列上，那么这就是线段树/树状数组模板题。</p><p>可惜不是。</p><p>那可不可以把它摊成一个区间再处理？</p><p>它毕竟是树，这做不到。</p><p>如果多个区间呢？能不能把一条路径拆成多个区间，也就是……链？</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>重儿子：对于树上一个非叶子结点，它的儿子中所在子树最大的儿子即为其重儿子。</li><li>轻儿子：对于树上一个非叶子结点，它的儿子中不是重儿子的都是轻儿子。</li><li>重边：对于树上一个非叶子结点，它连向重儿子的边为重边。</li><li>轻边：对于树上一个非叶子结点，它连向轻儿子的边为轻边。</li><li>重链：由重边连接而成的链为重链。</li></ul><p>例如：</p><p><img src="https://s2.loli.net/2025/08/31/aVEOMsoejKPbNyx.png" alt="note-hld-1.png"></p><p>如果这样子定义，是不是就可以保证全树被剖分为若干条重链了呢？</p><p>我们来确定几个性质。</p><h3 id="性质分析"><a href="#性质分析" class="headerlink" title="性质分析"></a>性质分析</h3><h4 id="1-每个点在且仅在一条重链上"><a href="#1-每个点在且仅在一条重链上" class="headerlink" title="1. 每个点在且仅在一条重链上"></a>1. 每个点在且仅在一条重链上</h4><p>对于一个重儿子，它自然是父亲传下来的重边的接续；对于一个轻儿子/根，它所在的链头就是自己。</p><p>因为一个非叶子结点只有一个重儿子，一条重链不可能分叉。</p><h4 id="2-每条链从上往下深度递增，以叶子结点结束"><a href="#2-每条链从上往下深度递增，以叶子结点结束" class="headerlink" title="2. 每条链从上往下深度递增，以叶子结点结束"></a>2. 每条链从上往下深度递增，以叶子结点结束</h4><p>这个也很好理解，毕竟重链是父传子的，直到传不下去为止。</p><h4 id="3-从上往下遍历，每经过一条轻边，余下的子树大小至少减少一半"><a href="#3-从上往下遍历，每经过一条轻边，余下的子树大小至少减少一半" class="headerlink" title="3. 从上往下遍历，每经过一条轻边，余下的子树大小至少减少一半"></a>3. 从上往下遍历，每经过一条轻边，余下的子树大小至少减少一半</h4><p>因为这个儿子有个兄弟，兄弟的子树不比自己小。显然，这样跳也就至少能减少一半。</p><p>换言之，在一棵大小为 $n$ 的树上，对于一条从上往下深度依次递增的路径，<strong>其至多经过 $O(\log n)$ 条重链</strong>。</p><h4 id="4-对于树的-DFS-序列，如果向下拓展时先走重儿子，则每条重链的映射（即-textrm-dfn-）是连续的。每颗子树的映射也是连续的"><a href="#4-对于树的-DFS-序列，如果向下拓展时先走重儿子，则每条重链的映射（即-textrm-dfn-）是连续的。每颗子树的映射也是连续的" class="headerlink" title="4. 对于树的 DFS 序列，如果向下拓展时先走重儿子，则每条重链的映射（即 $\textrm{dfn}$）是连续的。每颗子树的映射也是连续的"></a>4. 对于树的 DFS 序列，如果向下拓展时先走重儿子，则每条重链的映射（即 $\textrm{dfn}$）是连续的。每颗子树的映射也是连续的</h4><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>在树链剖分中，我们要维护 $7$ 个数组（虽然许多时候只要 $6$ 个）：</p><ul><li>$\textrm{fa}_x$：每个节点的父亲。</li><li>$\textrm{son}_x$：每个节点的<strong>重</strong>儿子。</li><li>$\textrm{depth}_x$：每个节点的深度。</li><li>$\textrm{siz}_x$：每个节点子树的大小。</li><li>$\textrm{anc}_x$：每个节点所在重链的链头。</li><li>$\textrm{dfn}_x$：记录每个点的映射。</li><li>$\textrm{rdfn}_x$：记录每个映射对应的点（事实上许多时候不需要维护）。</li></ul><p>我们分为两次。第一次处理前四个很容易处理的数组。第二次处理后三个。其实现只需要用基本的 dfs 即可。</p><h3 id="回答：最近公共祖先"><a href="#回答：最近公共祖先" class="headerlink" title="回答：最近公共祖先"></a>回答：最近公共祖先</h3><p>既然轻重链剖分的优势就是只要跳 $O(\log n)$ 次重链，我们就考虑两边分别向上跳重链。</p><p>那么我们就只有两个问题：每次由谁跳？跳到啥时候算完？</p><p>第二个问题比较好处理：如果两个点在同一重链上，其中深度低的必然就是最近公共祖先。</p><p>对于每次由谁跳，我们想想判断的依据。因为每次都是直接跳到节点所在链头之上，所以起决定作用的应该是两节点所在链头的深度。</p><p>显然，如果先跳链头低的，一定不会超过最近公共祖先。否则，如果先跳链头高的，可能就会超高了。</p><h3 id="回答：路径修改-查询"><a href="#回答：路径修改-查询" class="headerlink" title="回答：路径修改/查询"></a>回答：路径修改/查询</h3><p>我们知道一条重链上的点，映射是连续的。所以我们只需要套一个 LCA 的求法，用数据结构维护映射后的数组，每次修改/查询就是多个区间的修改/查询。</p><h3 id="回答：子树修改-查询"><a href="#回答：子树修改-查询" class="headerlink" title="回答：子树修改/查询"></a>回答：子树修改/查询</h3><p>我们还知道，在 DFS 序里，同一子树的映射也是连续的（即 $[\textrm{dfn}_u, \textrm{dfn}_u + \textrm{siz}_u)$）。所以我们甚至不用跳，直接一次区间修改/查询即可。</p><h3 id="数据结构选用"><a href="#数据结构选用" class="headerlink" title="数据结构选用"></a>数据结构选用</h3><p>我们的数据结构要支持区间修改/区间查询和，而且最好和每次询问的访问数 $O(\log n)$ 契合。显然，线段树是不二之选。当然，树状数组可能也可以。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MXV = <span class="hljs-number">100005</span>;<br><span class="hljs-type">int</span> val[MXV];<br><span class="hljs-type">int</span> DVS;<br><span class="hljs-type">int</span> root, V, opts;<br><br><span class="hljs-type">int</span> to[MXV &lt;&lt; <span class="hljs-number">1</span>], nxt[MXV &lt;&lt; <span class="hljs-number">1</span>], head[MXV], egsz;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  to[egsz] = b;<br>  nxt[egsz] = head[a];<br>  head[a] = egsz++;<br>&#125;<br><br><span class="hljs-type">int</span> siz[MXV], depth[MXV], fa[MXV], son[MXV];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f, <span class="hljs-type">int</span> h)</span> </span>&#123;<br>  siz[x] = <span class="hljs-number">1</span>;<br>  depth[x] = h;<br>  fa[x] = f;<br>  son[x] = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(head[x]); ~i; i = nxt[i]) &#123;<br>    <span class="hljs-keyword">if</span> (to[i] != f) &#123;<br>      <span class="hljs-built_in">init1</span>(to[i], x, h + <span class="hljs-number">1</span>);<br>      siz[x] += siz[to[i]];<br>      <span class="hljs-keyword">if</span> (!~son[x] || siz[to[i]] &gt; siz[son[x]]) son[x] = to[i];<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> anc[MXV], ptoi[MXV], itop[MXV], dfn;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init2</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> a)</span> </span>&#123;<br>  anc[x] = a;<br>  ptoi[x] = dfn, itop[dfn++] = x;<br>  <span class="hljs-keyword">if</span> (~son[x]) &#123;<br>    <span class="hljs-built_in">init2</span>(son[x], a);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(head[x]); ~i; i = nxt[i])<br>      <span class="hljs-keyword">if</span> (to[i] != fa[x] &amp;&amp; to[i] != son[x]) <span class="hljs-built_in">init2</span>(to[i], to[i]);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> sum[MXV &lt;&lt; <span class="hljs-number">2</span>], tag[MXV &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init3</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (r - l == <span class="hljs-number">1</span>) &#123;<br>    sum[cur] = val[itop[l]] % DVS;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mid</span><span class="hljs-params">((l + r) &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-built_in">init3</span>((cur &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, l, mid);<br>  <span class="hljs-built_in">init3</span>((cur + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>, mid, r);<br>  sum[cur] = (sum[(cur &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>] + sum[(cur + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>]) % DVS;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ls</span><span class="hljs-params">((p &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">rs</span><span class="hljs-params">((p + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mid</span><span class="hljs-params">((r + l) &gt;&gt; <span class="hljs-number">1</span>)</span></span>;<br>  tag[ls] = (tag[ls] + tag[p]) % DVS;<br>  sum[ls] = (sum[ls] + (mid - l) % DVS * tag[p] % DVS) % DVS;<br>  tag[rs] = (tag[rs] + tag[p]) % DVS;<br>  sum[rs] = (sum[rs] + (r - mid) % DVS * tag[p] % DVS) % DVS;<br>  tag[p] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>  sum[p] = (sum[(p &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>] + sum[(p + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>]) % DVS;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> curl, <span class="hljs-type">int</span> curr, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (curr &lt;= l || curl &gt;= r) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (curl &gt;= l &amp;&amp; curr &lt;= r) &#123;<br>    tag[cur] = (tag[cur] + k) % DVS;<br>    sum[cur] = (sum[cur] + (curr - curl) % DVS * k % DVS) % DVS;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">pushdown</span>(cur, curl, curr);<br>  <span class="hljs-built_in">add</span>((cur &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, l, r, curl, (curl + curr) &gt;&gt; <span class="hljs-number">1</span>, k);<br>  <span class="hljs-built_in">add</span>((cur + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>, l, r, (curl + curr) &gt;&gt; <span class="hljs-number">1</span>, curr, k);<br>  <span class="hljs-built_in">pushup</span>(cur);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> curl, <span class="hljs-type">int</span> curr)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (curr &lt;= l || curl &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (curl &gt;= l &amp;&amp; curr &lt;= r) <span class="hljs-keyword">return</span> sum[cur];<br>  <span class="hljs-built_in">pushdown</span>(cur, curl, curr);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">ask</span>((cur &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, l, r, curl, (curl + curr) &gt;&gt; <span class="hljs-number">1</span>) +<br>          <span class="hljs-built_in">ask</span>((cur + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>, l, r, (curl + curr) &gt;&gt; <span class="hljs-number">1</span>, curr)) %<br>         DVS;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">c</span><span class="hljs-params">(getchar())</span></span>;<br>  <span class="hljs-keyword">while</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">while</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>    x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">10</span>) <span class="hljs-built_in">write</span>(x / <span class="hljs-number">10</span>);<br>  <span class="hljs-built_in">putchar</span>((x % <span class="hljs-number">10</span>) | <span class="hljs-number">48</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  V = <span class="hljs-built_in">read</span>(), opts = <span class="hljs-built_in">read</span>(), root = <span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>, DVS = <span class="hljs-built_in">read</span>();<br>  <span class="hljs-built_in">fill</span>(head, head + V, <span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != V; ++i) cin &gt;&gt; val[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">1</span>), a, b; i != V; ++i) &#123;<br>    a = <span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>, b = <span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">addedge</span>(a, b), <span class="hljs-built_in">addedge</span>(b, a);<br>  &#125;<br>  <span class="hljs-built_in">init1</span>(root, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">init2</span>(root, root);<br>  <span class="hljs-built_in">init3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, V);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> opt, x, y, z; opts--;) &#123;<br>    opt = <span class="hljs-built_in">read</span>(), x = <span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">switch</span> (opt) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>        y = <span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>;<br>        z = <span class="hljs-built_in">read</span>() % DVS;<br>        <span class="hljs-keyword">while</span> (anc[x] != anc[y]) &#123;<br>          <span class="hljs-keyword">if</span> (depth[anc[x]] &lt; depth[anc[y]]) <span class="hljs-built_in">swap</span>(x, y);<br>          <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, ptoi[anc[x]], ptoi[x] + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, V, z);<br>          x = fa[anc[x]];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (depth[x] &lt; depth[y]) <span class="hljs-built_in">swap</span>(x, y);<br>        <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, ptoi[y], ptoi[x] + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, V, z);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;<br>        y = <span class="hljs-built_in">read</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (anc[x] != anc[y]) &#123;<br>          <span class="hljs-keyword">if</span> (depth[anc[x]] &lt; depth[anc[y]]) <span class="hljs-built_in">swap</span>(x, y);<br>          sum = (sum + <span class="hljs-built_in">ask</span>(<span class="hljs-number">0</span>, ptoi[anc[x]], ptoi[x] + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, V)) % DVS;<br>          x = fa[anc[x]];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (depth[x] &lt; depth[y]) <span class="hljs-built_in">swap</span>(x, y);<br>        <span class="hljs-built_in">write</span>((sum + <span class="hljs-built_in">ask</span>(<span class="hljs-number">0</span>, ptoi[y], ptoi[x] + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, V)) % DVS), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: &#123;<br>        z = <span class="hljs-built_in">read</span>() % DVS;<br>        <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, ptoi[x], ptoi[x] + siz[x], <span class="hljs-number">0</span>, V, z);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: &#123;<br>        <span class="hljs-built_in">write</span>(<span class="hljs-built_in">ask</span>(<span class="hljs-number">0</span>, ptoi[x], ptoi[x] + siz[x], <span class="hljs-number">0</span>, V)), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><a href="https://www.luogu.com.cn/problem/P2590">P2590 [ZJOI2008]树的统计</a></p><p><a href="https://www.luogu.com.cn/problem/P2486">P2486 [SDOI2011]染色</a></p><p><a href="https://www.luogu.com.cn/problem/P7735">P7735 [NOI2021] 轻重边</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记 - 珂朵莉树</title>
    <link href="/note-odt/"/>
    <url>/note-odt/</url>
    
    <content type="html"><![CDATA[<p>珂朵莉树，是一个暴力数据结构。它可用于含有区间赋值的区间维护题目，最好数据随机。其起源于 <a href="https://www.luogu.com.cn/problem/CF896C">CF896C</a>。</p><hr><h2 id="例题：CF896C-Willem-Chtholly-and-Seniorious"><a href="#例题：CF896C-Willem-Chtholly-and-Seniorious" class="headerlink" title="例题：CF896C Willem, Chtholly and Seniorious"></a>例题：CF896C Willem, Chtholly and Seniorious</h2><p>请你写一种奇怪的数据结构，支持：</p><ul><li>$1$ $l$ $r$ $x$：将 $[l,r]$ 区间所有数加上 $x$；</li><li>$2$ $l$ $r$ $x$：将 $[l,r]$ 区间所有数改成 $x$；</li><li>$3$ $l$ $r$ $x$：输出将 $[l,r]$ 区间从小到大排序后的第 $x$ 个数是多少（即区间第 $x$ 小，数字大小相同算多次，保证 $1 \leq x \leq r-l+1$）；</li><li>$4$ $l$ $r$ $x$ $y$：输出 $[l,r]$ 区间每个数字的 $x$ 次方的和模 $y$ 的值（即 $(\sum^r_{i=l}a_i^x) \bmod y$）。</li></ul><p>数据随机生成。</p><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>友情提示，代码多用前闭后开区间。</strong></p><p>珂朵莉树的核心思想是把一段值相同的区间存成一个块。</p><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>珂朵莉树使用 <code>set</code> 来维护每个块。</p><p>对于每个块，只需要维护其左端点、右端点与其值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>  ull l, r;<br>  <span class="hljs-keyword">mutable</span> ull v;<br>  <span class="hljs-built_in">Node</span>(ull _l = <span class="hljs-number">0</span>, ull _r = <span class="hljs-number">0</span>, ull _v = <span class="hljs-number">0</span>): <span class="hljs-built_in">l</span>(_l), <span class="hljs-built_in">r</span>(_r), <span class="hljs-built_in">v</span>(_v) &#123;&#125;<br>&#125;;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Node lhs, Node rhs) &#123; <span class="hljs-keyword">return</span> lhs.l &lt; rhs.l; &#125;<br></code></pre></td></tr></table></figure><p>至于为什么有 <code>mutable</code> 一词出现，可以试试不加，会 CE。<code>operator&lt;</code> 是要每个块在 <code>set</code> 中以左端点排序。</p><h3 id="核心操作：split"><a href="#核心操作：split" class="headerlink" title="核心操作：split"></a>核心操作：split</h3><p>这个操作用于将 $[l,r]$ 的块拆成 $[l,pos-1]$ 与 $[pos,r]$ 的两个块。返回的是 $[pos,r]$ 的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChtholyTree</span><br>&#123;<br>  set&lt;Node&gt; nodes;<br>  set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">split</span><span class="hljs-params">(ull pos)</span></span><br><span class="hljs-function">  </span>&#123;<br>    set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">i</span><span class="hljs-params">(nodes.lower_bound(Node(pos)))</span></span>;<br>    <span class="hljs-keyword">if</span> (i != nodes.<span class="hljs-built_in">end</span>() &amp;&amp; i-&gt;l == pos) <span class="hljs-keyword">return</span> i;<br>    --i;<br>    <span class="hljs-keyword">if</span> (i-&gt;r &lt;= pos) <span class="hljs-keyword">return</span> nodes.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-function">ull <span class="hljs-title">l</span><span class="hljs-params">(i-&gt;l)</span>, <span class="hljs-title">r</span><span class="hljs-params">(i-&gt;r)</span>, <span class="hljs-title">v</span><span class="hljs-params">(i-&gt;v)</span></span>;<br>    nodes.<span class="hljs-built_in">erase</span>(i);<br>    nodes.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Node</span>(l, pos, v));<br>    <span class="hljs-keyword">return</span> nodes.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Node</span>(pos, r, v)).first;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先用 <code>lower_bound</code>，来找到起点大于等于 <code>pos</code> 的最左块。</p><p>如果这个块的起点刚好是 <code>pos</code>，显然不需要再分裂，直接 <code>return</code> 即可。</p><p>否则，含有 <code>pos</code> 的块就必然是前面一块。</p><p>如果此时，<code>pos</code> 依然不在当前块中，显然 <code>pos</code> 必然不合法，返回 <code>end()</code> 迭代器。</p><p>当我找到了 <code>pos</code> 的所在块，我们就暴力分裂。将原来的块 <code>erase</code>，将两个新块分别 <code>insert</code>。</p><p><code>set.insert()</code> 返回 <code>pair&lt;iterator, bool&gt;</code>，前者即是我们要的，<code>return</code> 即可。</p><p><strong><code>split</code> 操作是珂朵莉树的核心。它是所有的其它<del>暴力</del>操作的基石。</strong></p><h3 id="操作一：区间加"><a href="#操作一：区间加" class="headerlink" title="操作一：区间加"></a>操作一：区间加</h3><p>我们只要找到左右两个端点之间的所有块，分别加，即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ull l, ull r, ull v)</span></span><br><span class="hljs-function"></span>&#123;<br>    set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">rp</span><span class="hljs-params">(split(r))</span>, <span class="hljs-title">lp</span><span class="hljs-params">(split(l))</span></span>;<br>    <span class="hljs-keyword">while</span> (lp != rp)<br>        lp-&gt;v += v, ++lp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="操作二：区间赋值（推平）"><a href="#操作二：区间赋值（推平）" class="headerlink" title="操作二：区间赋值（推平）"></a>操作二：区间赋值（推平）</h3><p>我们将左右两端点之间的所有块全删了，然后添加一个新的大块即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(ull l, ull r, ull v)</span></span><br><span class="hljs-function"></span>&#123;<br>    set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">rp</span><span class="hljs-params">(split(r))</span>, <span class="hljs-title">lp</span><span class="hljs-params">(split(l))</span></span>;<br>    nodes.<span class="hljs-built_in">erase</span>(lp, rp);<br>    nodes.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Node</span>(l, r, v));<br>&#125;<br></code></pre></td></tr></table></figure><p>暴力吧？</p><h3 id="操作三：区间第-k-小"><a href="#操作三：区间第-k-小" class="headerlink" title="操作三：区间第 $k$ 小"></a>操作三：区间第 $k$ 小</h3><p>将两端点中的每个块抽出来，保留其值与大小。对抽出来的块的值进行排序，从前往后扫，扫到 $k$ 就得出答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ull <span class="hljs-title">kth</span><span class="hljs-params">(ull l, ull r, ull k)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;pair&lt;ull, ull&gt; &gt; rnks;<br>    set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">rp</span><span class="hljs-params">(split(r))</span>, <span class="hljs-title">lp</span><span class="hljs-params">(split(l))</span></span>;<br>    <span class="hljs-keyword">while</span> (lp != rp)<br>        rnks.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(lp-&gt;v, lp-&gt;r - lp-&gt;l)), ++lp;<br>    <span class="hljs-built_in">sort</span>(rnks.<span class="hljs-built_in">begin</span>(), rnks.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (vector&lt;pair&lt;ull, ull&gt; &gt;::const_iterator <span class="hljs-built_in">i</span>(rnks.<span class="hljs-built_in">begin</span>()); i != rnks.<span class="hljs-built_in">end</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i-&gt;second &gt;= k) <span class="hljs-keyword">return</span> i-&gt;first;<br>        k -= i-&gt;second;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="操作四：区间乘幂求和"><a href="#操作四：区间乘幂求和" class="headerlink" title="操作四：区间乘幂求和"></a>操作四：区间乘幂求和</h3><p>对每个块的值使用快速幂，乘该块的大小，求和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ull <span class="hljs-title">pow</span><span class="hljs-params">(ull a, ull p, ull b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">ull <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; a %= b;<br>  <span class="hljs-keyword">while</span> (p) &#123;<br>    <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>) res = res * a % b;<br>    a = a * a % b;<br>    p &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res % b;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">pow</span><span class="hljs-params">(ull l, ull r, ull x, ull y)</span></span><br><span class="hljs-function"></span>&#123;<br>    set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">rp</span><span class="hljs-params">(split(r))</span>, <span class="hljs-title">lp</span><span class="hljs-params">(split(l))</span></span>;<br>    <span class="hljs-function">ull <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (lp != rp)<br>        res = (res + (lp-&gt;r - lp-&gt;l) * ::<span class="hljs-built_in">pow</span>(lp-&gt;v, x, y) % y) % y, ++lp;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>注意，对于所有衍生操作，<code>split</code> 的时候一定是先右再左！不然可能会使指针无效。</p><p>对于块，注意 <code>mutable</code> 和 <code>operator&lt;</code>。</p><p>珂朵莉树在数据比较合理的情况下，跑的很快。同是维护区间数据的数据结构，思维难度比线段树简单，但是时间复杂度不太稳。珂朵莉树的时间复杂度其实比较玄学，如果块太散，是很慢的。有适当的区间推平操作，珂朵莉树才有用。并且，如果数据不随机，也可能卡掉，数据随机会比较稳。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>  ull l, r;<br>  <span class="hljs-keyword">mutable</span> ull v;<br>  <span class="hljs-built_in">Node</span>(ull _l = <span class="hljs-number">0</span>, ull _r = <span class="hljs-number">0</span>, ull _v = <span class="hljs-number">0</span>): <span class="hljs-built_in">l</span>(_l), <span class="hljs-built_in">r</span>(_r), <span class="hljs-built_in">v</span>(_v) &#123;&#125;<br>&#125;;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Node lhs, Node rhs) &#123; <span class="hljs-keyword">return</span> lhs.l &lt; rhs.l; &#125;<br><br><span class="hljs-function">ull <span class="hljs-title">pow</span><span class="hljs-params">(ull a, ull p, ull b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">ull <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; a %= b;<br>  <span class="hljs-keyword">while</span> (p) &#123;<br>    <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>) res = res * a % b;<br>    a = a * a % b;<br>    p &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res % b;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChtholyTree</span><br>&#123;<br>  set&lt;Node&gt; nodes;<br>  <span class="hljs-built_in">ChtholyTree</span>() &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addnode</span><span class="hljs-params">(ull l, ull r, ull v)</span> </span>&#123; nodes.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Node</span>(l, r, v)); &#125;<br>  set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">split</span><span class="hljs-params">(ull pos)</span></span><br><span class="hljs-function">  </span>&#123;<br>    set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">i</span><span class="hljs-params">(nodes.lower_bound(Node(pos)))</span></span>;<br>    <span class="hljs-keyword">if</span> (i != nodes.<span class="hljs-built_in">end</span>() &amp;&amp; i-&gt;l == pos) <span class="hljs-keyword">return</span> i;<br>    --i;<br>    <span class="hljs-keyword">if</span> (i-&gt;r &lt;= pos) <span class="hljs-keyword">return</span> nodes.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-function">ull <span class="hljs-title">l</span><span class="hljs-params">(i-&gt;l)</span>, <span class="hljs-title">r</span><span class="hljs-params">(i-&gt;r)</span>, <span class="hljs-title">v</span><span class="hljs-params">(i-&gt;v)</span></span>;<br>    nodes.<span class="hljs-built_in">erase</span>(i);<br>    nodes.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Node</span>(l, pos, v));<br>    <span class="hljs-keyword">return</span> nodes.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Node</span>(pos, r, v)).first;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ull l, ull r, ull v)</span></span><br><span class="hljs-function">  </span>&#123;<br>    set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">rp</span><span class="hljs-params">(split(r))</span>, <span class="hljs-title">lp</span><span class="hljs-params">(split(l))</span></span>;<br>    <span class="hljs-keyword">while</span> (lp != rp)<br>      lp-&gt;v += v, ++lp;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(ull l, ull r, ull v)</span></span><br><span class="hljs-function">  </span>&#123;<br>    set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">rp</span><span class="hljs-params">(split(r))</span>, <span class="hljs-title">lp</span><span class="hljs-params">(split(l))</span></span>;<br>    nodes.<span class="hljs-built_in">erase</span>(lp, rp);<br>    nodes.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Node</span>(l, r, v));<br>  &#125;<br>  <span class="hljs-function">ull <span class="hljs-title">kth</span><span class="hljs-params">(ull l, ull r, ull k)</span></span><br><span class="hljs-function">  </span>&#123;<br>    vector&lt;pair&lt;ull, ull&gt; &gt; rnks;<br>    set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">rp</span><span class="hljs-params">(split(r))</span>, <span class="hljs-title">lp</span><span class="hljs-params">(split(l))</span></span>;<br>    <span class="hljs-keyword">while</span> (lp != rp)<br>      rnks.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(lp-&gt;v, lp-&gt;r - lp-&gt;l)), ++lp;<br>    <span class="hljs-built_in">sort</span>(rnks.<span class="hljs-built_in">begin</span>(), rnks.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (vector&lt;pair&lt;ull, ull&gt; &gt;::const_iterator <span class="hljs-built_in">i</span>(rnks.<span class="hljs-built_in">begin</span>()); i != rnks.<span class="hljs-built_in">end</span>(); ++i) &#123;<br>      <span class="hljs-keyword">if</span> (i-&gt;second &gt;= k) <span class="hljs-keyword">return</span> i-&gt;first;<br>      k -= i-&gt;second;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-function">ull <span class="hljs-title">pow</span><span class="hljs-params">(ull l, ull r, ull x, ull y)</span></span><br><span class="hljs-function">  </span>&#123;<br>    set&lt;Node&gt;::<span class="hljs-function">iterator <span class="hljs-title">rp</span><span class="hljs-params">(split(r))</span>, <span class="hljs-title">lp</span><span class="hljs-params">(split(l))</span></span>;<br>    <span class="hljs-function">ull <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (lp != rp)<br>      res = (res + (lp-&gt;r - lp-&gt;l) * ::<span class="hljs-built_in">pow</span>(lp-&gt;v, x, y) % y) % y, ++lp;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RandMachine</span><br>&#123;<br>  ull seed;<br>  <span class="hljs-built_in">RandMachine</span>(ull s): <span class="hljs-built_in">seed</span>(s) &#123;&#125;<br>  <span class="hljs-function">ull <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-function">ull <span class="hljs-title">ret</span><span class="hljs-params">(seed)</span></span>;<br>    seed = (seed * <span class="hljs-number">7</span> + <span class="hljs-number">13</span>) % <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function">ull <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">ull <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">c</span><span class="hljs-params">(getchar())</span></span>;<br>  <span class="hljs-keyword">while</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">while</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function"><span class="hljs-type">const</span> ull <span class="hljs-title">N</span><span class="hljs-params">(read())</span>, <span class="hljs-title">M</span><span class="hljs-params">(read())</span>, <span class="hljs-title">SEED</span><span class="hljs-params">(read())</span>, <span class="hljs-title">VMAX</span><span class="hljs-params">(read())</span></span>;<br>  <span class="hljs-function">RandMachine <span class="hljs-title">rnd</span><span class="hljs-params">(SEED)</span></span>;<br>  ChtholyTree tree;<br>  <span class="hljs-keyword">for</span> (ull <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>    tree.<span class="hljs-built_in">addnode</span>(i, i + <span class="hljs-number">1</span>, <span class="hljs-built_in">rnd</span>() % VMAX + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (ull op, l, r, x, y, <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != M; ++i) &#123;<br>    op = <span class="hljs-built_in">rnd</span>() % <span class="hljs-number">4</span> + <span class="hljs-number">1</span>;<br>    l = <span class="hljs-built_in">rnd</span>() % N + <span class="hljs-number">1</span>;<br>    r = <span class="hljs-built_in">rnd</span>() % N + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-built_in">swap</span>(l, r);<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) x = <span class="hljs-built_in">rnd</span>() % (r - l + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> x = <span class="hljs-built_in">rnd</span>() % VMAX + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-number">4</span>) y = <span class="hljs-built_in">rnd</span>() % VMAX + <span class="hljs-number">1</span>;<br>    --l;<br>    <span class="hljs-keyword">switch</span> (op)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      tree.<span class="hljs-built_in">add</span>(l, r, x); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      tree.<span class="hljs-built_in">assign</span>(l, r, x); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu\n&quot;</span>, tree.<span class="hljs-built_in">kth</span>(l, r, x)); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu\n&quot;</span>, tree.<span class="hljs-built_in">pow</span>(l, r, x, y)); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><a href="https://www.luogu.com.cn/problem/P5568">P5568 [SDOI2008] 校门外的区间</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - NOIP 2021</title>
    <link href="/rec-2021noip/"/>
    <url>/rec-2021noip/</url>
    
    <content type="html"><![CDATA[<h2 id="赛时"><a href="#赛时" class="headerlink" title="赛时"></a>赛时</h2><p>T1 首先看出来是个筛，找出每一个含有数字 7 的数，然后把这些数的倍数筛掉，然后弄成单向链表，预处理就可以了。算出要筛到 $10^7 + 2$。测了几遍，每个样例都能 A，但是有一两次大样例挂了。本来以为应该有更好的算法，但如果真有应该不是我的能力范围内，于是溜了。</p><p>T4 本来看了一下性质，在想有没有性质有用，想过各种怪的算法，最后都弄不出来。于是打暴力，玩模拟。1 边就判断一下能不能走，2 边就试着顺着走到底，3 边就把整个联通块弄出来。前两个样例秒过，第三个样例 1.7sec，第四个样例T死，不会。似乎是个图论题。</p><p>T3 推了式子出来，后来发现推了式子我并不会用，于是只能先打个记忆化搜索，每次就在每个位置都试一下差分，如果重复就不扩展，如果不重复就扩展。第一个样例过了，后三个样例全部 RE。赛时觉得应该是个数学或者搜索题。</p><p>T2 想过各种什么进制，甚至还上了个厕所，还是看不出来。感觉不是常规题，真不会，输出样例，摆烂了。</p><p>赛时感觉精神状态不太好，有点困。</p><hr><h2 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h2><p>第一反应是比较失败，感觉出不来什么好成绩。当时的估分是顶多 $100+0+12+16=128$。有个同学写了 T2 的 50pts 状压 DP，我当时就蒙了：这么烦的题，是状压 DP?!!!! 我哭死了。</p><p>最终居然拿了 $100+0+24+32=156$，T3 很给面子。压线 1=。很难受的就是，居然有两个 DP，真的看不出来……</p><p>觉得主要是两个方面的缺失：一是赛时精神状态一般，这是生活习惯的问题，不过最近有在调整。</p><p>二是后三题真的不会，不会就是不会。这个主要是能力方面，可能需要多接触一些新的题，要在训练中不过多停留在自己的舒适区。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记 - 高斯-约旦消元法</title>
    <link href="/note-gauss/"/>
    <url>/note-gauss/</url>
    
    <content type="html"><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li><p>输入：一个矩阵，表示一个线性方程组。例如 $\begin{bmatrix}2&amp;-1&amp;1&amp;1\4&amp;1&amp;-1&amp;5\1&amp;1&amp;1&amp;0\end{bmatrix}$，表示 $\begin{cases}2x_1 - x_2 + x_3 = 1\4x_1 + x_2 - x_3 = 5\x_1 + x_2 + x_3 = 0\end{cases}$。</p></li><li><p>输出：若方程有唯一解，输出唯一的一组解。如：$\begin{cases}x_1 = 1\x_2 = 0\x_3 = -1\end{cases}$。算法可以判断无解/有无限组解。</p></li><li><p>复杂度：时间：$O(N^3)$，空间：$O(N^2)$。</p></li></ul><hr><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><h3 id="step1-消元"><a href="#step1-消元" class="headerlink" title="step1: 消元"></a>step1: 消元</h3><p>以 $\begin{bmatrix}2&amp;-1&amp;1&amp;1\4&amp;1&amp;-1&amp;5\1&amp;1&amp;1&amp;0\end{bmatrix}$ 为例，</p><p>首先将一至三行中 $x_1$ 项系数绝对值最大的一行（即第二行）移到第一行，得：</p><p>$\begin{bmatrix}4&amp;1&amp;-1&amp;5\2&amp;-1&amp;1&amp;1\1&amp;1&amp;1&amp;0\end{bmatrix}$。</p><p>接着将其他方程中 $x_1$ 项的系数化为0。令第二条方程加上第一条的 $-\frac{1}{2}$ 倍，得：</p><p>$\begin{bmatrix}4&amp;1&amp;-1&amp;5\0&amp;-\frac{3}{2}&amp;\frac{3}{2}&amp;-\frac{3}{2}\1&amp;1&amp;1&amp;0\end{bmatrix}$。</p><p>令第三条方程加上第一条的 $-\frac{1}{4}$ 倍，得：</p><p>$\begin{bmatrix}4&amp;1&amp;-1&amp;5\0&amp;-\frac{3}{2}&amp;\frac{3}{2}&amp;-\frac{3}{2}\0&amp;\frac{3}{4}&amp;\frac{5}{4}&amp;-\frac{5}{4}\end{bmatrix}$。</p><p>接着消第二个元。</p><p>$\begin{bmatrix}4&amp;0&amp;0&amp;4\0&amp;-\frac{3}{2}&amp;\frac{3}{2}&amp;-\frac{3}{2}\0&amp;0&amp;\frac{17}{4}&amp;-\frac{17}{4}\end{bmatrix}$。</p><p>消第三个元。</p><p>$\begin{bmatrix}4&amp;0&amp;0&amp;4\0&amp;-\frac{3}{2}&amp;0&amp;0\0&amp;0&amp;\frac{17}{4}&amp;-\frac{17}{4}\end{bmatrix}$。</p><p>至此，消元完毕。得：</p><p>$\begin{cases}4x_1=4\-\frac{3}{2}x_2=0\\frac{17}{4}x_3=-\frac{17}{4}\end{cases}$。</p><h3 id="step2-系数化为-1"><a href="#step2-系数化为-1" class="headerlink" title="step2: 系数化为 1"></a>step2: 系数化为 1</h3><p>系数化一，将矩阵化为单位矩阵，得：</p><p>$\begin{bmatrix}1&amp;0&amp;0&amp;1\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;-1\end{bmatrix}$。</p><p>所以，原方程组的解就是：</p><p>$\begin{cases}x_1 = 1\x_2 = 0\x_3 = -1\end{cases}$。</p><h3 id="step3-检查无解-无穷解"><a href="#step3-检查无解-无穷解" class="headerlink" title="step3: 检查无解/无穷解"></a>step3: 检查无解/无穷解</h3><p>如果在消元时，碰到某一元系数为 0，就先跳过。到最后再来看，只要有一个出现 $bx=0(b\ne0)$ 就是无解，如果都是 $0x=0$，就是无限组解。</p><p>可以发现，对于每个元，需要 $O(N^2)$ 的时间来对每一项加减，来消元。这就是其时间复杂度由来。</p><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P3389-【模板】高斯消元法"><a href="#P3389-【模板】高斯消元法" class="headerlink" title="P3389 【模板】高斯消元法"></a><a href="https://www.luogu.com.cn/problem/P3389">P3389 【模板】高斯消元法</a></h3><p>模板题。不需要判断无解或无穷解，只要碰到某元系数为 0，即可跳出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">double</span> matrix[<span class="hljs-number">100</span>][<span class="hljs-number">101</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 读入</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    cin &gt;&gt; N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j &lt;= N; ++j)<br>            cin &gt;&gt; matrix[i][j];<br>    <span class="hljs-comment">// 加减消元</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>        <span class="hljs-comment">// 找到系数绝对值最大的行</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mx</span><span class="hljs-params">(i)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(i + <span class="hljs-number">1</span>); j != N; ++j)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(matrix[j][i]) &gt; <span class="hljs-built_in">fabs</span>(matrix[mx][i]))<br>                mx = j;<br>        <span class="hljs-keyword">if</span> (i != mx)<br>            <span class="hljs-built_in">swap</span>(matrix[i], matrix[mx]);<br>        <span class="hljs-keyword">if</span> (!matrix[i][i]) &#123; <span class="hljs-comment">// 无解/无限组解</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;No Solution&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 加减</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != N; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (j != i) &#123;<br>                <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">quot</span><span class="hljs-params">(matrix[j][i] / matrix[i][i])</span></span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">0</span>); k &lt;= N; ++k) &#123;<br>                    matrix[j][k] -= matrix[i][k] * quot;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 系数化为1 &amp; 输出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; fixed &lt;&lt; matrix[i][N] / matrix[i][i] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="P2455-SDOI2006-线性方程组"><a href="#P2455-SDOI2006-线性方程组" class="headerlink" title="P2455 [SDOI2006]线性方程组"></a><a href="https://www.luogu.com.cn/problem/P2455">P2455 [SDOI2006]线性方程组</a></h3><p>其实也是模板，比上一个模板更细一些。注意细节！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">double</span> matrix[<span class="hljs-number">50</span>][<span class="hljs-number">51</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">N</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    cin &gt;&gt; N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j &lt;= N; ++j)<br>            cin &gt;&gt; matrix[i][j];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cur</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 这是一个细节！找系数绝对值最大的行时，范围是 [cur, N)，关注 cur 的变化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mx</span><span class="hljs-params">(cur)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(cur + <span class="hljs-number">1</span>); j != N; ++j)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(matrix[j][i]) &gt; <span class="hljs-built_in">fabs</span>(matrix[mx][i]))<br>                mx = j;<br>        <span class="hljs-keyword">if</span> (!matrix[mx][i]) <span class="hljs-comment">// 无解</span><br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (cur != mx)<br>            <span class="hljs-built_in">swap</span>(matrix[cur], matrix[mx]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">j</span>(<span class="hljs-number">0</span>); j != N; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (j != cur) &#123;<br>                <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">quot</span><span class="hljs-params">(matrix[j][i] / matrix[cur][i])</span></span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">k</span>(<span class="hljs-number">0</span>); k &lt;= N; ++k) &#123;<br>                    matrix[j][k] -= matrix[cur][k] * quot;<br>                &#125;<br>            &#125;<br>        &#125;<br>        ++cur;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur != N) &#123;<br>        <span class="hljs-keyword">while</span> (cur != N)<br>            <span class="hljs-keyword">if</span> (matrix[cur++][N]) &#123; <span class="hljs-comment">// 无解 只要有一个无解，无限组解也是无解</span><br>                cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 无限组解</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">i</span>(<span class="hljs-number">0</span>); i != N; ++i) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&#x27;x&#x27;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;=&#x27;</span> &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; fixed &lt;&lt; matrix[i][N] / matrix[i][i] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - CSP 2021</title>
    <link href="/rec-2021csp/"/>
    <url>/rec-2021csp/</url>
    
    <content type="html"><![CDATA[<h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><p><em>Updated on 2025.8.31: 这里本来应该有几个链接的，但是现在都失效了。</em></p><hr><h2 id="初赛篇"><a href="#初赛篇" class="headerlink" title="初赛篇"></a>初赛篇</h2><hr><h3 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY -1"></a>DAY -1</h3><p><em>2021.9.18.</em></p><p>历史步步高砸了，但是换回了一个小憩，哈哈。</p><h3 id="DAY-0"><a href="#DAY-0" class="headerlink" title="DAY 0"></a>DAY 0</h3><p><em>2021.9.19.</em></p><p>和 一个外校神仙OIer 和 一个同校OIer 同车去。</p><h4 id="MORNING-SENIOR"><a href="#MORNING-SENIOR" class="headerlink" title="MORNING: SENIOR"></a>MORNING: SENIOR</h4><h5 id="做题有感"><a href="#做题有感" class="headerlink" title="做题有感"></a>做题有感</h5><p>《计算几何》</p><p>《手动编码》</p><p>《Four Russians》</p><p>《笛卡尔树》</p><p><del>发出恶臭的声音。</del></p><h5 id="画外音"><a href="#画外音" class="headerlink" title="画外音"></a>画外音</h5><p>估分 70.5。悬。</p><hr><h4 id="AFTERNOON-JUNIOR"><a href="#AFTERNOON-JUNIOR" class="headerlink" title="AFTERNOON: JUNIOR"></a>AFTERNOON: JUNIOR</h4><h5 id="做题有感-1"><a href="#做题有感-1" class="headerlink" title="做题有感"></a>做题有感</h5><p>$61 \times 3$ 算成 186 可以卡多久……</p><p>字符串编码跟上午相似，简单一些。</p><p>“c.s.q.<del>n.</del>“</p><h5 id="画外音-1"><a href="#画外音-1" class="headerlink" title="画外音"></a>画外音</h5><p>估分 90.5。要没。</p><p>上午的分赛区写了“广州”，下午写了“广东”，应该不影响。嗯。</p><p>黑笔居然没水，把我急的。还好老师有借我一支笔。老师真好。</p><p>和 一个外校神仙 OIer &amp; 一个同校 OIer 同车回。</p><hr><h3 id="DAY-N"><a href="#DAY-N" class="headerlink" title="DAY +N"></a>DAY +N</h3><p><em>2021.9.22.</em></p><p>Junior: 93.5.</p><p>Senior: 70.5.</p><p>广州市 Junior 初赛 第一？</p><hr><h2 id="复赛篇"><a href="#复赛篇" class="headerlink" title="复赛篇"></a>复赛篇</h2><hr><h3 id="DAY-1-1"><a href="#DAY-1-1" class="headerlink" title="DAY -1"></a>DAY -1</h3><p><em>2021.10.22.</em></p><p>开了个赛前的会儿，合了个照，A 了个树形 DP，比较轻松。</p><p>据说我长得比一些高一的还高？</p><hr><h3 id="DAY-0-1"><a href="#DAY-0-1" class="headerlink" title="DAY 0"></a>DAY 0</h3><p><em>2021.10.23.</em></p><h4 id="MORNING-JUNIOR"><a href="#MORNING-JUNIOR" class="headerlink" title="MORNING: JUNIOR"></a>MORNING: JUNIOR</h4><p>策略第一，先断顺序：</p><p>1,3,4,2.</p><h5 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h5><p>发现结果最大是 $K - 1$。 如果不可能是 $K - 1$，那必然是 $R \bmod K$，因为 $L \le R$。</p><p>核实一下结论，差不多，写完代码，下一题。</p><h5 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h5><p>轻松地模拟。按他的定义，一项一项来，先看整体格式（是不是 <code>%d.%d.%d.%d:%d</code> 的格式，有没有不该有的符号），再看值在不在范围内，最后看前导 0，完事。</p><p>测了大样例，没问题，就不管了。</p><p>T4 想到链表/并查集，但是怎么推都太乱了，暂时搁置。</p><h5 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h5><p>一直在想应该用什么数据结构，后来打了个 $O(NQ)$，碰到一个 2 操作就暴力求排名。</p><p>期间明明想过 $O(5000N + Q + N \log N)$ 的正解（碰到一个 1 操作就暴力插入排序，2 操作变成 $O(1)$），然后没写……</p><h5 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h5><p>定义 $T_i$ 为第 $i$ 个数死亡时刻。初始化 $T_i$ 为在块中的位置。</p><p>它只有两种方式推到：要么是初始化，要么就是找到 $j \le i$ 满足 $\textrm{color}_i = \textrm{color}_j$，</p><p>设有 $j + 1 \le k \le i - 1$，则 $T_i &gt; \max{T_k}$，$T_j &gt; \max{T_k}$。</p><p>此时，$T_i = \max(T_i, T_j + 1)$。</p><p>可以用单调栈维护，但是没调出来，最后打了一个 $O(N^2)$。</p><p>要结束了，慌乱地删了 checker，很怕不小心把自己代码删了。</p><p>估：$100 + 76 + 100 + 30 = 316$。</p><hr><h4 id="AFTERNOON-SENIOR"><a href="#AFTERNOON-SENIOR" class="headerlink" title="AFTERNOON: SENIOR"></a>AFTERNOON: SENIOR</h4><p>看了一遍题，打算顺序：</p><p>1,2,3,4.</p><p>笑死，一个都不会。</p><h5 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h5><p>感觉像单峰/双峰函数，随后写了一个类似于模拟退火的鬼东西，调了 1.5h，样例都过了，溜了。</p><h5 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h5><p>就偷偷拿个全问号的 DP 部分分，按照他给的每一条性质一个个来，连判重都没判，也不知道怎么核对，先溜了，又不会。</p><h5 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h5><p>性质没看懂，拿了一个回文的部分分，溜了。</p><h5 id="T4-1"><a href="#T4-1" class="headerlink" title="T4"></a>T4</h5><p>看 $K \le 2$ 的部分分：网络流。</p><p>调了个 Dinic。<del>差点写挂。</del></p><p>一测大样例，忽然发现怎么数据那么大，部分分都不让我好好拿？？？$O(N^3M^3)$ 的网络流被卡死。$N,M \le 18$ 都很危。</p><p>上了个厕所，然后发现，还是不会啊……</p><p>估：$100 + 0 + 4 + 15 = 119$。</p><hr><h4 id="画外音-2"><a href="#画外音-2" class="headerlink" title="画外音"></a>画外音</h4><p>这次跟上次一个学校，但是走不同的门。</p><p>这次 DP 少的可怜，而且还都挺烦的。</p><p>洛谷估分：</p><p>Junior: $100 + 76 + 100 + 70 = 346$.</p><p>Senior: $20 + 0 + 0 + 0 = 20$.</p><p>能力不行。</p><p><del>Junior T4 那么高分吗？乱搞做法大胜利。</del></p><p>再接再厉。</p><p>外校神仙OIer，洛谷自测，AK Junior， Senior 128，\%\%\%。</p><hr><h3 id="DAY-1-2"><a href="#DAY-1-2" class="headerlink" title="DAY +1"></a>DAY +1</h3><p><em>2021.10.24.</em></p><p>看了初三学长的博客，跟他们聊一聊。</p><p>好心痛。</p><p>这是他们初中 OI 的句号。</p><p>我不知道 6 月 31 号是什么特殊的日子，但是我希望你好起来。</p><p>我不知道 128 分能不能拿到 Senior 1=，但是我希望你好起来。</p><p><del>溜去做作业力。</del></p><hr><h3 id="DAY-N-1"><a href="#DAY-N-1" class="headerlink" title="DAY +N"></a>DAY +N</h3><p><em>2021.10.30.</em></p><p>Junior: $100 + 76 + 100 + 60 = 336$。</p><p>Senior: $30 + 0 + 20 + 5 = 55$。</p><p>现在全部高于洛谷分了。</p><p>看到学长主要也是高于洛谷分，也很开心。</p><p>上午打了把 NOIP 模拟赛，$40 + 100 + 30 + 25 = 195$。</p><p>接下来，就是为 期中，NOIP，CCPC 奋斗。</p><p>加油！</p><hr><p><em>Updated on 2025.8.31: 其实上文的 Dinic 的确是假的，不然能有 30pts。</em></p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
